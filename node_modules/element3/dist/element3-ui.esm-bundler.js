/*!
  * element3 v0.0.26
  * (c) 2020 kkb
  * @license MIT
  */
import { h, Transition, computed, provide, getCurrentInstance, toRefs, unref, openBlock, createBlock, renderSlot, inject, createCommentVNode, mergeProps, ref, nextTick, withKeys, withModifiers, createVNode, withDirectives, vModelRadio, Fragment, createTextVNode, toDisplayString, watch, onMounted, resolveDynamicComponent, withCtx, reactive, watchEffect, toRef, onUpdated, isRef, resolveComponent, resolveDirective, onBeforeUnmount, onBeforeMount, vShow, onUnmounted, TransitionGroup, renderList, vModelText, createSlots, onBeforeUpdate, createApp, Teleport, render as render$1p, defineComponent, isVNode } from 'vue';

/* istanbul ignore next */

const SPECIAL_CHARS_REGEXP = /([\:\-\_]+(.))/g;
const MOZ_HACK_REGEXP = /^moz([A-Z])/;
const ieVersion =  Number(document.documentMode);
/* istanbul ignore next */

const trim = function (string) {
  return (string || '').replace(/^[\s\uFEFF]+|[\s\uFEFF]+$/g, '');
};
/* istanbul ignore next */


const camelCase = function (name) {
  return name.replace(SPECIAL_CHARS_REGEXP, function (_, separator, letter, offset) {
    return offset ? letter.toUpperCase() : letter;
  }).replace(MOZ_HACK_REGEXP, 'Moz$1');
};
/* istanbul ignore next */


const on = function () {
  if ( document.addEventListener) {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.addEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event && handler) {
        element.attachEvent('on' + event, handler);
      }
    };
  }
}();
/* istanbul ignore next */

const off = function () {
  if ( document.removeEventListener) {
    return function (element, event, handler) {
      if (element && event) {
        element.removeEventListener(event, handler, false);
      }
    };
  } else {
    return function (element, event, handler) {
      if (element && event) {
        element.detachEvent('on' + event, handler);
      }
    };
  }
}();
/* istanbul ignore next */

const once = function (el, event, fn) {
  var listener = function () {
    if (fn) {
      fn.apply(this, arguments);
    }

    off(el, event, listener);
  };

  on(el, event, listener);
};
/* istanbul ignore next */

function hasClass(el, cls) {
  if (!el || !cls) return false;
  if (cls.indexOf(' ') !== -1) throw new Error('className should not contain space.');

  if (el.classList) {
    return el.classList.contains(cls);
  } else {
    return (' ' + el.className + ' ').indexOf(' ' + cls + ' ') > -1;
  }
}
/* istanbul ignore next */

function addClass(el, cls) {
  if (!el) return;
  var curClass = el.className;
  var classes = (cls || '').split(' ');

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.add(clsName);
    } else if (!hasClass(el, clsName)) {
      curClass += ' ' + clsName;
    }
  }

  if (!el.classList) {
    el.className = curClass;
  }
}
/* istanbul ignore next */

function removeClass(el, cls) {
  if (!el || !cls) return;
  var classes = cls.split(' ');
  var curClass = ' ' + el.className + ' ';

  for (var i = 0, j = classes.length; i < j; i++) {
    var clsName = classes[i];
    if (!clsName) continue;

    if (el.classList) {
      el.classList.remove(clsName);
    } else if (hasClass(el, clsName)) {
      curClass = curClass.replace(' ' + clsName + ' ', ' ');
    }
  }

  if (!el.classList) {
    el.className = trim(curClass);
  }
}
/* istanbul ignore next */

const getStyle = ieVersion < 9 ? function (element, styleName) {
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);

  if (styleName === 'float') {
    styleName = 'styleFloat';
  }

  try {
    switch (styleName) {
      case 'opacity':
        try {
          return element.filters.item('alpha').opacity / 100;
        } catch (e) {
          return 1.0;
        }

      default:
        return element.style[styleName] || element.currentStyle ? element.currentStyle[styleName] : null;
    }
  } catch (e) {
    return element.style[styleName];
  }
} : function (element, styleName) {
  if (!element || !styleName) return null;
  styleName = camelCase(styleName);

  if (styleName === 'float') {
    styleName = 'cssFloat';
  }

  try {
    var computed = document.defaultView.getComputedStyle(element, '');
    return element.style[styleName] || computed ? computed[styleName] : null;
  } catch (e) {
    return element.style[styleName];
  }
};
const isScroll = (el, vertical) => {
  const determinedDirection = vertical !== null || vertical !== undefined;
  const overflow = determinedDirection ? vertical ? getStyle(el, 'overflow-y') : getStyle(el, 'overflow-x') : getStyle(el, 'overflow');
  return overflow.match(/(scroll|auto)/);
};
const getScrollContainer = (el, vertical) => {
  let parent = el;

  while (parent) {
    if ([window, document, document.documentElement].includes(parent)) {
      return window;
    }

    if (isScroll(parent, vertical)) {
      return parent;
    }

    parent = parent.parentNode;
  }

  return parent;
};
const isInContainer = (el, container) => {
  if ( !el || !container) return false;
  const elRect = el.getBoundingClientRect();
  let containerRect;

  if ([window, document, document.documentElement, null, undefined].includes(container)) {
    containerRect = {
      top: 0,
      right: window.innerWidth,
      bottom: window.innerHeight,
      left: 0
    };
  } else {
    containerRect = container.getBoundingClientRect();
  }

  return elRect.top < containerRect.bottom && elRect.bottom > containerRect.top && elRect.right > containerRect.left && elRect.left < containerRect.right;
};

class TransitionFn {
  beforeEnter(el) {
    addClass(el, 'collapse-transition');
    !el.dataset && (el.dataset = {});
    el.dataset.oldPaddingTop = el.style.paddingTop;
    el.dataset.oldPaddingBottom = el.style.paddingBottom;
    el.style.height = '0';
    el.style.paddingTop = 0;
    el.style.paddingBottom = 0;
  }

  enter(el) {
    el.dataset.oldOverflow = el.style.overflow;

    if (el.scrollHeight !== 0) {
      el.style.height = el.scrollHeight + 'px';
      el.style.paddingTop = el.dataset.oldPaddingTop;
      el.style.paddingBottom = el.dataset.oldPaddingBottom;
    } else {
      el.style.height = '';
      el.style.paddingTop = el.dataset.oldPaddingTop;
      el.style.paddingBottom = el.dataset.oldPaddingBottom;
    }

    el.style.overflow = 'hidden';
  }

  afterEnter(el) {
    // for safari: remove class then reset height is necessary
    removeClass(el, 'collapse-transition');
    el.style.height = '';
    el.style.overflow = el.dataset.oldOverflow;
  }

  beforeLeave(el) {
    if (!el.dataset) el.dataset = {};
    el.dataset.oldPaddingTop = el.style.paddingTop;
    el.dataset.oldPaddingBottom = el.style.paddingBottom;
    el.dataset.oldOverflow = el.style.overflow;
    el.style.height = el.scrollHeight + 'px';
    el.style.overflow = 'hidden';
  }

  leave(el) {
    if (el.scrollHeight !== 0) {
      // for safari: add class after set height, or it will jump to zero height suddenly, weired
      addClass(el, 'collapse-transition');
      el.style.height = 0;
      el.style.paddingTop = 0;
      el.style.paddingBottom = 0;
    }
  }

  afterLeave(el) {
    removeClass(el, 'collapse-transition');
    el.style.height = '';
    el.style.overflow = el.dataset.oldOverflow;
    el.style.paddingTop = el.dataset.oldPaddingTop;
    el.style.paddingBottom = el.dataset.oldPaddingBottom;
  }

}

const ElCollapseTransition = (props, context) => {
  const transitions = new TransitionFn();
  const data = {
    onBeforeEnter: transitions.beforeEnter,
    onEnter: transitions.enter,
    onAfterEnter: transitions.afterEnter,
    onBeforeLeave: transitions.beforeLeave,
    onLeave: transitions.leave,
    onAfterLeave: transitions.afterLeave
  };
  return h(Transition, data, context.slots);
};

ElCollapseTransition.install = function (app) {
  app.component('ElCollapseTransition', ElCollapseTransition);
};

var ElRow = {
  name: 'ElRow',
  componentName: 'ElRow',

  setup(props) {
    const style = computed(() => {
      const ret = {};

      if (props.gutter) {
        ret.marginLeft = `-${props.gutter / 2}px`;
        ret.marginRight = ret.marginLeft;
      }

      return ret;
    });
    provide('el-row', getCurrentInstance());
    return {
      style
    };
  },

  props: {
    tag: {
      type: String,
      default: 'div'
    },
    gutter: {
      type: Number,
      default: 0
    },
    type: String,
    justify: {
      type: String,
      default: 'start'
    },
    align: {
      type: String,
      default: 'top'
    }
  },

  render() {
    return h(this.tag, {
      class: ['el-row', this.justify !== 'start' ? `is-justify-${this.justify}` : '', this.align !== 'top' ? `is-align-${this.align}` : '', {
        'el-row--flex': this.type === 'flex'
      }],
      style: this.style
    }, this.$slots.default && this.$slots.default());
  }

};

/* istanbul ignore next */

ElRow.install = function (app) {
  app.component(ElRow.name, ElRow);
};

var script = {
  name: 'ElCol',
  props: {
    span: {
      type: Number,
      default: 24
    },
    tag: {
      type: String,
      default: 'div'
    },
    offset: Number,
    pull: Number,
    push: Number,
    xs: [Number, Object],
    sm: [Number, Object],
    md: [Number, Object],
    lg: [Number, Object],
    xl: [Number, Object]
  },

  setup(props, {
    slots
  }) {
    const {
      tag
    } = toRefs(props);
    const gutter = computed(() => {
      let {
        parent
      } = getCurrentInstance();

      while (parent && parent.type.componentName !== 'ElRow') {
        parent = parent.parent;
      }

      return parent ? parent.props.gutter : 0;
    });
    return () => {
      const classList = [];
      const style = {};

      if (unref(gutter)) {
        style.paddingLeft = unref(gutter) / 2 + 'px';
        style.paddingRight = style.paddingLeft;
      }
      ['span', 'offset', 'pull', 'push'].forEach(prop => {
        if (unref(toRefs(props)[prop]) || unref(toRefs(props)[prop]) === 0) {
          classList.push(prop !== 'span' ? `el-col-${prop}-${unref(toRefs(props)[prop])}` : `el-col-${unref(toRefs(props)[prop])}`);
        }
      });
      ['xs', 'sm', 'md', 'lg', 'xl'].forEach(size => {
        if (typeof unref(toRefs(props)[size]) === 'number') {
          classList.push(`el-col-${size}-${unref(toRefs(props)[size])}`);
        } else if (typeof unref(toRefs(props)[size]) === 'object') {
          const propsData = unref(toRefs(props)[size]);
          Object.keys(propsData).forEach(prop => {
            classList.push(prop !== 'span' ? `el-col-${size}-${prop}-${propsData[prop]}` : `el-col-${size}-${propsData[prop]}`);
          });
        }
      });
      return h(unref(tag), {
        class: ['el-col', classList],
        style
      }, slots.default ? slots.default() : '');
    };
  }

};

script.__file = "packages/col/Col.vue";

/* istanbul ignore next */

script.install = function (app) {
  app.component(script.name, script);
};

var script$1 = {
  name: 'ElContainer',
  props: {
    direction: String
  },

  setup(props, {
    slots
  }) {
    const {
      direction
    } = toRefs(props);
    const isVertical = computed(() => {
      if (direction === 'vertical') {
        return true;
      } else if (direction === 'horizontal') {
        return false;
      }

      if (slots && slots.default) {
        return slots.default().some(vNode => {
          const tag = vNode.type && vNode.type.name;
          return tag === 'ElHeader' || tag === 'ElFooter';
        });
      } else {
        return false;
      }
    });
    return {
      isVertical
    };
  }

};

function render(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("section", {
    class: ["el-container", { 'is-vertical': $setup.isVertical }]
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2 /* CLASS */))
}

script$1.render = render;
script$1.__file = "packages/container/Container.vue";

/* istanbul ignore next */

script$1.install = function (app) {
  app.component(script$1.name, script$1);
};

var script$2 = {
  name: 'ElHeader',
  props: {
    height: {
      type: String,
      default: '60px'
    }
  }
};

function render$1(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("header", {
    class: "el-header",
    style: { height: $props.height }
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4 /* STYLE */))
}

script$2.render = render$1;
script$2.__file = "packages/header/Header.vue";

/* istanbul ignore next */

script$2.install = function (app) {
  app.component(script$2.name, script$2);
};

var script$3 = {
  name: 'ElFooter',
  componentName: 'ElFooter',
  props: {
    height: {
      type: String,
      default: '60px'
    }
  }
};

function render$2(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("footer", {
    class: "el-footer",
    style: { height: $props.height }
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4 /* STYLE */))
}

script$3.render = render$2;
script$3.__file = "packages/footer/Footer.vue";

/* istanbul ignore next */

script$3.install = function (app) {
  app.component(script$3.name, script$3);
};

var script$4 = {
  name: 'ElAside',
  componentName: 'ElAside',
  props: {
    width: {
      type: String,
      default: '300px'
    }
  }
};

function render$3(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("aside", {
    class: "el-aside",
    style: { width: $props.width }
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 4 /* STYLE */))
}

script$4.render = render$3;
script$4.__file = "packages/aside/Aside.vue";

/* istanbul ignore next */

script$4.install = function (app) {
  app.component(script$4.name, script$4);
};

var script$5 = {
  name: 'ElMain',
  componentName: 'ElMain'
};

const _hoisted_1 = { class: "el-main" };

function render$4(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("main", _hoisted_1, [
    renderSlot(_ctx.$slots, "default")
  ]))
}

script$5.render = render$4;
script$5.__file = "packages/main/Main.vue";

/* istanbul ignore next */

script$5.install = function (app) {
  app.component(script$5.name, script$5);
};

var script$6 = {
  name: 'ElIcon',
  props: {
    name: String
  }
};

function render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("i", {
    class: `el-icon-${$props.name}`
  }, null, 2 /* CLASS */))
}

script$6.render = render$5;
script$6.__file = "packages/icon/Icon.vue";

/* istanbul ignore next */

script$6.install = function (app) {
  app.component(script$6.name, script$6);
};

/**
 * get globalOptions $ELEMENT config object
 */

function useGlobalOptions() {
  const instance = getCurrentInstance();

  if (!instance) {
    console.ware('useGlobalOptions must be call in setup function');
    return;
  }

  return instance.appContext.config.globalProperties.$ELEMENT || {};
}
function setupGlobalOptions(opts = {}) {
  return app => {
    app.config.globalProperties.$ELEMENT = {
      size: opts.size || '',
      zIndex: opts.zIndex || 2000
    };
  };
}

var script$7 = {
  name: 'ElButton',
  props: {
    size: {
      type: String,

      validator(val) {
        if (val === '') return true;
        return ['medium', 'small', 'mini'].indexOf(val) !== -1;
      }

    },
    type: {
      type: String,

      validator(val) {
        return ['primary', 'success', 'warning', 'danger', 'info', 'text'].indexOf(val) !== -1;
      }

    },
    nativeType: {
      type: String,
      default: 'button'
    },
    plain: Boolean,
    round: Boolean,
    circle: Boolean,
    loading: Boolean,
    disabled: Boolean,
    icon: String
  },

  setup(props) {
    const {
      size,
      disabled
    } = toRefs(props);
    const buttonSize = useButtonSize(size);
    const buttonDisabled = useButtonDisabled(disabled);
    const classes = useClasses({
      props,
      size: buttonSize,
      disabled: buttonDisabled
    });
    return {
      buttonDisabled,
      classes
    };
  }

};

const useClasses = ({
  props,
  size,
  disabled
}) => {
  return computed(() => {
    return [size.value ? `el-button--${size.value}` : '', props.type ? `el-button--${props.type}` : '', {
      'is-plain': props.plain,
      'is-round': props.round,
      'is-circle': props.circle,
      'is-loading': props.loading,
      'is-disabled': disabled.value
    }];
  });
};

const useButtonDisabled = disabled => {
  return computed(() => {
    const elForm = inject('elForm', {});
    return (disabled === null || disabled === void 0 ? void 0 : disabled.value) || elForm.disabled;
  });
};

const useButtonSize = size => {
  const globalConfig = useGlobalOptions();
  return computed(() => {
    const elFormItem = inject('elFormItem', {});
    return (size === null || size === void 0 ? void 0 : size.value) || elFormItem.elFormItemSize || globalConfig.size;
  });
};

const _hoisted_1$1 = {
  key: 0,
  class: "el-icon-loading"
};
const _hoisted_2 = { key: 2 };

function render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("button", {
    class: ["el-button", $setup.classes],
    type: $props.nativeType,
    disabled: $setup.buttonDisabled || $props.loading
  }, [
    ($props.loading)
      ? (openBlock(), createBlock("i", _hoisted_1$1))
      : ($props.icon)
        ? (openBlock(), createBlock("i", {
            key: 1,
            class: $props.icon
          }, null, 2 /* CLASS */))
        : createCommentVNode("v-if", true),
    (_ctx.$slots.default)
      ? (openBlock(), createBlock("span", _hoisted_2, [
          renderSlot(_ctx.$slots, "default")
        ]))
      : createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, ["type", "disabled"]))
}

script$7.render = render$6;
script$7.__file = "packages/button/Button.vue";

script$7.install = function (app) {
  app.component(script$7.name, script$7);
};

var script$8 = {
  name: 'ElButtonGroup'
};

const _hoisted_1$2 = { class: "el-button-group" };

function render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$2, [
    renderSlot(_ctx.$slots, "default")
  ]))
}

script$8.render = render$7;
script$8.__file = "packages/button-group/ButtonGroup.vue";

/* istanbul ignore next */

script$8.install = function (app) {
  app.component(script$8.name, script$8);
};

var script$9 = {
  name: 'ElLink',
  props: {
    type: {
      type: String,
      default: 'default'
    },
    underline: {
      type: Boolean,
      default: true
    },
    disabled: Boolean,
    href: String,
    icon: String
  },
  emits: ['click'],

  setup(props, {
    emit
  }) {
    const handleClick = evt => {
      if (props.disabled) return;
      if (props.href) return;
      emit('click', evt);
    };

    return {
      handleClick
    };
  }

};

const _hoisted_1$3 = {
  key: 1,
  class: "el-link--inner"
};

function render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("a", mergeProps({
    class: [
      'el-link',
      $props.type ? `el-link--${$props.type}` : '',
      $props.disabled && 'is-disabled',
      $props.underline && !$props.disabled && 'is-underline'
    ],
    href: $props.disabled ? null : $props.href
  }, _ctx.$attrs, {
    onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleClick(...args)))
  }), [
    ($props.icon)
      ? (openBlock(), createBlock("i", {
          key: 0,
          class: $props.icon
        }, null, 2 /* CLASS */))
      : createCommentVNode("v-if", true),
    (_ctx.$slots.default)
      ? (openBlock(), createBlock("span", _hoisted_1$3, [
          renderSlot(_ctx.$slots, "default")
        ]))
      : createCommentVNode("v-if", true),
    (_ctx.$slots.icon)
      ? renderSlot(_ctx.$slots, "icon", { key: 2 })
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */, ["href"]))
}

script$9.render = render$8;
script$9.__file = "packages/link/Link.vue";

/* istanbul ignore next */

script$9.install = function (app) {
  app.component(script$9.name, script$9);
};

var script$a = {
  name: 'ElRadio',
  componentName: 'ElRadio',
  props: {
    modelValue: [String, Number, Symbol, Boolean, Array],
    label: [String, Number, Symbol, Boolean, Array],
    disabled: Boolean,
    name: String,
    border: Boolean,
    size: String
  },
  emits: ['update:modelValue', 'change'],

  setup(props) {
    const {
      modelValue,
      label,
      size,
      disabled
    } = toRefs(props);
    const radio = ref();
    const focus = ref(false);
    const {
      elForm,
      elFormItem
    } = useInject();
    const {
      isGroup,
      radioGroup
    } = useCheckGroup();
    const {
      model,
      handleChange
    } = useModel({
      isGroup,
      radioGroup,
      modelValue,
      label,
      radio
    });
    const {
      radioSize,
      isDisabled,
      tabIndex
    } = useStyle({
      isGroup,
      radioGroup,
      size,
      disabled,
      model,
      label,
      elForm,
      elFormItem
    });
    return {
      radio,
      focus,
      model,
      radioSize,
      isDisabled,
      tabIndex,
      handleChange
    };
  }

};

function useInject() {
  const elForm = inject('elForm', {});
  const elFormItem = inject('elFormItem', {});
  return {
    elForm,
    elFormItem
  };
}

function useCheckGroup() {
  let {
    parent
  } = getCurrentInstance();

  while (parent) {
    if (parent.type.name !== 'ElRadioGroup') {
      parent = parent.parent;
    } else {
      return {
        isGroup: true,
        radioGroup: parent
      };
    }
  }

  return {
    isGroup: false,
    radioGroup: null
  };
}

function useModel({
  isGroup,
  radioGroup,
  modelValue,
  radio,
  label
}) {
  const {
    emit
  } = getCurrentInstance();
  const model = computed({
    get() {
      const res = isGroup ? radioGroup.proxy.modelValue : modelValue;
      return unref(res);
    },

    set(val) {
      if (isGroup) {
        radioGroup.emit('update:modelValue', val);
      } else {
        emit('update:modelValue', val);
      }

      radio.value && (radio.value.checked = unref(model) === unref(label));
    }

  });

  async function handleChange() {
    await nextTick();
    emit('change', model.value);
    isGroup && radioGroup.emit('change', model.value);
  }

  return {
    model,
    handleChange
  };
}

function useStyle({
  isGroup,
  radioGroup,
  size,
  disabled,
  model,
  label,
  elForm,
  elFormItem
}) {
  const {
    ctx
  } = getCurrentInstance();
  const elFormDisable = elForm.disabled;
  const radioSize = computed(() => {
    const temRadioSize = unref(size) || elFormItem.elFormItemSize || (ctx.$ELEMENT || {}).size;
    return isGroup ? radioGroup.ctx.radioGroupSize || temRadioSize : temRadioSize;
  });
  const isDisabled = computed(() => {
    return isGroup ? radioGroup.props.disabled || disabled.value || elFormDisable : disabled.value || elFormDisable;
  });
  const tabIndex = computed(() => {
    return isDisabled.value || isGroup && model.value !== label.value ? -1 : 0;
  });
  return {
    radioSize,
    isDisabled,
    tabIndex
  };
}

const _hoisted_1$4 = /*#__PURE__*/createVNode("span", { class: "el-radio__inner" }, null, -1 /* HOISTED */);

function render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("label", {
    class: ["el-radio", [
      $props.border && $setup.radioSize ? 'el-radio--' + $setup.radioSize : '',
      { 'is-disabled': $setup.isDisabled },
      { 'is-focus': $setup.focus },
      { 'is-bordered': $props.border },
      { 'is-checked': $setup.model === $props.label }
    ]],
    role: "radio",
    "aria-checked": $setup.model === $props.label,
    "aria-disabled": $setup.isDisabled,
    tabindex: $setup.tabIndex,
    onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers($event => ($setup.model = $setup.isDisabled ? $setup.model : $props.label), ["stop","prevent"]), ["space"]))
  }, [
    createVNode("span", {
      class: ["el-radio__input", {
        'is-disabled': $setup.isDisabled,
        'is-checked': $setup.model === $props.label
      }]
    }, [
      _hoisted_1$4,
      withDirectives(createVNode("input", {
        ref: "radio",
        class: "el-radio__original",
        value: $props.label,
        type: "radio",
        "aria-hidden": "true",
        "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ($setup.model = $event)),
        onFocus: _cache[2] || (_cache[2] = $event => ($setup.focus = true)),
        onBlur: _cache[3] || (_cache[3] = $event => ($setup.focus = false)),
        onChange: _cache[4] || (_cache[4] = (...args) => ($setup.handleChange(...args))),
        name: $props.name,
        disabled: $setup.isDisabled,
        tabindex: "-1"
      }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["value", "name", "disabled"]), [
        [vModelRadio, $setup.model]
      ])
    ], 2 /* CLASS */),
    createVNode("span", {
      class: "el-radio__label",
      onKeydown: _cache[5] || (_cache[5] = withModifiers(() => {}, ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default"),
      (!_ctx.$slots.default)
        ? (openBlock(), createBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
          ], 64 /* STABLE_FRAGMENT */))
        : createCommentVNode("v-if", true)
    ], 32 /* HYDRATE_EVENTS */)
  ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["aria-checked", "aria-disabled", "tabindex"]))
}

script$a.render = render$9;
script$a.__file = "packages/radio/Radio.vue";

/* istanbul ignore next */

script$a.install = function (app) {
  app.component(script$a.name, script$a);
};

var script$b = {
  name: 'ElRadioButton',
  componentName: 'ElRadioButton',
  props: {
    label: [String, Number, Symbol, Boolean],
    disabled: Boolean,
    name: String
  },

  setup(props) {
    const {
      label,
      disabled
    } = toRefs(props);
    const radio = ref();
    const focus = ref(false);
    const {
      elForm,
      elFormItem
    } = useInject$1();
    const {
      radioGroup
    } = useCheckGroup$1();
    const {
      value,
      handleChange
    } = useModel$1({
      radioGroup,
      label,
      radio
    });
    const {
      size,
      isDisabled,
      tabIndex,
      activeStyle
    } = useStyle$1({
      radioGroup,
      disabled,
      value,
      label,
      elForm,
      elFormItem
    });
    return {
      radio,
      focus,
      value,
      size,
      isDisabled,
      tabIndex,
      activeStyle,
      handleChange
    };
  }

};

function useInject$1() {
  const elForm = inject('elForm', {});
  const elFormItem = inject('elFormItem', {});
  return {
    elForm,
    elFormItem
  };
}

function useCheckGroup$1() {
  let {
    parent
  } = getCurrentInstance();

  while (parent) {
    if (parent.type.name !== 'ElRadioGroup') {
      parent = parent.parent;
    } else {
      return {
        isGroup: true,
        radioGroup: parent
      };
    }
  }

  console.warn('ElementUI Warn: `<radio-button></radio-button>` must be use with <radio-group></radio-group>');
  return {
    isGroup: false,
    radioGroup: null
  };
}

function useModel$1({
  radioGroup
}) {
  const value = computed({
    get() {
      return radioGroup.props.modelValue;
    },

    set(val) {
      radioGroup.emit('update:modelValue', val); // radio.checked = value.value === label.value;
    }

  });

  async function handleChange() {
    await nextTick();
    radioGroup.emit('change', value.value);
  }

  return {
    value,
    handleChange
  };
}

function useStyle$1({
  radioGroup,
  disabled,
  value,
  label,
  elForm,
  elFormItem
}) {
  const {
    ctx
  } = getCurrentInstance();
  const elFormDisable = elForm.disabled;
  const size = computed(() => {
    const temRadioSize = elFormItem.elFormItemSize || (ctx.$ELEMENT || {}).size;
    return radioGroup.ctx.radioGroupSize || temRadioSize;
  });
  const isDisabled = computed(() => {
    return radioGroup.props.disabled || disabled.value || elFormDisable;
  });
  const tabIndex = computed(() => {
    return isDisabled.value || radioGroup && value.value !== label.value ? -1 : 0;
  });
  const activeStyle = computed(() => {
    return {
      backgroundColor: radioGroup.props.fill || '',
      borderColor: radioGroup.props.fill || '',
      boxShadow: radioGroup.props.fill ? `-1px 0 0 0 ${radioGroup.props.fill}` : '',
      color: radioGroup.props.textColor || ''
    };
  });
  return {
    size,
    isDisabled,
    tabIndex,
    activeStyle
  };
}

function render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("label", {
    class: ["el-radio-button", [
      $setup.size ? 'el-radio-button--' + $setup.size : '',
      { 'is-active': $setup.value === $props.label },
      { 'is-disabled': $setup.isDisabled },
      { 'is-focus': $setup.focus }
    ]],
    role: "radio",
    "aria-checked": $setup.value === $props.label,
    "aria-disabled": $setup.isDisabled,
    tabindex: $setup.tabIndex,
    onKeydown: _cache[6] || (_cache[6] = withKeys(withModifiers($event => ($setup.value = $setup.isDisabled ? $setup.value : $props.label), ["stop","prevent"]), ["space"]))
  }, [
    withDirectives(createVNode("input", {
      class: "el-radio-button__orig-radio",
      value: $props.label,
      type: "radio",
      "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ($setup.value = $event)),
      name: $props.name,
      onChange: _cache[2] || (_cache[2] = (...args) => ($setup.handleChange(...args))),
      disabled: $setup.isDisabled,
      tabindex: "-1",
      onFocus: _cache[3] || (_cache[3] = $event => ($setup.focus = true)),
      onBlur: _cache[4] || (_cache[4] = $event => ($setup.focus = false))
    }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["value", "name", "disabled"]), [
      [vModelRadio, $setup.value]
    ]),
    createVNode("span", {
      class: "el-radio-button__inner",
      style: $setup.value === $props.label ? $setup.activeStyle : null,
      onKeydown: _cache[5] || (_cache[5] = withModifiers(() => {}, ["stop"]))
    }, [
      renderSlot(_ctx.$slots, "default"),
      (!_ctx.$slots.default)
        ? (openBlock(), createBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
          ], 64 /* STABLE_FRAGMENT */))
        : createCommentVNode("v-if", true)
    ], 36 /* STYLE, HYDRATE_EVENTS */)
  ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["aria-checked", "aria-disabled", "tabindex"]))
}

script$b.render = render$a;
script$b.__file = "packages/radio-button/RadioButton.vue";

/* istanbul ignore next */

script$b.install = function (app) {
  app.component(script$b.name, script$b);
};

function mitt (n) {
  return {
    all: n = n || new Map(),
    on: function (t, e) {
      var i = n.get(t);
      i && i.push(e) || n.set(t, [e]);
    },
    off: function (t, e) {
      var i = n.get(t);
      i && i.splice(i.indexOf(e) >>> 0, 1);
    },
    emit: function (t, e) {
      (n.get(t) || []).slice().map(function (n) {
        n(e);
      }), (n.get("*") || []).slice().map(function (n) {
        n(t, e);
      });
    }
  };
}

const DISPATCH = 'dispatch';
const BROADCAST = 'broadcast';
const wrapper = Symbol('wrapper');
const emitter = mitt();
function useEmitter() {
  const currentComponentInstance = getCurrentInstance();

  function on(type, handler) {
    const handleWrapper = e => {
      const {
        value,
        type,
        emitComponentInstance
      } = e;

      if (type === BROADCAST) {
        if (isChildComponent(currentComponentInstance, emitComponentInstance)) {
          handler && handler(...value);
        }
      } else if (type === DISPATCH) {
        if (isChildComponent(emitComponentInstance, currentComponentInstance)) {
          handler && handler(...value);
        }
      } else {
        handler && handler(...value);
      }
    }; // Save the real handler because the need to call off


    handler[wrapper] = handleWrapper;
    emitter.on(type, handleWrapper);
  }

  function broadcast(type, ...args) {
    emitter.emit(type, {
      type: BROADCAST,
      emitComponentInstance: currentComponentInstance,
      value: args
    });
  }

  function dispatch(type, ...args) {
    emitter.emit(type, {
      type: DISPATCH,
      emitComponentInstance: currentComponentInstance,
      value: args
    });
  }

  function off(type, handler) {
    emitter.off(type, handler[wrapper]);
  }

  function once(type, handler) {
    const handleOn = (...args) => {
      handler && handler(...args);
      off(type, handleOn);
    };

    on(type, handleOn);
  }

  return {
    on,
    broadcast,
    dispatch,
    off,
    once
  };
}
/**
 * check componentChild is componentParent child components
 * @param {*} componentChild
 * @param {*} componentParent
 */

function isChildComponent(componentChild, componentParent) {
  const parentUId = componentParent.uid;

  while (componentChild && ((_componentChild = componentChild) === null || _componentChild === void 0 ? void 0 : (_componentChild$paren = _componentChild.parent) === null || _componentChild$paren === void 0 ? void 0 : _componentChild$paren.uid) !== parentUId) {
    var _componentChild, _componentChild$paren;

    componentChild = componentChild.parent;
  }

  return Boolean(componentChild);
}

const keyCode = Object.freeze({
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40
});
var script$c = {
  name: 'ElRadioGroup',
  componentName: 'ElRadioGroup',
  props: {
    modelValue: [String, Number, Symbol, Boolean],
    size: String,
    fill: String,
    textColor: String,
    disabled: Boolean
  },
  emits: ['update:modelValue', 'change'],

  setup(props) {
    const {
      modelValue = {},
      size = {}
    } = toRefs(props);
    const {
      dispatch
    } = useEmitter();
    const {
      elFormItem
    } = useInject$2();
    watch(modelValue, v => {
      dispatch('el.form.change', v);
    });
    const {
      handleKeydown
    } = useKeyDown();
    const {
      elTag,
      radioGroupSize
    } = useStyle$2({
      elFormItem,
      size
    });
    return {
      elTag,
      radioGroupSize,
      handleKeydown
    };
  }

};

function useInject$2() {
  const elFormItem = inject('elFormItem', {});
  return {
    elFormItem
  };
}

function useKeyDown() {
  const {
    ctx
  } = getCurrentInstance();
  onMounted(() => {
    const radios = ctx.$el.querySelectorAll('[type=radio]');
    const firstLabel = ctx.$el.querySelectorAll('[role=radio]')[0];

    if (![].some.call(radios, radio => radio.checked) && firstLabel) {
      firstLabel.tabIndex = 0;
    }
  });

  function handleKeydown(e) {
    const target = e.target;
    const className = target.nodeName === 'INPUT' ? '[type=radio]' : '[role=radio]';
    const radios = ctx.$el.querySelectorAll(className);
    const length = radios.length;
    const index = [].indexOf.call(radios, target);
    const roleRadios = ctx.$el.querySelectorAll('[role=radio]');

    switch (e.keyCode) {
      case keyCode.LEFT:
      case keyCode.UP:
        e.stopPropagation();
        e.preventDefault();

        if (index === 0) {
          roleRadios[length - 1].click();
          roleRadios[length - 1].focus();
        } else {
          roleRadios[index - 1].click();
          roleRadios[index - 1].focus();
        }

        break;

      case keyCode.RIGHT:
      case keyCode.DOWN:
        if (index === length - 1) {
          e.stopPropagation();
          e.preventDefault();
          roleRadios[0].click();
          roleRadios[0].focus();
        } else {
          roleRadios[index + 1].click();
          roleRadios[index + 1].focus();
        }

        break;
    }
  }

  return {
    handleKeydown
  };
}

function useStyle$2({
  elFormItem,
  size
}) {
  const {
    ctx,
    vnode
  } = getCurrentInstance();
  const radioGroupSize = computed(() => {
    return size.value || elFormItem.elFormItemSize || (ctx.$ELEMENT || {}).size;
  });
  const elTag = computed(() => {
    return (vnode.data || {}).tag || 'div';
  });
  return {
    radioGroupSize,
    elTag
  };
}

function render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(resolveDynamicComponent($setup.elTag), {
    class: "el-radio-group",
    role: "radiogroup",
    onKeydown: $setup.handleKeydown
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default")
    ]),
    _: 3
  }, 8 /* PROPS */, ["onKeydown"]))
}

script$c.render = render$b;
script$c.__file = "packages/radio-group/RadioGroup.vue";

/* istanbul ignore next */

script$c.install = function (app) {
  app.component(script$c.name, script$c);
};

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 * IMPORTANT: all calls of this function must be prefixed with
 * \/\*#\_\_PURE\_\_\*\/
 * So that rollup can tree-shake them if necessary.
 */
const EMPTY_OBJ = process.env.NODE_ENV !== 'production' ? Object.freeze({}) : {};
const EMPTY_ARR = process.env.NODE_ENV !== 'production' ? Object.freeze([]) : [];

const onRE = /^on[^a-z]/;

const isOn = key => onRE.test(key);

const isArray = Array.isArray;

function usePropUtils() {
  return {
    isAfferentProp: isAfferentProp()
  };
}

function isAfferentProp() {
  // Used only for setuping or mounting
  const {
    vnode
  } = getCurrentInstance();
  return propKey => {
    return typeof vnode.props[propKey] !== 'undefined';
  };
}

function useModel$2() {
  // core
  const {
    emit,
    props
  } = getCurrentInstance();
  const elCheckboxGroup = inject('elCheckboxGroup', {
    props: {}
  });
  const {
    dispatch
  } = useEmitter();
  const state = reactive({
    modelValue: null // If the parent element is ChceckboxGroup use its modelValue

  });
  watchEffect(() => {
    state.modelValue = elCheckboxGroup.props.modelValue || props.modelValue;
  });
  const model = computed({
    get() {
      return state.modelValue; // BUG: if the Checkbox list and modelValue are an object, this causes the object element to be deleted.
      // Resolve: `isArray(modelValue) ? [...modelValue] : modelValue`, but doing so will invalidate the `checked` prop.
    },

    set({
      label,
      checked
    }) {
      if (label && isArray(model.value)) {
        // when modelValue or elCheckboxGroup.modeValue is array
        const modelValue = model.value;
        const labelIndex = modelValue.indexOf(label);
        labelIndex === -1 && checked === true && modelValue.push(label);
        labelIndex !== -1 && checked === false && modelValue.splice(labelIndex, 1);
        state.modelValue = modelValue;
        emit('update:modelValue', modelValue);
        dispatch('update:modelValue', modelValue);
      } else {
        const modelValue = checked ? props.trueLabel : props.falseLabel;
        state.modelValue = modelValue;
        emit('update:modelValue', modelValue);
      }
    }

  });

  async function handleChange() {
    await nextTick();
    emit('change', model.value);
    dispatch('change', model.value);
  }

  return {
    model,
    handleChange
  };
}
function useAria() {
  const {
    props,
    vnode
  } = getCurrentInstance();
  onMounted(() => {
    if (props.indeterminate) {
      vnode.el.setAttribute('aria-controls', props.controls);
    }
  });
}
function useCheckSelected({
  model
}) {
  const {
    props
  } = getCurrentInstance();
  const {
    isAfferentProp
  } = usePropUtils();
  const checkbox = ref(null);
  onMounted(() => {
    isAfferentProp('checked') && (model.value = {
      label: props.label,
      checked: props.checked
    });
  });
  const isChecked = computed(() => {
    const _isChecked = isArray(model.value) ? model.value.indexOf(props.label) !== -1 : model.value === props.trueLabel;

    checkbox.value && (checkbox.value.checked = _isChecked);
    return _isChecked;
  });
  return {
    isChecked,
    checkbox
  };
}
function useSize() {
  const elCheckboxGroup = inject('elCheckboxGroup', {
    props: {},
    ctx: {}
  });
  const {
    props,
    ctx
  } = getCurrentInstance();
  const checkboxSize = computed(() => {
    return props.size || elCheckboxGroup.ctx.checkboxGroupSize || (ctx.$ELEMENT || {}).size;
  });
  return checkboxSize;
}
function useLimit({
  model
}) {
  const elCheckboxGroup = inject('elCheckboxGroup', {
    props: {},
    ctx: {}
  });
  const {
    props
  } = getCurrentInstance();
  const isLimit = computed(() => {
    if (elCheckboxGroup.props.modelValue) {
      // if elCheckboxGroup exist
      const modelValueLength = elCheckboxGroup.props.modelValue.length;
      const min = elCheckboxGroup.props.min;
      const max = elCheckboxGroup.props.max;
      return modelValueLength <= min && model.value.indexOf(props.label) !== -1 || modelValueLength >= max && model.value.indexOf(props.label) === -1;
    } else {
      return false;
    }
  });
  return isLimit;
}
function useDisabled({
  isLimit
}) {
  const elCheckboxGroup = inject('elCheckboxGroup', {
    props: {},
    ctx: {}
  });
  const {
    props
  } = getCurrentInstance();
  const isDisabled = computed(() => {
    return props.disabled || elCheckboxGroup.ctx.checkboxGroupDisabled || isLimit.value;
  });
  return isDisabled;
}
function useBorder() {
  const elCheckboxGroup = inject('elCheckboxGroup', {
    props: {},
    ctx: {}
  });
  const {
    props
  } = getCurrentInstance();
  const isBorder = computed(() => {
    return props.border || elCheckboxGroup.props.border;
  });
  return isBorder;
}
function useActiveStyle() {
  const elCheckboxGroup = inject('elCheckboxGroup', {
    props: {},
    ctx: {}
  });
  return {
    backgroundColor: elCheckboxGroup.props.fill || '',
    borderColor: elCheckboxGroup.props.fill || '',
    color: elCheckboxGroup.props.textColor || '',
    'box-shadow': '-1px 0 0 0 ' + elCheckboxGroup.props.fill
  };
}

var script$d = {
  name: 'ElCheckbox',
  props: {
    modelValue: [String, Number, Boolean, Symbol, Array],
    label: [String, Number, Boolean, Symbol],
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: String,
    trueLabel: {
      type: [String, Number, Boolean],
      default: true
    },
    falseLabel: {
      type: [String, Number, Boolean],
      default: false
    },
    id: String
    /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 */
    ,
    controls: String
    /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 */
    ,
    border: Boolean,
    size: String
  },
  emits: ['update:modelValue', 'change'],

  setup() {
    const state = reactive({
      focus: false
    });
    useAria();
    const {
      model,
      handleChange
    } = useModel$2();
    const isLimit = useLimit({
      model
    });
    const {
      isChecked,
      checkbox
    } = useCheckSelected({
      model
    });
    const checkboxSize = useSize();
    const isDisabled = useDisabled({
      isLimit
    });
    const isBorder = useBorder();
    return { ...toRefs(state),
      checkbox,
      model,
      isDisabled,
      checkboxSize,
      isChecked,
      handleChange,
      isBorder
    };
  }

};

const _hoisted_1$5 = /*#__PURE__*/createVNode("span", { class: "el-checkbox__inner" }, null, -1 /* HOISTED */);
const _hoisted_2$1 = {
  key: 0,
  class: "el-checkbox__label"
};

function render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("label", {
    class: ["el-checkbox", [
      $setup.isBorder && $setup.checkboxSize ? 'el-checkbox--' + $setup.checkboxSize : '',
      { 'is-disabled': $setup.isDisabled },
      { 'is-bordered': $setup.isBorder },
      { 'is-checked': $setup.isChecked }
    ]],
    role: "checkbox",
    id: $props.id,
    "aria-checked": $setup.isChecked,
    "aria-disabled": $setup.isDisabled
  }, [
    createVNode("span", {
      class: ["el-checkbox__input", {
        'is-disabled': $setup.isDisabled,
        'is-checked': $setup.isChecked,
        'is-indeterminate': $props.indeterminate,
        'is-focus': _ctx.focus
      }],
      tabindex: $props.indeterminate ? 0 : false,
      role: $props.indeterminate ? 'checkbox' : false,
      "aria-checked": $props.indeterminate ? 'mixed' : false
    }, [
      _hoisted_1$5,
      createVNode("input", {
        class: "el-checkbox__original",
        type: "checkbox",
        ref: "checkbox",
        "aria-hidden": $props.indeterminate ? 'true' : 'false',
        name: $props.name,
        disabled: $setup.isDisabled,
        "true-value": $props.trueLabel,
        "false-value": $props.falseLabel,
        value: $props.label,
        onChange: _cache[1] || (_cache[1] = (...args) => ($setup.handleChange(...args))),
        onInput: _cache[2] || (_cache[2] = $event => ($setup.model = { label: $props.label, checked: $event.target.checked })),
        onFocus: _cache[3] || (_cache[3] = $event => (_ctx.focus = true)),
        onBlur: _cache[4] || (_cache[4] = $event => (_ctx.focus = false))
      }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["aria-hidden", "name", "disabled", "true-value", "false-value", "value"])
    ], 10 /* CLASS, PROPS */, ["tabindex", "role", "aria-checked"]),
    (_ctx.$slots.default || $props.label)
      ? (openBlock(), createBlock("span", _hoisted_2$1, [
          renderSlot(_ctx.$slots, "default"),
          (!_ctx.$slots.default)
            ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
              ], 64 /* STABLE_FRAGMENT */))
            : createCommentVNode("v-if", true)
        ]))
      : createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, ["id", "aria-checked", "aria-disabled"]))
}

script$d.render = render$c;
script$d.__file = "packages/checkbox/Checkbox.vue";

/* istanbul ignore next */

script$d.install = function (app) {
  app.component(script$d.name, script$d);
};

var script$e = {
  name: 'ElCheckboxButton',
  props: {
    modelValue: [String, Number, Boolean, Symbol, Array],
    label: [String, Number, Boolean, Symbol],
    indeterminate: Boolean,
    disabled: Boolean,
    checked: Boolean,
    name: String,
    trueLabel: {
      type: [String, Number, Boolean],
      default: true
    },
    falseLabel: {
      type: [String, Number, Boolean],
      default: false
    },
    id: String
    /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 */
    ,
    controls: String
    /* 当indeterminate为真时，为controls提供相关连的checkbox的id，表明元素间的控制关系 */
    ,
    border: Boolean,
    size: String
  },
  emits: ['update:modelValue', 'change'],

  setup() {
    const state = reactive({
      focus: false
    });
    useAria();
    const {
      model,
      handleChange
    } = useModel$2();
    const isLimit = useLimit({
      model
    });
    const {
      isChecked,
      checkbox
    } = useCheckSelected({
      model
    });
    const checkboxSize = useSize();
    const isDisabled = useDisabled({
      isLimit
    });
    const activeStyle = useActiveStyle();
    return { ...toRefs(state),
      checkbox,
      model,
      isDisabled,
      checkboxSize,
      isChecked,
      handleChange,
      activeStyle
    };
  }

};

function render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("label", {
    class: ["el-checkbox-button", [
      $setup.checkboxSize ? 'el-checkbox-button--' + $setup.checkboxSize : '',
      { 'is-disabled': $setup.isDisabled },
      { 'is-checked': $setup.isChecked },
      { 'is-focus': _ctx.focus }
    ]],
    role: "checkbox",
    id: $props.id,
    "aria-checked": $setup.isChecked,
    "aria-disabled": $setup.isDisabled
  }, [
    createVNode("input", {
      class: "el-checkbox-button__original",
      type: "checkbox",
      ref: "checkbox",
      "aria-hidden": $props.indeterminate ? 'true' : 'false',
      name: $props.name,
      disabled: $setup.isDisabled,
      "true-value": $props.trueLabel,
      "false-value": $props.falseLabel,
      modelValue: $setup.model,
      value: $props.label,
      onChange: _cache[1] || (_cache[1] = (...args) => ($setup.handleChange(...args))),
      onInput: _cache[2] || (_cache[2] = $event => ($setup.model = { label: $props.label, checked: $event.target.checked })),
      onFocus: _cache[3] || (_cache[3] = $event => (_ctx.focus = true)),
      onBlur: _cache[4] || (_cache[4] = $event => (_ctx.focus = false))
    }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["aria-hidden", "name", "disabled", "true-value", "false-value", "modelValue", "value"]),
    (_ctx.$slots.default || $props.label)
      ? (openBlock(), createBlock("span", {
          key: 0,
          class: "el-checkbox-button__inner",
          style: $setup.isChecked ? $setup.activeStyle : null
        }, [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.label), 1 /* TEXT */)
          ])
        ], 4 /* STYLE */))
      : createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, ["id", "aria-checked", "aria-disabled"]))
}

script$e.render = render$d;
script$e.__file = "packages/checkbox-button/CheckboxButton.vue";

/* istanbul ignore next */

script$e.install = function (app) {
  app.component(script$e.name, script$e);
};

var script$f = {
  name: 'ElCheckboxGroup',
  props: {
    modelValue: Array,
    disabled: Boolean,
    min: Number,
    max: Number,
    size: String,
    fill: String,
    textColor: String,
    border: Boolean
  },
  emits: ['update:modelValue', 'change'],

  setup(props, {
    emit
  }) {
    const elForm = inject('elForm', {
      props: {},
      ctx: {}
    });
    const elFormItem = inject('elFormItem', {});
    provide('elCheckboxGroup', getCurrentInstance());
    const {
      dispatch,
      on
    } = useEmitter();
    const checkboxGroupSize = computed(() => {
      return props.size || elFormItem.elFormItemSize;
    });
    const checkboxGroupDisabled = computed(() => {
      return props.disabled || elForm.disabled;
    });
    on('update:modelValue', v => {
      emit('update:modelValue', v);
      dispatch('el.form.change', v);
    });
    on('change', v => {
      emit('change', v);
    });
    return {
      checkboxGroupSize,
      checkboxGroupDisabled
    };
  }

};

const _hoisted_1$6 = {
  class: "el-checkbox-group",
  role: "group",
  "aria-label": "checkbox-group"
};

function render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$6, [
    renderSlot(_ctx.$slots, "default")
  ]))
}

script$f.render = render$e;
script$f.__file = "packages/checkbox-group/CheckboxGroup.vue";

/* istanbul ignore next */

script$f.install = function (app) {
  app.component(script$f.name, script$f);
};

function broadcast(componentName, eventName, params) {
  this.$children.forEach(child => {
    var name = child.$options.componentName;

    if (name === componentName) {
      child.$emit.apply(child, [eventName].concat(params));
    } else {
      broadcast.apply(child, [componentName, eventName].concat([params]));
    }
  });
}

var Emitter = {
  methods: {
    dispatch(componentName, eventName, params) {
      var parent = this.$parent || this.$root;
      var name = parent.$options.componentName;

      while (parent && (!name || name !== componentName)) {
        parent = parent.$parent;

        if (parent) {
          name = parent.$options.componentName;
        }
      }

      if (parent) {
        parent.$emit.apply(parent, [eventName].concat(params));
      }
    },

    broadcast(componentName, eventName, params) {
      broadcast.call(this, componentName, eventName, params);
    }

  }
};

function merge (target) {
  for (let i = 1, j = arguments.length; i < j; i++) {
    const source = arguments[i] || {};

    for (const prop in source) {
      if (Object.hasOwnProperty.call(source, prop)) {
        const value = source[prop];

        if (value !== undefined) {
          target[prop] = value;
        }
      }
    }
  }

  return target;
}

function isDef(val) {
  return val !== undefined && val !== null;
}
function isKorean(text) {
  const reg = /([(\uAC00-\uD7AF)|(\u3130-\u318F)])+/gi;
  return reg.test(text);
}

let hiddenTextarea;
const HIDDEN_STYLE = `
  height:0 !important;
  visibility:hidden !important;
  overflow:hidden !important;
  position:absolute !important;
  z-index:-1000 !important;
  top:0 !important;
  right:0 !important
`;
const CONTEXT_STYLE = ['letter-spacing', 'line-height', 'padding-top', 'padding-bottom', 'font-family', 'font-weight', 'font-size', 'text-rendering', 'text-transform', 'width', 'text-indent', 'padding-left', 'padding-right', 'border-width', 'box-sizing'];

function calculateNodeStyling(targetElement) {
  const style = window.getComputedStyle(targetElement);
  const boxSizing = style.getPropertyValue('box-sizing');
  const paddingSize = parseFloat(style.getPropertyValue('padding-bottom')) + parseFloat(style.getPropertyValue('padding-top'));
  const borderSize = parseFloat(style.getPropertyValue('border-bottom-width')) + parseFloat(style.getPropertyValue('border-top-width'));
  const contextStyle = CONTEXT_STYLE.map(name => `${name}:${style.getPropertyValue(name)}`).join(';');
  return {
    contextStyle,
    paddingSize,
    borderSize,
    boxSizing
  };
}

function calcTextareaHeight(targetElement, minRows = 1, maxRows = null) {
  if (!hiddenTextarea) {
    hiddenTextarea = document.createElement('textarea');
    document.body.appendChild(hiddenTextarea);
  }

  const {
    paddingSize,
    borderSize,
    boxSizing,
    contextStyle
  } = calculateNodeStyling(targetElement);
  hiddenTextarea.setAttribute('style', `${contextStyle};${HIDDEN_STYLE}`);
  hiddenTextarea.value = targetElement.value || targetElement.placeholder || '';
  let height = hiddenTextarea.scrollHeight;
  const result = {};

  if (boxSizing === 'border-box') {
    height = height + borderSize;
  } else if (boxSizing === 'content-box') {
    height = height - paddingSize;
  }

  hiddenTextarea.value = '';
  const singleRowHeight = hiddenTextarea.scrollHeight - paddingSize;

  if (minRows !== null) {
    let minHeight = singleRowHeight * minRows;

    if (boxSizing === 'border-box') {
      minHeight = minHeight + paddingSize + borderSize;
    }

    height = Math.max(minHeight, height);
    result.minHeight = `${minHeight}px`;
  }

  if (maxRows !== null) {
    let maxHeight = singleRowHeight * maxRows;

    if (boxSizing === 'border-box') {
      maxHeight = maxHeight + paddingSize + borderSize;
    }

    height = Math.min(maxHeight, height);
  }

  result.height = `${height}px`;
  hiddenTextarea.parentNode && hiddenTextarea.parentNode.removeChild(hiddenTextarea);
  hiddenTextarea = null;
  return result;
}

const useValidate = () => {
  const elFormItem = inject('elFormItem', '');
  const validateState = computed(() => {
    return elFormItem ? elFormItem.validateState : '';
  });
  const validateIcon = computed(() => {
    return {
      validating: 'el-icon-loading',
      success: 'el-icon-circle-check',
      error: 'el-icon-circle-close'
    }[unref(validateState)];
  });
  return {
    validateState,
    validateIcon
  };
};
const useTextarea = ({
  autosize,
  type,
  resize
}, textareaCalcStyle) => {
  const textarea = ref(null);
  const textareaStyle = computed(() => {
    return merge({}, textareaCalcStyle.value, {
      resize: unref(resize)
    });
  });

  const resizeTextarea = () => {
    // if (this.$isServer) return;
    if (type.value !== 'textarea') return;

    if (!autosize.value) {
      textareaCalcStyle.value = {
        minHeight: calcTextareaHeight(unref(textarea)).minHeight
      };
      return;
    }

    const minRows = autosize.value.minRows;
    const maxRows = autosize.value.maxRows;
    textareaCalcStyle.value = calcTextareaHeight(unref(textarea), minRows, maxRows);
  };

  return {
    textarea,
    textareaStyle,
    resizeTextarea
  };
};
const useInput = ({
  size,
  type,
  disabled,
  modelValue,
  suffixIcon,
  readonly,
  clearable,
  showPassword,
  showWordLimit
}, {
  hovering,
  focused
}, instance, textarea, attrs, validateState, needStatusIcon, slots) => {
  const input = ref(null);
  const elFormItem = inject('elFormItem', {});
  const elForm = inject('elForm', {});

  const _elFormItemSize = computed(() => {
    return unref(elFormItem.elFormItemSize);
  });

  const inputSize = computed(() => {
    return unref(size) || unref(_elFormItemSize) || (instance.proxy.$ELEMENT || {}).size;
  });
  const inputDisabled = computed(() => {
    return unref(disabled) || unref(elForm.disabled);
  });
  const nativeInputValue = computed(() => {
    return unref(modelValue) === null || unref(modelValue) === undefined ? '' : String(unref(modelValue));
  });
  const textLength = computed(() => {
    if (typeof unref(modelValue) === 'number') {
      return String(unref(modelValue)).length;
    }

    return (unref(modelValue) || '').length;
  });
  const upperLimit = computed(() => {
    return Number(attrs.maxlength);
  });
  const isWordLimitVisible = computed(() => {
    return unref(showWordLimit) && attrs.maxlength && (unref(type) === 'text' || unref(type) === 'textarea') && !unref(inputDisabled) && !unref(readonly) && !unref(showPassword);
  });
  const inputExceed = computed(() => {
    // show exceed style if length of initial value greater then maxlength
    return unref(isWordLimitVisible) && unref(textLength) >= unref(upperLimit);
  });
  const showClear = computed(() => {
    return unref(clearable) && !unref(inputDisabled) && !unref(readonly) && unref(nativeInputValue) && (unref(focused) || unref(hovering));
  });
  const showPwdVisible = computed(() => {
    return unref(showPassword) && !unref(inputDisabled) && !unref(readonly) && (!!unref(nativeInputValue) || unref(focused));
  });

  const getSuffixVisible = () => {
    return slots.suffix || unref(suffixIcon) || unref(showClear) || unref(showPassword) || unref(isWordLimitVisible) || unref(validateState) && unref(needStatusIcon);
  };

  return {
    input: input.value || textarea,
    inputSize,
    inputDisabled,
    nativeInputValue,
    isWordLimitVisible,
    inputExceed,
    upperLimit,
    textLength,
    showClear,
    showPwdVisible,
    getSuffixVisible
  };
};
const useInteractive = (instance, input, textarea, {
  modelValue,
  validateEvent
}, {
  focused,
  isComposing,
  passwordVisible
}, nativeInputValue, emit, slots) => {
  const getInput = () => {
    return unref(input) || unref(textarea);
  };

  const focus = () => {
    getInput().focus();
  };

  const blur = () => {
    getInput().blur();
  };

  const select = () => {
    getInput().select();
  };

  const setNativeInputValue = () => {
    const input = getInput();
    if (!input) return;
    if (input.value === unref(nativeInputValue)) return;
    input.value = unref(nativeInputValue);
  };

  const handleBlur = event => {
    focused.value = false;
    emit('blur', event);

    if (unref(validateEvent)) {
      instance.proxy.dispatch('el.form.blur', [unref(modelValue)]);
    }
  };

  const handleFocus = event => {
    focused.value = true;
    emit('focus', event);
  };

  const handleInput = event => {
    // should not emit input during composition
    // see: https://github.com/ElemeFE/element/issues/10516
    if (unref(isComposing)) return; // hack for https://github.com/ElemeFE/element/issues/8548
    // should remove the following line when we don't support IE

    if (event.target.value === unref(nativeInputValue)) return;
    emit('update:modelValue', event.target.value);
    emit('input', event.target.value); // ensure native input value is controlled
    // see: https://github.com/ElemeFE/element/issues/12850

    nextTick(setNativeInputValue);
  };

  const handleChange = event => {
    emit('update:modelValue', event.target.value);
    emit('change', event.target.value);
  };

  const handleCompositionStart = () => {
    isComposing.value = true;
  };

  const handleCompositionUpdate = event => {
    const text = event.target.value;
    const lastCharacter = text[text.length - 1] || '';
    isComposing.value = !isKorean(lastCharacter);
  };

  const handleCompositionEnd = event => {
    if (unref(isComposing)) {
      isComposing.value = false;
      handleInput(event);
    }
  };

  const clear = () => {
    emit('update:modelValue', '');
    emit('input', '');
    emit('change', '');
    emit('clear');
  };

  const handlePasswordVisible = () => {
    passwordVisible.value = !unref(passwordVisible);
    focus();
  };

  const calcIconOffset = place => {
    const $el = instance.proxy.$el;
    const elList = [].slice.call($el.querySelectorAll(`.el-input__${place}`) || []);
    if (!elList.length) return;
    let el = null;

    for (let i = 0; i < elList.length; i++) {
      if (elList[i].parentNode === $el) {
        el = elList[i];
        break;
      }
    }

    if (!el) return;
    const pendantMap = {
      suffix: 'append',
      prefix: 'prepend'
    };
    const pendant = pendantMap[place];

    if (slots[pendant]) {
      el.style.transform = `translateX(${place === 'suffix' ? '-' : ''}${$el.querySelector(`.el-input-group__${pendant}`).offsetWidth}px)`;
    } else {
      el.removeAttribute('style');
    }
  };

  const updateIconOffset = () => {
    calcIconOffset('prefix');
    calcIconOffset('suffix');
  };

  watch(() => unref(nativeInputValue), () => {
    setNativeInputValue();
  });
  return {
    focus,
    blur,
    select,
    setNativeInputValue,
    getInput,
    handleBlur,
    handleFocus,
    handleInput,
    handleChange,
    handleCompositionStart,
    handleCompositionUpdate,
    handleCompositionEnd,
    clear,
    handlePasswordVisible,
    updateIconOffset
  };
};
const useStatusIcon = () => {
  const elForm = inject('elForm', {});
  const needStatusIcon = computed(() => {
    return !!unref(elForm).statusIcon;
  });
  return {
    needStatusIcon
  };
};

// todo:
var script$g = {
  name: 'ElInput',
  componentName: 'ElInput',
  mixins: [Emitter],
  inheritAttrs: false,
  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },
  emits: ['input', 'change', 'blur', 'clear', 'focus', 'update:modelValue'],

  setup(props, {
    attrs,
    emit,
    slots
  }) {
    const {
      dispatch
    } = useEmitter();
    const state = reactive({
      textareaCalcStyle: {},
      hovering: false,
      focused: false,
      isComposing: false,
      passwordVisible: false
    });
    const {
      type,
      modelValue,
      validateEvent
    } = toRefs(props);
    const instance = getCurrentInstance();
    const {
      needStatusIcon
    } = useStatusIcon();
    const {
      validateState,
      validateIcon
    } = useValidate();
    const {
      textarea,
      textareaStyle,
      resizeTextarea
    } = useTextarea(toRefs(props), toRef(state, 'textareaCalcStyle'));
    const {
      input,
      inputSize,
      inputDisabled,
      nativeInputValue,
      textLength,
      upperLimit,
      isWordLimitVisible,
      inputExceed,
      showClear,
      showPwdVisible,
      getSuffixVisible
    } = useInput(toRefs(props), toRefs(state), instance, textarea, attrs, validateState, needStatusIcon, slots);
    const {
      focus,
      blur,
      select,
      setNativeInputValue,
      handleBlur,
      handleFocus,
      handleInput,
      handleChange,
      handleCompositionStart,
      handleCompositionUpdate,
      handleCompositionEnd,
      clear,
      handlePasswordVisible,
      updateIconOffset
    } = useInteractive(instance, input, textarea, toRefs(props), toRefs(state), nativeInputValue, emit, slots); // when change between <input> and <textarea>,
    // update DOM dependent value and styles
    // https://github.com/ElemeFE/element/issues/14857

    watch(() => unref(type), () => {
      nextTick(() => {
        setNativeInputValue();
        resizeTextarea();
        updateIconOffset();
      });
    });
    watch(() => unref(modelValue), val => {
      nextTick(() => {
        setNativeInputValue();
        resizeTextarea();
      });

      if (unref(validateEvent)) {
        dispatch('el.form.change', val);
      }
    });
    onMounted(() => {
      setNativeInputValue();
      resizeTextarea();
      updateIconOffset();
    });
    onUpdated(() => {
      nextTick(updateIconOffset);
    });
    return { ...toRefs(state),
      classProp: props.class,
      inputSize,
      validateState,
      validateIcon,
      inputDisabled,
      nativeInputValue,
      upperLimit,
      isWordLimitVisible,
      inputExceed,
      textLength,
      textarea,
      textareaStyle,
      getSuffixVisible,
      resizeTextarea,
      input,
      showClear,
      showPwdVisible,
      focus,
      blur,
      select,
      setNativeInputValue,
      handleBlur,
      handleFocus,
      handleInput,
      handleChange,
      handleCompositionStart,
      handleCompositionUpdate,
      handleCompositionEnd,
      clear,
      handlePasswordVisible,
      updateIconOffset,
      needStatusIcon
    };
  },

  props: {
    modelValue: [String, Number],
    size: String,
    resize: String,
    form: String,
    disabled: Boolean,
    readonly: Boolean,
    class: String,
    type: {
      type: String,
      default: 'text'
    },
    autosize: {
      type: [Boolean, Object],
      default: false
    },
    autocomplete: {
      type: String,
      default: 'off'
    },
    validateEvent: {
      type: Boolean,
      default: true
    },
    suffixIcon: String,
    prefixIcon: String,
    label: String,
    clearable: {
      type: Boolean,
      default: false
    },
    showPassword: {
      type: Boolean,
      default: false
    },
    showWordLimit: {
      type: Boolean,
      default: false
    },
    tabindex: String
  }
};

const _hoisted_1$7 = {
  key: 0,
  class: "el-input-group__prepend"
};
const _hoisted_2$2 = {
  key: 2,
  class: "el-input__prefix"
};
const _hoisted_3 = {
  key: 3,
  class: "el-input__suffix"
};
const _hoisted_4 = { class: "el-input__suffix-inner" };
const _hoisted_5 = {
  key: 3,
  class: "el-input__count"
};
const _hoisted_6 = { class: "el-input__count-inner" };
const _hoisted_7 = {
  key: 4,
  class: "el-input-group__append"
};
const _hoisted_8 = {
  key: 2,
  class: "el-input__count"
};

function render$f(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    style: _ctx.$attrs.style,
    class: [
      $setup.classProp,
      $props.type === 'textarea' ? 'el-textarea' : 'el-input',
      $setup.inputSize ? 'el-input--' + $setup.inputSize : '',
      {
        'is-disabled': $setup.inputDisabled,
        'is-exceed': $setup.inputExceed,
        'el-input-group': _ctx.$slots.prepend || _ctx.$slots.append,
        'el-input-group--append': _ctx.$slots.append,
        'el-input-group--prepend': _ctx.$slots.prepend,
        'el-input--prefix': _ctx.$slots.prefix || $props.prefixIcon,
        'el-input--suffix':
          _ctx.$slots.suffix || $props.suffixIcon || $props.clearable || $props.showPassword
      }
    ],
    onMouseenter: _cache[18] || (_cache[18] = $event => (_ctx.hovering = true)),
    onMouseleave: _cache[19] || (_cache[19] = $event => (_ctx.hovering = false))
  }, [
    ($props.type !== 'textarea')
      ? (openBlock(), createBlock(Fragment, { key: 0 }, [
          createCommentVNode(" 前置元素 "),
          (_ctx.$slots.prepend)
            ? (openBlock(), createBlock("div", _hoisted_1$7, [
                renderSlot(_ctx.$slots, "prepend")
              ]))
            : createCommentVNode("v-if", true),
          ($props.type !== 'textarea')
            ? (openBlock(), createBlock("input", mergeProps({
                key: 1,
                tabindex: $props.tabindex,
                class: "el-input__inner"
              }, _ctx.$attrs, {
                type: $props.showPassword ? (_ctx.passwordVisible ? 'text' : 'password') : $props.type,
                disabled: $setup.inputDisabled,
                readonly: $props.readonly,
                autocomplete: $props.autocomplete,
                ref: "input",
                onCompositionstart: _cache[1] || (_cache[1] = (...args) => ($setup.handleCompositionStart(...args))),
                onCompositionupdate: _cache[2] || (_cache[2] = (...args) => ($setup.handleCompositionUpdate(...args))),
                onCompositionend: _cache[3] || (_cache[3] = (...args) => ($setup.handleCompositionEnd(...args))),
                onInput: _cache[4] || (_cache[4] = (...args) => ($setup.handleInput(...args))),
                onFocus: _cache[5] || (_cache[5] = (...args) => ($setup.handleFocus(...args))),
                onBlur: _cache[6] || (_cache[6] = (...args) => ($setup.handleBlur(...args))),
                onChange: _cache[7] || (_cache[7] = (...args) => ($setup.handleChange(...args))),
                "aria-label": $props.label
              }), null, 16 /* FULL_PROPS */, ["tabindex", "type", "disabled", "readonly", "autocomplete", "aria-label"]))
            : createCommentVNode("v-if", true),
          createCommentVNode(" 前置内容 "),
          (_ctx.$slots.prefix || $props.prefixIcon)
            ? (openBlock(), createBlock("span", _hoisted_2$2, [
                renderSlot(_ctx.$slots, "prefix"),
                ($props.prefixIcon)
                  ? (openBlock(), createBlock("i", {
                      key: 0,
                      class: ["el-input__icon", $props.prefixIcon]
                    }, null, 2 /* CLASS */))
                  : createCommentVNode("v-if", true)
              ]))
            : createCommentVNode("v-if", true),
          createCommentVNode(" 后置内容 "),
          ($setup.getSuffixVisible())
            ? (openBlock(), createBlock("span", _hoisted_3, [
                createVNode("span", _hoisted_4, [
                  (!$setup.showClear || !$setup.showPwdVisible || !$setup.isWordLimitVisible)
                    ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                        renderSlot(_ctx.$slots, "suffix"),
                        ($props.suffixIcon)
                          ? (openBlock(), createBlock("i", {
                              key: 0,
                              class: ["el-input__icon", $props.suffixIcon]
                            }, null, 2 /* CLASS */))
                          : createCommentVNode("v-if", true)
                      ], 64 /* STABLE_FRAGMENT */))
                    : createCommentVNode("v-if", true),
                  ($setup.showClear)
                    ? (openBlock(), createBlock("i", {
                        key: 1,
                        class: "el-input__icon el-icon-circle-close el-input__clear",
                        onMousedown: _cache[8] || (_cache[8] = withModifiers(() => {}, ["prevent"])),
                        onClick: _cache[9] || (_cache[9] = (...args) => ($setup.clear(...args)))
                      }, null, 32 /* HYDRATE_EVENTS */))
                    : createCommentVNode("v-if", true),
                  ($setup.showPwdVisible)
                    ? (openBlock(), createBlock("i", {
                        key: 2,
                        class: "el-input__icon el-icon-view el-input__clear",
                        onClick: _cache[10] || (_cache[10] = (...args) => ($setup.handlePasswordVisible(...args)))
                      }))
                    : createCommentVNode("v-if", true),
                  ($setup.isWordLimitVisible)
                    ? (openBlock(), createBlock("span", _hoisted_5, [
                        createVNode("span", _hoisted_6, toDisplayString($setup.textLength) + "/" + toDisplayString($setup.upperLimit), 1 /* TEXT */)
                      ]))
                    : createCommentVNode("v-if", true)
                ]),
                ($setup.validateState)
                  ? (openBlock(), createBlock("i", {
                      key: 0,
                      class: ["el-input__icon", ['el-input__validateIcon', $setup.validateIcon]]
                    }, null, 2 /* CLASS */))
                  : createCommentVNode("v-if", true)
              ]))
            : createCommentVNode("v-if", true),
          createCommentVNode(" 后置元素 "),
          (_ctx.$slots.append)
            ? (openBlock(), createBlock("div", _hoisted_7, [
                renderSlot(_ctx.$slots, "append")
              ]))
            : createCommentVNode("v-if", true)
        ], 64 /* STABLE_FRAGMENT */))
      : (openBlock(), createBlock("textarea", mergeProps({
          key: 1,
          tabindex: $props.tabindex,
          class: "el-textarea__inner",
          onCompositionstart: _cache[11] || (_cache[11] = (...args) => ($setup.handleCompositionStart(...args))),
          onCompositionupdate: _cache[12] || (_cache[12] = (...args) => ($setup.handleCompositionUpdate(...args))),
          onCompositionend: _cache[13] || (_cache[13] = (...args) => ($setup.handleCompositionEnd(...args))),
          onInput: _cache[14] || (_cache[14] = (...args) => ($setup.handleInput(...args))),
          ref: "textarea"
        }, _ctx.$attrs, {
          disabled: $setup.inputDisabled,
          readonly: $props.readonly,
          autocomplete: $props.autocomplete,
          style: $setup.textareaStyle,
          onFocus: _cache[15] || (_cache[15] = (...args) => ($setup.handleFocus(...args))),
          onBlur: _cache[16] || (_cache[16] = (...args) => ($setup.handleBlur(...args))),
          onChange: _cache[17] || (_cache[17] = (...args) => ($setup.handleChange(...args))),
          "aria-label": $props.label
        }), null, 16 /* FULL_PROPS */, ["tabindex", "disabled", "readonly", "autocomplete", "aria-label"])),
    ($setup.isWordLimitVisible && $props.type === 'textarea')
      ? (openBlock(), createBlock("span", _hoisted_8, toDisplayString($setup.textLength) + "/" + toDisplayString($setup.upperLimit), 1 /* TEXT */))
      : createCommentVNode("v-if", true)
  ], 38 /* CLASS, STYLE, HYDRATE_EVENTS */))
}

script$g.render = render$f;
script$g.__file = "packages/input/Input.vue";

/* istanbul ignore next */

script$g.install = function (app) {
  app.component(script$g.name, script$g);
};

function useFocus(ref) {
  return function focus() {
    if (isRef(ref)) {
      ref.value.focus();
    } else {
      const {
        ctx
      } = getCurrentInstance();
      ctx.$refs[ref].focus();
    }
  };
}

const INTERVAL_TIME = 100;
var RepeatClick = {
  beforeMount(el, binding) {
    let startTime;
    let intervalId;

    const callHandler = () => binding.value && binding.value();

    const clearIntervalHandler = () => {
      if (intervalId) {
        clearInterval(intervalId);
        intervalId = null;
      }
    };

    const isMainKey = e => {
      // 0：主按键，通常指鼠标左键或默认值
      return e.button === 0;
    };

    const handleMouseup = () => {
      if (Date.now() - startTime < INTERVAL_TIME) {
        callHandler();
      }

      clearIntervalHandler();
    };

    const handleMousedown = e => {
      if (!isMainKey(e)) return;
      startTime = Date.now();
      once(document, 'mouseup', handleMouseup);
      clearIntervalHandler();
      intervalId = setInterval(callHandler, INTERVAL_TIME);
    };

    on(el, 'mousedown', handleMousedown);
  }

};

var script$h = {
  name: 'ElInputNumber',
  directives: {
    repeatClick: RepeatClick
  },
  components: {
    ElInput: script$g
  },
  props: {
    step: {
      type: Number,
      default: 1
    },
    stepStrictly: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    modelValue: {
      type: Number,
      default: 0
    },
    disabled: Boolean,
    size: {
      default: '',
      type: String
    },
    controls: {
      type: Boolean,
      default: true
    },
    controlsPosition: {
      type: String,
      default: ''
    },
    name: String,
    label: String,
    placeholder: String,
    precision: {
      type: Number,

      validator(val) {
        return val >= 0 && val === parseInt(val, 10);
      },

      default: undefined
    }
  },
  emits: ['change', 'update:modelValue', 'blur', 'focus'],

  setup(props, {
    emit
  }) {
    const {
      ctx
    } = getCurrentInstance();
    const {
      step,
      stepStrictly,
      max,
      min,
      modelValue,
      disabled,
      size,
      controls,
      controlsPosition,
      precision
    } = toRefs(props);
    const state = reactive({
      currentValue: 0,
      userInput: null
    });
    const focus = useFocus('input');

    const getPrecision = value => {
      if (value === undefined) return 0;
      const valueString = value.toString();
      const dotPosition = valueString.indexOf('.');
      let precision = 0;

      if (dotPosition !== -1) {
        precision = valueString.length - dotPosition - 1;
      }

      return precision;
    };

    const setCurrentValue = newVal => {
      const oldVal = state.currentValue;

      if (typeof newVal === 'number' && precision.value !== undefined) {
        newVal = toPrecision(newVal, precision.value);
      }

      if (newVal >= max.value) newVal = max.value;
      if (newVal <= min.value) newVal = min.value;
      if (oldVal === newVal) return;
      state.userInput = null;
      emit('update:modelValue', newVal);
      emit('change', newVal, oldVal);
      state.currentValue = newVal;
    };

    const toPrecision = (num, precision) => {
      if (precision === undefined) precision = numPrecision.value;
      return parseFloat(Math.round(num * Math.pow(10, precision)) / Math.pow(10, precision));
    };

    const _decrease = (val, step) => {
      if (typeof val !== 'number' && val !== undefined) {
        return state.currentValue;
      }

      const precisionFactor = Math.pow(10, numPrecision.value);
      return toPrecision((precisionFactor * val - precisionFactor * step) / precisionFactor);
    };

    const _increase = (val, step) => {
      if (typeof val !== 'number' && val !== undefined) {
        return state.currentValue;
      }

      const precisionFactor = Math.pow(10, numPrecision.value); // Solve the accuracy problem of JS decimal calculation by converting the value to integer.

      return toPrecision((precisionFactor * val + precisionFactor * step) / precisionFactor);
    };

    const minDisabled = computed(() => {
      return _decrease(modelValue.value, step.value) < min.value;
    });
    const maxDisabled = computed(() => {
      return _increase(modelValue.value, step.value) > max.value;
    });
    const numPrecision = computed(() => {
      const stepPrecision = getPrecision(step.value);

      if (precision.value !== undefined) {
        if (stepPrecision > precision.value) {
          console.warn('[Element Warn][InputNumber]precision should not be less than the decimal places of step');
        }

        return precision.value;
      } else {
        return Math.max(getPrecision(modelValue.value), stepPrecision);
      }
    });
    const controlsAtRight = computed(() => controls.value && controlsPosition.value === 'right');

    const _elFormItemSize = computed(() => {
      const elFormItem = inject('elFormItem', {});
      return (elFormItem || {}).elFormItemSize;
    });

    const inputNumberSize = computed(() => {
      return size.value || _elFormItemSize.value || (ctx.$ELEMENT || {}).size;
    });
    const inputNumberDisabled = computed(() => {
      const elForm = inject('elForm', {});
      return disabled.value || !!(elForm || {}).disabled;
    });
    const displayValue = computed({
      get: () => {
        if (state.userInput !== null) {
          return state.userInput;
        }

        let currentValue = state.currentValue;

        if (typeof currentValue === 'number') {
          if (stepStrictly.value) {
            const stepPrecision = getPrecision(step.value);
            const precisionFactor = Math.pow(10, stepPrecision);
            currentValue = Math.round(currentValue / step.value) * precisionFactor * step.value / precisionFactor;
          }

          if (precision.value !== undefined) {
            currentValue = currentValue.toFixed(precision.value);
          }
        }

        return currentValue;
      },
      set: () => {
        return state.currentValue;
      }
    });

    const increase = () => {
      if (inputNumberDisabled.value || maxDisabled.value) return;
      const value = modelValue.value || 0;

      const newVal = _increase(value, step.value);

      setCurrentValue(newVal);
    };

    const decrease = () => {
      if (inputNumberDisabled.value || minDisabled.value) return;
      const value = modelValue.value || 0;

      const newVal = _decrease(value, step.value);

      setCurrentValue(newVal);
    };

    const handleInput = value => {
      state.userInput = value;
    };

    const handleInputChange = value => {
      const newVal = value === '' ? undefined : Number(value);

      if (!isNaN(newVal) || value === '') {
        setCurrentValue(newVal);
      }

      state.userInput = null;
    };

    onMounted(() => {
      const {
        refs
      } = getCurrentInstance();
      const innerInput = refs.input.$el && refs.input.$refs.input;
      innerInput.setAttribute('role', 'spinbutton');
      innerInput.setAttribute('aria-valuemax', max.value);
      innerInput.setAttribute('aria-valuemin', min.value);
      innerInput.setAttribute('aria-valuenow', state.currentValue);
      innerInput.setAttribute('aria-disabled', inputNumberDisabled.value);
    });
    onUpdated(() => {
      const {
        refs
      } = getCurrentInstance();
      if (!refs || !refs.input.$el) return;
      const innerInput = refs.input.$el && refs.input.$refs.input;
      innerInput.setAttribute('aria-valuenow', state.currentValue);
    });
    watch(modelValue, value => {
      let newVal = value === undefined ? value : Number(value);

      if (newVal !== undefined) {
        if (isNaN(newVal)) {
          return;
        }

        if (stepStrictly.value) {
          const stepPrecision = getPrecision(step.value);
          const precisionFactor = Math.pow(10, stepPrecision);
          newVal = Math.round(newVal / step.value) * precisionFactor * step.value / precisionFactor;
        }

        if (precision.value !== undefined) {
          newVal = toPrecision(newVal, precision.value);
        }
      }

      if (newVal >= max.value) newVal = max.value;
      if (newVal <= min.value) newVal = min.value;
      state.currentValue = newVal;
      state.userInput = null;
      emit('update:modelValue', newVal);
    }, {
      immediate: true
    });

    const handleBlur = event => {
      emit('blur', event);
    };

    const handleFocus = event => {
      emit('focus', event);
    };

    const select = () => {};

    return {
      controlsAtRight,
      inputNumberSize,
      displayValue,
      minDisabled,
      maxDisabled,
      inputNumberDisabled,
      increase,
      decrease,
      handleInputChange,
      handleInput,
      focus,
      setCurrentValue,
      handleBlur,
      handleFocus,
      select
    };
  }

};

function render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _directive_repeat_click = resolveDirective("repeat-click");

  return (openBlock(), createBlock("div", {
    class: [
      'el-input-number',
      $setup.inputNumberSize ? 'el-input-number--' + $setup.inputNumberSize : '',
      { 'is-disabled': $setup.inputNumberDisabled },
      { 'is-without-controls': !$props.controls },
      { 'is-controls-right': $setup.controlsAtRight }
    ],
    onDragstart: _cache[4] || (_cache[4] = withModifiers(() => {}, ["prevent"]))
  }, [
    ($props.controls)
      ? withDirectives((openBlock(), createBlock("span", {
          key: 0,
          class: [{ 'is-disabled': $setup.minDisabled }, "el-input-number__decrease"],
          onKeydown: _cache[1] || (_cache[1] = withKeys((...args) => ($setup.decrease(...args)), ["enter"])),
          role: "button"
        }, [
          createVNode("i", {
            class: `el-icon-${$setup.controlsAtRight ? 'arrow-down' : 'minus'}`
          }, null, 2 /* CLASS */)
        ], 34 /* CLASS, HYDRATE_EVENTS */)), [
          [_directive_repeat_click, $setup.decrease]
        ])
      : createCommentVNode("v-if", true),
    ($props.controls)
      ? withDirectives((openBlock(), createBlock("span", {
          key: 1,
          class: [{ 'is-disabled': $setup.maxDisabled }, "el-input-number__increase"],
          onKeydown: _cache[2] || (_cache[2] = withKeys((...args) => ($setup.increase(...args)), ["enter"])),
          role: "button"
        }, [
          createVNode("i", {
            class: `el-icon-${$setup.controlsAtRight ? 'arrow-up' : 'plus'}`
          }, null, 2 /* CLASS */)
        ], 34 /* CLASS, HYDRATE_EVENTS */)), [
          [_directive_repeat_click, $setup.increase]
        ])
      : createCommentVNode("v-if", true),
    createVNode(_component_el_input, {
      disabled: $setup.inputNumberDisabled,
      label: $props.label,
      max: $props.max,
      min: $props.min,
      name: $props.name,
      placeholder: $props.placeholder,
      size: $setup.inputNumberSize,
      onBlur: $setup.handleBlur,
      onChange: $setup.handleInputChange,
      onFocus: $setup.handleFocus,
      onInput: $setup.handleInput,
      onKeydown: [
        withKeys(withModifiers($setup.decrease, ["prevent"]), ["down"]),
        withKeys(withModifiers($setup.increase, ["prevent"]), ["up"])
      ],
      ref: "input",
      modelValue: $setup.displayValue,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ($setup.displayValue = $event))
    }, null, 8 /* PROPS */, ["disabled", "label", "max", "min", "name", "placeholder", "size", "onBlur", "onChange", "onFocus", "onInput", "onKeydown", "modelValue"])
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$h.render = render$g;
script$h.__file = "packages/input-number/InputNumber.vue";

/* istanbul ignore next */

script$h.install = function (app) {
  app.component(script$h.name, script$h);
};

function Focus (ref) {
  return {
    methods: {
      focus() {
        this.$refs[ref].focus();
      }

    }
  };
}

var defaultLang = {
  el: {
    colorpicker: {
      confirm: '确定',
      clear: '清空'
    },
    datepicker: {
      now: '此刻',
      today: '今天',
      cancel: '取消',
      clear: '清空',
      confirm: '确定',
      selectDate: '选择日期',
      selectTime: '选择时间',
      startDate: '开始日期',
      startTime: '开始时间',
      endDate: '结束日期',
      endTime: '结束时间',
      prevYear: '前一年',
      nextYear: '后一年',
      prevMonth: '上个月',
      nextMonth: '下个月',
      year: '年',
      month1: '1 月',
      month2: '2 月',
      month3: '3 月',
      month4: '4 月',
      month5: '5 月',
      month6: '6 月',
      month7: '7 月',
      month8: '8 月',
      month9: '9 月',
      month10: '10 月',
      month11: '11 月',
      month12: '12 月',
      // week: '周次',
      weeks: {
        sun: '日',
        mon: '一',
        tue: '二',
        wed: '三',
        thu: '四',
        fri: '五',
        sat: '六'
      },
      months: {
        jan: '一月',
        feb: '二月',
        mar: '三月',
        apr: '四月',
        may: '五月',
        jun: '六月',
        jul: '七月',
        aug: '八月',
        sep: '九月',
        oct: '十月',
        nov: '十一月',
        dec: '十二月'
      }
    },
    select: {
      loading: '加载中',
      noMatch: '无匹配数据',
      noData: '无数据',
      placeholder: '请选择'
    },
    cascader: {
      noMatch: '无匹配数据',
      loading: '加载中',
      placeholder: '请选择',
      noData: '暂无数据'
    },
    pagination: {
      goto: '前往',
      pagesize: '条/页',
      total: '共 {total} 条',
      pageClassifier: '页'
    },
    messagebox: {
      title: '提示',
      confirm: '确定',
      cancel: '取消',
      error: '输入的数据不合法!'
    },
    upload: {
      deleteTip: '按 delete 键可删除',
      delete: '删除',
      preview: '查看图片',
      continue: '继续上传'
    },
    table: {
      emptyText: '暂无数据',
      confirmFilter: '筛选',
      resetFilter: '重置',
      clearFilter: '全部',
      sumText: '合计'
    },
    tree: {
      emptyText: '暂无数据'
    },
    transfer: {
      noMatch: '无匹配数据',
      noData: '无数据',
      titles: ['列表 1', '列表 2'],
      filterPlaceholder: '请输入搜索内容',
      noCheckedFormat: '共 {total} 项',
      hasCheckedFormat: '已选 {checked}/{total} 项'
    },
    image: {
      error: '加载失败'
    },
    pageHeader: {
      title: '返回'
    },
    popconfirm: {
      confirmButtonText: '确定',
      cancelButtonText: '取消'
    }
  }
};

function isString(obj) {
  return Object.prototype.toString.call(obj) === '[object String]';
}
function isObject(obj) {
  return Object.prototype.toString.call(obj) === '[object Object]';
}
function isArray$1(value) {
  return value instanceof Array;
}
function isHtmlElement(node) {
  return node && node.nodeType === Node.ELEMENT_NODE;
}
const isFunction = functionToCheck => {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
};
const isUndefined = val => {
  // eslint-disable-next-line no-void
  return val === void 0;
};
const isDefined = val => {
  return val !== undefined && val !== null;
};

const hasOwnProperty = Object.prototype.hasOwnProperty;
function noop() {}
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

function extend(to, _from) {
  for (const key in _from) {
    to[key] = _from[key];
  }

  return to;
}

function toObject(arr) {
  var res = {};

  for (let i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }

  return res;
}
const getValueByPath = function (object, prop) {
  prop = prop || '';
  const paths = prop.split('.');
  let current = object;
  let result = null;

  for (let i = 0, j = paths.length; i < j; i++) {
    const path = paths[i];
    if (!current) break;

    if (i === j - 1) {
      result = current[path];
      break;
    }

    current = current[path];
  }

  return result;
};
function getPropByPath(obj, path, strict) {
  let tempObj = obj;
  path = path.replace(/\[(\w+)\]/g, '.$1');
  path = path.replace(/^\./, '');
  const keyArr = path.split('.');
  let i = 0;

  for (let len = keyArr.length; i < len - 1; ++i) {
    if (!tempObj && !strict) break;
    const key = keyArr[i];

    if (key in tempObj) {
      tempObj = tempObj[key];
    } else {
      if (strict) {
        throw new Error('please transfer a valid prop path to form item!');
      }

      break;
    }
  }

  return {
    o: tempObj,
    k: keyArr[i],
    v: tempObj ? tempObj[keyArr[i]] : null
  };
}
const generateId = function () {
  return Math.floor(Math.random() * 10000);
};
const valueEquals = (a, b) => {
  // see: https://stackoverflow.com/questions/3115982/how-to-check-if-two-arrays-are-equal-with-javascript
  if (a === b) return true;
  if (!(a instanceof Array)) return false;
  if (!(b instanceof Array)) return false;
  if (a.length !== b.length) return false;

  for (let i = 0; i !== a.length; ++i) {
    if (a[i] !== b[i]) return false;
  }

  return true;
};
const escapeRegexpString = (value = '') => String(value).replace(/[|\\{}()[\]^$+*?.]/g, '\\$&'); // TODO: use native Array.find, Array.findIndex when IE support is dropped

const arrayFindIndex = function (arr, pred) {
  for (let i = 0; i !== arr.length; ++i) {
    if (pred(arr[i])) {
      return i;
    }
  }

  return -1;
};
const arrayFind = function (arr, pred) {
  const idx = arrayFindIndex(arr, pred);
  return idx !== -1 ? arr[idx] : undefined;
}; // coerce truthy value to array

const coerceTruthyValueToArray = function (val) {
  if (Array.isArray(val)) {
    return val;
  } else if (val) {
    return [val];
  } else {
    return [];
  }
};
const isIE = function () {
  return !isNaN(Number(document.documentMode)); // return !Vue.prototype.$isServer && !isNaN(Number(document.documentMode))
};
const isEdge = function () {
  return navigator.userAgent.indexOf('Edge') > -1; // return !Vue.prototype.$isServer && navigator.userAgent.indexOf('Edge') > -1
};
const isFirefox = function () {
  return !!window.navigator.userAgent.match(/firefox/i); // return !Vue.prototype.$isServer && !!window.navigator.userAgent.match(/firefox/i)
};
const autoprefixer = function (style) {
  if (typeof style !== 'object') return style;
  const rules = ['transform', 'transition', 'animation'];
  const prefixes = ['ms-', 'webkit-'];
  rules.forEach(rule => {
    const value = style[rule];

    if (rule && value) {
      prefixes.forEach(prefix => {
        style[prefix + rule] = value;
      });
    }
  });
  return style;
};
const kebabCase = function (str) {
  const hyphenateRE = /([^-])([A-Z])/g;
  return str.replace(hyphenateRE, '$1-$2').replace(hyphenateRE, '$1-$2').toLowerCase();
};
const capitalize = function (str) {
  if (!isString(str)) return str;
  return str.charAt(0).toUpperCase() + str.slice(1);
};
const looseEqual = function (a, b) {
  const isObjectA = isObject(a);
  const isObjectB = isObject(b);

  if (isObjectA && isObjectB) {
    return JSON.stringify(a) === JSON.stringify(b);
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
};
const arrayEquals = function (arrayA, arrayB) {
  arrayA = arrayA || [];
  arrayB = arrayB || [];

  if (arrayA.length !== arrayB.length) {
    return false;
  }

  for (let i = 0; i < arrayA.length; i++) {
    if (!looseEqual(arrayA[i], arrayB[i])) {
      return false;
    }
  }

  return true;
};
const isEqual = function (value1, value2) {
  if (Array.isArray(value1) && Array.isArray(value2)) {
    return arrayEquals(value1, value2);
  }

  return looseEqual(value1, value2);
};
const isEmpty = function (val) {
  // null or undefined
  if (val == null) return true;
  if (typeof val === 'boolean') return false;
  if (typeof val === 'number') return !val;
  if (val instanceof Error) return val.message === '';

  switch (Object.prototype.toString.call(val)) {
    // String or Array
    case '[object String]':
    case '[object Array]':
      return !val.length;
    // Map or Set or File

    case '[object File]':
    case '[object Map]':
    case '[object Set]':
      {
        return !val.size;
      }
    // Plain Object

    case '[object Object]':
      {
        return !Object.keys(val).length;
      }
  }

  return false;
};
function rafThrottle(fn) {
  let locked = false;
  return function (...args) {
    if (locked) return;
    locked = true;
    window.requestAnimationFrame(() => {
      fn.apply(this, args);
      locked = false;
    });
  };
}

const RE_NARGS = /(%|)\{([0-9a-zA-Z_]+)\}/g;
/**
 *  String format template
 *  - Inspired:
 *    https://github.com/Matt-Esch/string-template/index.js
 */

function Format () {
  /**
   * template
   *
   * @param {String} string
   * @param {Array} ...args
   * @return {String}
   */
  function template(string, ...args) {
    if (args.length === 1 && typeof args[0] === 'object') {
      args = args[0];
    }

    if (!args || !args.hasOwnProperty) {
      args = {};
    }

    return string.replace(RE_NARGS, (match, prefix, i, index) => {
      let result;

      if (string[index - 1] === '{' && string[index + match.length] === '}') {
        return i;
      } else {
        result = hasOwn(args, i) ? args[i] : null;

        if (result === null || result === undefined) {
          return '';
        }

        return result;
      }
    });
  }

  return template;
}

const format = Format();
let lang = defaultLang; // let merged = false

let i18nHandler = function () {// #todo
  // const vuei18n = Object.getPrototypeOf(this || Vue).$t
  // if (typeof vuei18n === 'function' && !!Vue.locale) {
  //   if (!merged) {
  //     merged = true
  //     Vue.locale(
  //       Vue.config.lang,
  //       deepmerge(lang, Vue.locale(Vue.config.lang) || {}, { clone: true })
  //     )
  //   }
  //   return vuei18n.apply(this, arguments)
  // }
};

const t = function (path, options) {
  let value = i18nHandler.apply(this, arguments);
  if (value !== null && value !== undefined) return value;
  const array = path.split('.');
  let current = lang;

  for (let i = 0, j = array.length; i < j; i++) {
    const property = array[i];
    value = current[property];
    if (i === j - 1) return format(value, options);
    if (!value) return '';
    current = value;
  }

  return '';
};

var Locale = {
  methods: {
    t(...args) {
      return t.apply(this, args);
    }

  }
};

let hasModal = false;
let hasInitZIndex = false;
let zIndex;

const getModal = function () {
  // if (Vue.prototype.$isServer) return
  let modalDom = PopupManager.modalDom;

  if (modalDom) {
    hasModal = true;
  } else {
    hasModal = false;
    modalDom = document.createElement('div');
    PopupManager.modalDom = modalDom;
    modalDom.addEventListener('touchmove', function (event) {
      event.preventDefault();
      event.stopPropagation();
    }, {
      passive: true
    });
    modalDom.addEventListener('click', function () {
      PopupManager.doOnModalClick && PopupManager.doOnModalClick();
    });
  }

  return modalDom;
};

const instances = {};
const PopupManager = {
  modalFade: true,
  getInstance: function (id) {
    return instances[id];
  },
  register: function (id, instance) {
    if (id && instance) {
      instances[id] = instance;
    }
  },
  deregister: function (id) {
    if (id) {
      instances[id] = null;
      delete instances[id];
    }
  },
  nextZIndex: function () {
    return PopupManager.zIndex++;
  },
  modalStack: [],
  doOnModalClick: function () {
    const topItem = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topItem) return;
    const instance = PopupManager.getInstance(topItem.id);

    if (instance && instance.closeOnClickModal) {
      instance.close();
    }
  },
  openModal: function (id, zIndex, dom, modalClass, modalFade) {
    // if (Vue.prototype.$isServer) return
    if (!id || zIndex === undefined) return;
    this.modalFade = modalFade;
    const modalStack = this.modalStack;

    for (let i = 0, j = modalStack.length; i < j; i++) {
      const item = modalStack[i];

      if (item.id === id) {
        return;
      }
    }

    const modalDom = getModal();

    if (zIndex) {
      modalDom.style.zIndex = zIndex;
    }

    addClass(modalDom, 'v-modal');

    if (this.modalFade && !hasModal) {
      addClass(modalDom, 'v-modal-enter');
    }

    if (modalClass) {
      const classArr = modalClass.trim().split(/\s+/);
      classArr.forEach(item => addClass(modalDom, item));
    }

    setTimeout(() => {
      removeClass(modalDom, 'v-modal-enter');
    }, 200);

    if (dom && dom.parentNode && dom.parentNode.nodeType !== 11) {
      dom.parentNode.appendChild(modalDom);
    } else {
      document.body.appendChild(modalDom);
    }

    modalDom.tabIndex = 0;
    modalDom.style.display = '';
    this.modalStack.push({
      id: id,
      zIndex: zIndex,
      modalClass: modalClass
    });
  },
  closeModal: function (id) {
    const modalStack = this.modalStack;
    const modalDom = getModal();

    if (modalStack.length > 0) {
      const topItem = modalStack[modalStack.length - 1];

      if (topItem.id === id) {
        if (topItem.modalClass) {
          const classArr = topItem.modalClass.trim().split(/\s+/);
          classArr.forEach(item => removeClass(modalDom, item));
        }

        modalStack.pop();

        if (modalStack.length > 0) {
          modalDom.style.zIndex = modalStack[modalStack.length - 1].zIndex;
        }
      } else {
        for (let i = modalStack.length - 1; i >= 0; i--) {
          if (modalStack[i].id === id) {
            modalStack.splice(i, 1);
            break;
          }
        }
      }
    }

    if (modalStack.length === 0) {
      if (this.modalFade) {
        addClass(modalDom, 'v-modal-leave');
      }

      setTimeout(() => {
        if (modalStack.length === 0) {
          if (modalDom.parentNode) modalDom.parentNode.removeChild(modalDom);
          modalDom.style.display = 'none';
          PopupManager.modalDom = undefined;
        }

        removeClass(modalDom, 'v-modal-leave');
      }, 200);
    }
  }
};
Object.defineProperty(PopupManager, 'zIndex', {
  configurable: true,

  get() {
    if (!hasInitZIndex) {
      // zIndex = zIndex || (Vue.prototype.$ELEMENT || {}).zIndex || 2000
      zIndex = zIndex || 2000;
      hasInitZIndex = true;
    }

    return zIndex;
  },

  set(value) {
    zIndex = value;
  }

});

const getTopPopup = function () {
  // if (Vue.prototype.$isServer) return
  if (PopupManager.modalStack.length > 0) {
    const topPopup = PopupManager.modalStack[PopupManager.modalStack.length - 1];
    if (!topPopup) return;
    const instance = PopupManager.getInstance(topPopup.id);
    return instance;
  }
}; // if (!Vue.prototype.$isServer) {
// handle `esc` key when the popup is shown


window.addEventListener('keydown', function (event) {
  if (event.keyCode === 27) {
    const topPopup = getTopPopup();

    if (topPopup && topPopup.closeOnPressEscape) {
      topPopup.handleClose ? topPopup.handleClose() : topPopup.handleAction ? topPopup.handleAction('cancel') : topPopup.close();
    }
  }
});

let scrollBarWidth;
function getScrollBarWidth () {
  // if (Vue.prototype.$isServer) return 0
  if (scrollBarWidth !== undefined) return scrollBarWidth;
  const outer = document.createElement('div');
  outer.className = 'el-scrollbar__wrap';
  outer.style.visibility = 'hidden';
  outer.style.width = '100px';
  outer.style.position = 'absolute';
  outer.style.top = '-9999px';
  document.body.appendChild(outer);
  const widthNoScroll = outer.offsetWidth;
  outer.style.overflow = 'scroll';
  const inner = document.createElement('div');
  inner.style.width = '100%';
  outer.appendChild(inner);
  const widthWithScroll = inner.offsetWidth;
  outer.parentNode.removeChild(outer);
  scrollBarWidth = widthNoScroll - widthWithScroll;
  return scrollBarWidth;
}

/* eslint-disable no-unused-vars */

var root = window; // default options

var DEFAULTS = {
  // placement of the popper
  placement: 'bottom',
  gpuAcceleration: true,
  // shift popper from its origin by the given amount of pixels (can be negative)
  offset: 0,
  // the element which will act as boundary of the popper
  boundariesElement: 'viewport',
  // amount of pixel used to define a minimum distance between the boundaries and the popper
  boundariesPadding: 5,
  // popper will try to prevent overflow following this order,
  // by default, then, it could overflow on the left and on top of the boundariesElement
  preventOverflowOrder: ['left', 'right', 'top', 'bottom'],
  // the behavior used by flip to change the placement of the popper
  flipBehavior: 'flip',
  arrowElement: '[x-arrow]',
  arrowOffset: 0,
  // list of functions used to modify the offsets before they are applied to the popper
  modifiers: ['shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle'],
  modifiersIgnored: [],
  forceAbsolute: false
};
/**
 * Create a new Popper.js instance
 * @constructor Popper
 * @param {HTMLElement} reference - The reference element used to position the popper
 * @param {HTMLElement|Object} popper
 *      The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [popper.tagName='div'] The tag name of the generated popper.
 * @param {Array} [popper.classNames=['popper']] Array of classes to apply to the generated popper.
 * @param {Array} [popper.attributes] Array of attributes to apply, specify `attr:value` to assign a value to it.
 * @param {HTMLElement|String} [popper.parent=window.document.body] The parent element, given as HTMLElement or as query string.
 * @param {String} [popper.content=''] The content of the popper, it can be text, html, or node; if it is not text, set `contentType` to `html` or `node`.
 * @param {String} [popper.contentType='text'] If `html`, the `content` will be parsed as HTML. If `node`, it will be appended as-is.
 * @param {String} [popper.arrowTagName='div'] Same as `popper.tagName` but for the arrow element.
 * @param {Array} [popper.arrowClassNames='popper__arrow'] Same as `popper.classNames` but for the arrow element.
 * @param {String} [popper.arrowAttributes=['x-arrow']] Same as `popper.attributes` but for the arrow element.
 * @param {Object} options
 * @param {String} [options.placement=bottom]
 *      Placement of the popper accepted values: `top(-start, -end), right(-start, -end), bottom(-start, -right),
 *      left(-start, -end)`
 *
 * @param {HTMLElement|String} [options.arrowElement='[x-arrow]']
 *      The DOM Node used as arrow for the popper, or a CSS selector used to get the DOM node. It must be child of
 *      its parent Popper. Popper.js will apply to the given element the style required to align the arrow with its
 *      reference element.
 *      By default, it will look for a child node of the popper with the `x-arrow` attribute.
 *
 * @param {Boolean} [options.gpuAcceleration=true]
 *      When this property is set to true, the popper position will be applied using CSS3 translate3d, allowing the
 *      browser to use the GPU to accelerate the rendering.
 *      If set to false, the popper will be placed using `top` and `left` properties, not using the GPU.
 *
 * @param {Number} [options.offset=0]
 *      Amount of pixels the popper will be shifted (can be negative).
 *
 * @param {String|Element} [options.boundariesElement='viewport']
 *      The element which will define the boundaries of the popper position, the popper will never be placed outside
 *      of the defined boundaries (except if `keepTogether` is enabled)
 *
 * @param {Number} [options.boundariesPadding=5]
 *      Additional padding for the boundaries
 *
 * @param {Array} [options.preventOverflowOrder=['left', 'right', 'top', 'bottom']]
 *      Order used when Popper.js tries to avoid overflows from the boundaries, they will be checked in order,
 *      this means that the last ones will never overflow
 *
 * @param {String|Array} [options.flipBehavior='flip']
 *      The behavior used by the `flip` modifier to change the placement of the popper when the latter is trying to
 *      overlap its reference element. Defining `flip` as value, the placement will be flipped on
 *      its axis (`right - left`, `top - bottom`).
 *      You can even pass an array of placements (eg: `['right', 'left', 'top']` ) to manually specify
 *      how alter the placement when a flip is needed. (eg. in the above example, it would first flip from right to left,
 *      then, if even in its new placement, the popper is overlapping its reference element, it will be moved to top)
 *
 * @param {Array} [options.modifiers=[ 'shift', 'offset', 'preventOverflow', 'keepTogether', 'arrow', 'flip', 'applyStyle']]
 *      List of functions used to modify the data before they are applied to the popper, add your custom functions
 *      to this array to edit the offsets and placement.
 *      The function should reflect the @params and @returns of preventOverflow
 *
 * @param {Array} [options.modifiersIgnored=[]]
 *      Put here any built-in modifier name you want to exclude from the modifiers list
 *      The function should reflect the @params and @returns of preventOverflow
 *
 * @param {Boolean} [options.removeOnDestroy=false]
 *      Set to true if you want to automatically remove the popper when you call the `destroy` method.
 */

function Popper(reference, popper, options) {
  this._reference = reference.jquery ? reference[0] : reference;
  this.state = {}; // if the popper variable is a configuration object, parse it to generate an HTMLElement
  // generate a default popper if is not defined

  var isNotDefined = typeof popper === 'undefined' || popper === null;
  var isConfig = popper && Object.prototype.toString.call(popper) === '[object Object]';

  if (isNotDefined || isConfig) {
    this._popper = this.parse(isConfig ? popper : {});
  } // otherwise, use the given HTMLElement as popper
  else {
      this._popper = popper.jquery ? popper[0] : popper;
    } // with {} we create a new object with the options inside it


  this._options = Object.assign({}, DEFAULTS, options); // refactoring modifiers' list

  this._options.modifiers = this._options.modifiers.map(function (modifier) {
    // remove ignored modifiers
    if (this._options.modifiersIgnored.indexOf(modifier) !== -1) return; // set the x-placement attribute before everything else because it could be used to add margins to the popper
    // margins needs to be calculated to get the correct popper offsets

    if (modifier === 'applyStyle') {
      this._popper.setAttribute('x-placement', this._options.placement);
    } // return predefined modifier identified by string or keep the custom one


    return this.modifiers[modifier] || modifier;
  }.bind(this)); // make sure to apply the popper position before any computation

  this.state.position = this._getPosition(this._popper, this._reference);
  setStyle(this._popper, {
    position: this.state.position,
    top: 0
  }); // fire the first update to position the popper in the right place

  this.update(); // setup event listeners, they will take care of update the position in specific situations

  this._setupEventListeners();

  return this;
} //
// Methods
//

/**
 * Destroy the popper
 * @method
 * @memberof Popper
 */

Popper.prototype.destroy = function () {
  this._popper.removeAttribute('x-placement');

  this._popper.style.left = '';
  this._popper.style.position = '';
  this._popper.style.top = '';
  this._popper.style[getSupportedPropertyName('transform')] = '';

  this._removeEventListeners(); // remove the popper if user explicity asked for the deletion on destroy


  if (this._options.removeOnDestroy) {
    this._popper.remove();
  }

  return this;
};
/**
 * Updates the position of the popper, computing the new offsets and applying the new style
 * @method
 * @memberof Popper
 */


Popper.prototype.update = function () {
  var data = {
    instance: this,
    styles: {}
  }; // store placement inside the data object, modifiers will be able to edit `placement` if needed
  // and refer to _originalPlacement to know the original value

  data.placement = this._options.placement;
  data._originalPlacement = this._options.placement; // compute the popper and reference offsets and put them inside data.offsets

  data.offsets = this._getOffsets(this._popper, this._reference, data.placement); // get boundaries

  data.boundaries = this._getBoundaries(data, this._options.boundariesPadding, this._options.boundariesElement);
  data = this.runModifiers(data, this._options.modifiers);

  if (typeof this.state.updateCallback === 'function') {
    this.state.updateCallback(data);
  }
};
/**
 * If a function is passed, it will be executed after the initialization of popper with as first argument the Popper instance.
 * @method
 * @memberof Popper
 * @param {Function} callback
 */


Popper.prototype.onCreate = function (callback) {
  // the createCallbacks return as first argument the popper instance
  callback(this);
  return this;
};
/**
 * If a function is passed, it will be executed after each update of popper with as first argument the set of coordinates and informations
 * used to style popper and its arrow.
 * NOTE: it doesn't get fired on the first call of the `Popper.update()` method inside the `Popper` constructor!
 * @method
 * @memberof Popper
 * @param {Function} callback
 */


Popper.prototype.onUpdate = function (callback) {
  this.state.updateCallback = callback;
  return this;
};
/**
 * Helper used to generate poppers from a configuration file
 * @method
 * @memberof Popper
 * @param config {Object} configuration
 * @returns {HTMLElement} popper
 */


Popper.prototype.parse = function (config) {
  var defaultConfig = {
    tagName: 'div',
    classNames: ['popper'],
    attributes: [],
    parent: root.document.body,
    content: '',
    contentType: 'text',
    arrowTagName: 'div',
    arrowClassNames: ['popper__arrow'],
    arrowAttributes: ['x-arrow']
  };
  config = Object.assign({}, defaultConfig, config);
  var d = root.document;
  var popper = d.createElement(config.tagName);
  addClassNames(popper, config.classNames);
  addAttributes(popper, config.attributes);

  if (config.contentType === 'node') {
    popper.appendChild(config.content.jquery ? config.content[0] : config.content);
  } else if (config.contentType === 'html') {
    popper.innerHTML = config.content;
  } else {
    popper.textContent = config.content;
  }

  if (config.arrowTagName) {
    var arrow = d.createElement(config.arrowTagName);
    addClassNames(arrow, config.arrowClassNames);
    addAttributes(arrow, config.arrowAttributes);
    popper.appendChild(arrow);
  }

  var parent = config.parent.jquery ? config.parent[0] : config.parent; // if the given parent is a string, use it to match an element
  // if more than one element is matched, the first one will be used as parent
  // if no elements are matched, the script will throw an error

  if (typeof parent === 'string') {
    parent = d.querySelectorAll(config.parent);

    if (parent.length > 1) {
      console.warn('WARNING: the given `parent` query(' + config.parent + ') matched more than one element, the first one will be used');
    }

    if (parent.length === 0) {
      throw "ERROR: the given `parent` doesn't exists!";
    }

    parent = parent[0];
  } // if the given parent is a DOM nodes list or an array of nodes with more than one element,
  // the first one will be used as parent


  if (parent.length > 1 && parent instanceof Element === false) {
    console.warn('WARNING: you have passed as parent a list of elements, the first one will be used');
    parent = parent[0];
  } // append the generated popper to its parent


  parent.appendChild(popper);
  return popper;
  /**
   * Adds class names to the given element
   * @function
   * @ignore
   * @param {HTMLElement} target
   * @param {Array} classes
   */

  function addClassNames(element, classNames) {
    classNames.forEach(function (className) {
      element.classList.add(className);
    });
  }
  /**
   * Adds attributes to the given element
   * @function
   * @ignore
   * @param {HTMLElement} target
   * @param {Array} attributes
   * @example
   * addAttributes(element, [ 'data-info:foobar' ]);
   */


  function addAttributes(element, attributes) {
    attributes.forEach(function (attribute) {
      element.setAttribute(attribute.split(':')[0], attribute.split(':')[1] || '');
    });
  }
};
/**
 * Helper used to get the position which will be applied to the popper
 * @method
 * @memberof Popper
 * @param config {HTMLElement} popper element
 * @param reference {HTMLElement} reference element
 * @returns {String} position
 */


Popper.prototype._getPosition = function (popper, reference) {
  var container = getOffsetParent(reference);

  if (this._options.forceAbsolute) {
    return 'absolute';
  } // Decide if the popper will be fixed
  // If the reference element is inside a fixed context, the popper will be fixed as well to allow them to scroll together


  var isParentFixed = isFixed(reference);
  return isParentFixed ? 'fixed' : 'absolute';
};
/**
 * Get offsets to the popper
 * @method
 * @memberof Popper
 * @access private
 * @param {Element} popper - the popper element
 * @param {Element} reference - the reference element (the popper will be relative to this)
 * @returns {Object} An object containing the offsets which will be applied to the popper
 */


Popper.prototype._getOffsets = function (popper, reference, placement) {
  placement = placement.split('-')[0];
  var popperOffsets = {};
  popperOffsets.position = this.state.position;
  var isParentFixed = popperOffsets.position === 'fixed'; //
  // Get reference element position
  //

  var referenceOffsets = getOffsetRectRelativeToCustomParent(reference, getOffsetParent(popper), isParentFixed); //
  // Get popper sizes
  //

  var popperRect = getOuterSizes(popper); //
  // Compute offsets of popper
  //
  // depending by the popper placement we have to compute its offsets slightly differently

  if (['right', 'left'].indexOf(placement) !== -1) {
    popperOffsets.top = referenceOffsets.top + referenceOffsets.height / 2 - popperRect.height / 2;

    if (placement === 'left') {
      popperOffsets.left = referenceOffsets.left - popperRect.width;
    } else {
      popperOffsets.left = referenceOffsets.right;
    }
  } else {
    popperOffsets.left = referenceOffsets.left + referenceOffsets.width / 2 - popperRect.width / 2;

    if (placement === 'top') {
      popperOffsets.top = referenceOffsets.top - popperRect.height;
    } else {
      popperOffsets.top = referenceOffsets.bottom;
    }
  } // Add width and height to our offsets object


  popperOffsets.width = popperRect.width;
  popperOffsets.height = popperRect.height;
  return {
    popper: popperOffsets,
    reference: referenceOffsets
  };
};
/**
 * Setup needed event listeners used to update the popper position
 * @method
 * @memberof Popper
 * @access private
 */


Popper.prototype._setupEventListeners = function () {
  // NOTE: 1 DOM access here
  this.state.updateBound = this.update.bind(this);
  root.addEventListener('resize', this.state.updateBound); // if the boundariesElement is window we don't need to listen for the scroll event

  if (this._options.boundariesElement !== 'window') {
    var target = getScrollParent(this._reference); // here it could be both `body` or `documentElement` thanks to Firefox, we then check both

    if (target === root.document.body || target === root.document.documentElement) {
      target = root;
    }

    target.addEventListener('scroll', this.state.updateBound);
    this.state.scrollTarget = target;
  }
};
/**
 * Remove event listeners used to update the popper position
 * @method
 * @memberof Popper
 * @access private
 */


Popper.prototype._removeEventListeners = function () {
  // NOTE: 1 DOM access here
  root.removeEventListener('resize', this.state.updateBound);

  if (this._options.boundariesElement !== 'window' && this.state.scrollTarget) {
    this.state.scrollTarget.removeEventListener('scroll', this.state.updateBound);
    this.state.scrollTarget = null;
  }

  this.state.updateBound = null;
};
/**
 * Computed the boundaries limits and return them
 * @method
 * @memberof Popper
 * @access private
 * @param {Object} data - Object containing the property "offsets" generated by `_getOffsets`
 * @param {Number} padding - Boundaries padding
 * @param {Element} boundariesElement - Element used to define the boundaries
 * @returns {Object} Coordinates of the boundaries
 */


Popper.prototype._getBoundaries = function (data, padding, boundariesElement) {
  // NOTE: 1 DOM access here
  var boundaries = {};
  var width, height;

  if (boundariesElement === 'window') {
    var body = root.document.body,
        html = root.document.documentElement;
    height = Math.max(body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight);
    width = Math.max(body.scrollWidth, body.offsetWidth, html.clientWidth, html.scrollWidth, html.offsetWidth);
    boundaries = {
      top: 0,
      right: width,
      bottom: height,
      left: 0
    };
  } else if (boundariesElement === 'viewport') {
    var offsetParent = getOffsetParent(this._popper);
    var scrollParent = getScrollParent(this._popper);
    var offsetParentRect = getOffsetRect(offsetParent); // Thanks the fucking native API, `document.body.scrollTop` & `document.documentElement.scrollTop`

    var getScrollTopValue = function (element) {
      return element == document.body ? Math.max(document.documentElement.scrollTop, document.body.scrollTop) : element.scrollTop;
    };

    var getScrollLeftValue = function (element) {
      return element == document.body ? Math.max(document.documentElement.scrollLeft, document.body.scrollLeft) : element.scrollLeft;
    }; // if the popper is fixed we don't have to substract scrolling from the boundaries


    var scrollTop = data.offsets.popper.position === 'fixed' ? 0 : getScrollTopValue(scrollParent);
    var scrollLeft = data.offsets.popper.position === 'fixed' ? 0 : getScrollLeftValue(scrollParent);
    boundaries = {
      top: 0 - (offsetParentRect.top - scrollTop),
      right: root.document.documentElement.clientWidth - (offsetParentRect.left - scrollLeft),
      bottom: root.document.documentElement.clientHeight - (offsetParentRect.top - scrollTop),
      left: 0 - (offsetParentRect.left - scrollLeft)
    };
  } else {
    if (getOffsetParent(this._popper) === boundariesElement) {
      boundaries = {
        top: 0,
        left: 0,
        right: boundariesElement.clientWidth,
        bottom: boundariesElement.clientHeight
      };
    } else {
      boundaries = getOffsetRect(boundariesElement);
    }
  }

  boundaries.left += padding;
  boundaries.right -= padding;
  boundaries.top = boundaries.top + padding;
  boundaries.bottom = boundaries.bottom - padding;
  return boundaries;
};
/**
 * Loop trough the list of modifiers and run them in order, each of them will then edit the data object
 * @method
 * @memberof Popper
 * @access public
 * @param {Object} data
 * @param {Array} modifiers
 * @param {Function} ends
 */


Popper.prototype.runModifiers = function (data, modifiers, ends) {
  var modifiersToRun = modifiers.slice();

  if (ends !== undefined) {
    modifiersToRun = this._options.modifiers.slice(0, getArrayKeyIndex(this._options.modifiers, ends));
  }

  modifiersToRun.forEach(function (modifier) {
    if (isFunction$1(modifier)) {
      data = modifier.call(this, data);
    }
  }.bind(this));
  return data;
};
/**
 * Helper used to know if the given modifier depends from another one.
 * @method
 * @memberof Popper
 * @param {String} requesting - name of requesting modifier
 * @param {String} requested - name of requested modifier
 * @returns {Boolean}
 */


Popper.prototype.isModifierRequired = function (requesting, requested) {
  var index = getArrayKeyIndex(this._options.modifiers, requesting);
  return !!this._options.modifiers.slice(0, index).filter(function (modifier) {
    return modifier === requested;
  }).length;
}; //
// Modifiers
//

/**
 * Modifiers list
 * @namespace Popper.modifiers
 * @memberof Popper
 * @type {Object}
 */


Popper.prototype.modifiers = {};
/**
 * Apply the computed styles to the popper element
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @returns {Object} The same data object
 */

Popper.prototype.modifiers.applyStyle = function (data) {
  // apply the final offsets to the popper
  // NOTE: 1 DOM access here
  var styles = {
    position: data.offsets.popper.position
  }; // round top and left to avoid blurry text

  var left = Math.round(data.offsets.popper.left);
  var top = Math.round(data.offsets.popper.top); // if gpuAcceleration is set to true and transform is supported, we use `translate3d` to apply the position to the popper
  // we automatically use the supported prefixed version if needed

  var prefixedProperty;

  if (this._options.gpuAcceleration && (prefixedProperty = getSupportedPropertyName('transform'))) {
    styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
    styles.top = 0;
    styles.left = 0;
  } // othwerise, we use the standard `left` and `top` properties
  else {
      styles.left = left;
      styles.top = top;
    } // any property present in `data.styles` will be applied to the popper,
  // in this way we can make the 3rd party modifiers add custom styles to it
  // Be aware, modifiers could override the properties defined in the previous
  // lines of this modifier!


  Object.assign(styles, data.styles);
  setStyle(this._popper, styles); // set an attribute which will be useful to style the tooltip (use it to properly position its arrow)
  // NOTE: 1 DOM access here

  this._popper.setAttribute('x-placement', data.placement); // if the arrow modifier is required and the arrow style has been computed, apply the arrow style


  if (this.isModifierRequired(this.modifiers.applyStyle, this.modifiers.arrow) && data.offsets.arrow) {
    setStyle(data.arrowElement, data.offsets.arrow);
  }

  return data;
};
/**
 * Modifier used to shift the popper on the start or end of its reference element side
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @returns {Object} The data object, properly modified
 */


Popper.prototype.modifiers.shift = function (data) {
  var placement = data.placement;
  var basePlacement = placement.split('-')[0];
  var shiftVariation = placement.split('-')[1]; // if shift shiftVariation is specified, run the modifier

  if (shiftVariation) {
    var reference = data.offsets.reference;
    var popper = getPopperClientRect(data.offsets.popper);
    var shiftOffsets = {
      y: {
        start: {
          top: reference.top
        },
        end: {
          top: reference.top + reference.height - popper.height
        }
      },
      x: {
        start: {
          left: reference.left
        },
        end: {
          left: reference.left + reference.width - popper.width
        }
      }
    };
    var axis = ['bottom', 'top'].indexOf(basePlacement) !== -1 ? 'x' : 'y';
    data.offsets.popper = Object.assign(popper, shiftOffsets[axis][shiftVariation]);
  }

  return data;
};
/**
 * Modifier used to make sure the popper does not overflows from it's boundaries
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by `update` method
 * @returns {Object} The data object, properly modified
 */


Popper.prototype.modifiers.preventOverflow = function (data) {
  var order = this._options.preventOverflowOrder;
  var popper = getPopperClientRect(data.offsets.popper);
  var check = {
    left: function () {
      var left = popper.left;

      if (popper.left < data.boundaries.left) {
        left = Math.max(popper.left, data.boundaries.left);
      }

      return {
        left: left
      };
    },
    right: function () {
      var left = popper.left;

      if (popper.right > data.boundaries.right) {
        left = Math.min(popper.left, data.boundaries.right - popper.width);
      }

      return {
        left: left
      };
    },
    top: function () {
      var top = popper.top;

      if (popper.top < data.boundaries.top) {
        top = Math.max(popper.top, data.boundaries.top);
      }

      return {
        top: top
      };
    },
    bottom: function () {
      var top = popper.top;

      if (popper.bottom > data.boundaries.bottom) {
        top = Math.min(popper.top, data.boundaries.bottom - popper.height);
      }

      return {
        top: top
      };
    }
  };
  order.forEach(function (direction) {
    data.offsets.popper = Object.assign(popper, check[direction]());
  });
  return data;
};
/**
 * Modifier used to make sure the popper is always near its reference
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */


Popper.prototype.modifiers.keepTogether = function (data) {
  var popper = getPopperClientRect(data.offsets.popper);
  var reference = data.offsets.reference;
  var f = Math.floor;

  if (popper.right < f(reference.left)) {
    data.offsets.popper.left = f(reference.left) - popper.width;
  }

  if (popper.left > f(reference.right)) {
    data.offsets.popper.left = f(reference.right);
  }

  if (popper.bottom < f(reference.top)) {
    data.offsets.popper.top = f(reference.top) - popper.height;
  }

  if (popper.top > f(reference.bottom)) {
    data.offsets.popper.top = f(reference.bottom);
  }

  return data;
};
/**
 * Modifier used to flip the placement of the popper when the latter is starting overlapping its reference element.
 * Requires the `preventOverflow` modifier before it in order to work.
 * **NOTE:** This modifier will run all its previous modifiers everytime it tries to flip the popper!
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */


Popper.prototype.modifiers.flip = function (data) {
  // check if preventOverflow is in the list of modifiers before the flip modifier.
  // otherwise flip would not work as expected.
  if (!this.isModifierRequired(this.modifiers.flip, this.modifiers.preventOverflow)) {
    console.warn('WARNING: preventOverflow modifier is required by flip modifier in order to work, be sure to include it before flip!');
    return data;
  }

  if (data.flipped && data.placement === data._originalPlacement) {
    // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
    return data;
  }

  var placement = data.placement.split('-')[0];
  var placementOpposite = getOppositePlacement(placement);
  var variation = data.placement.split('-')[1] || '';
  var flipOrder = [];

  if (this._options.flipBehavior === 'flip') {
    flipOrder = [placement, placementOpposite];
  } else {
    flipOrder = this._options.flipBehavior;
  }

  flipOrder.forEach(function (step, index) {
    if (placement !== step || flipOrder.length === index + 1) {
      return;
    }

    placement = data.placement.split('-')[0];
    placementOpposite = getOppositePlacement(placement);
    var popperOffsets = getPopperClientRect(data.offsets.popper); // this boolean is used to distinguish right and bottom from top and left
    // they need different computations to get flipped

    var a = ['right', 'bottom'].indexOf(placement) !== -1; // using Math.floor because the reference offsets may contain decimals we are not going to consider here

    if (a && Math.floor(data.offsets.reference[placement]) > Math.floor(popperOffsets[placementOpposite]) || !a && Math.floor(data.offsets.reference[placement]) < Math.floor(popperOffsets[placementOpposite])) {
      // we'll use this boolean to detect any flip loop
      data.flipped = true;
      data.placement = flipOrder[index + 1];

      if (variation) {
        data.placement += '-' + variation;
      }

      data.offsets.popper = this._getOffsets(this._popper, this._reference, data.placement).popper;
      data = this.runModifiers(data, this._options.modifiers, this._flip);
    }
  }.bind(this));
  return data;
};
/**
 * Modifier used to add an offset to the popper, useful if you more granularity positioning your popper.
 * The offsets will shift the popper on the side of its reference element.
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */


Popper.prototype.modifiers.offset = function (data) {
  var offset = this._options.offset;
  var popper = data.offsets.popper;

  if (data.placement.indexOf('left') !== -1) {
    popper.top -= offset;
  } else if (data.placement.indexOf('right') !== -1) {
    popper.top += offset;
  } else if (data.placement.indexOf('top') !== -1) {
    popper.left -= offset;
  } else if (data.placement.indexOf('bottom') !== -1) {
    popper.left += offset;
  }

  return data;
};
/**
 * Modifier used to move the arrows on the edge of the popper to make sure them are always between the popper and the reference element
 * It will use the CSS outer size of the arrow element to know how many pixels of conjuction are needed
 * @method
 * @memberof Popper.modifiers
 * @argument {Object} data - The data object generated by _update method
 * @returns {Object} The data object, properly modified
 */


Popper.prototype.modifiers.arrow = function (data) {
  var arrow = this._options.arrowElement;
  var arrowOffset = this._options.arrowOffset; // if the arrowElement is a string, suppose it's a CSS selector

  if (typeof arrow === 'string') {
    arrow = this._popper.querySelector(arrow);
  } // if arrow element is not found, don't run the modifier


  if (!arrow) {
    return data;
  } // the arrow element must be child of its popper


  if (!this._popper.contains(arrow)) {
    console.warn('WARNING: `arrowElement` must be child of its popper element!');
    return data;
  } // arrow depends on keepTogether in order to work


  if (!this.isModifierRequired(this.modifiers.arrow, this.modifiers.keepTogether)) {
    console.warn('WARNING: keepTogether modifier is required by arrow modifier in order to work, be sure to include it before arrow!');
    return data;
  }

  var arrowStyle = {};
  var placement = data.placement.split('-')[0];
  var popper = getPopperClientRect(data.offsets.popper);
  var reference = data.offsets.reference;
  var isVertical = ['left', 'right'].indexOf(placement) !== -1;
  var len = isVertical ? 'height' : 'width';
  var side = isVertical ? 'top' : 'left';
  var altSide = isVertical ? 'left' : 'top';
  var opSide = isVertical ? 'bottom' : 'right';
  var arrowSize = getOuterSizes(arrow)[len]; //
  // extends keepTogether behavior making sure the popper and its reference have enough pixels in conjuction
  //
  // top/left side

  if (reference[opSide] - arrowSize < popper[side]) {
    data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowSize);
  } // bottom/right side


  if (reference[side] + arrowSize > popper[opSide]) {
    data.offsets.popper[side] += reference[side] + arrowSize - popper[opSide];
  } // compute center of the popper


  var center = reference[side] + (arrowOffset || reference[len] / 2 - arrowSize / 2);
  var sideValue = center - popper[side]; // prevent arrow from being placed not contiguously to its popper

  sideValue = Math.max(Math.min(popper[len] - arrowSize - 8, sideValue), 8);
  arrowStyle[side] = sideValue;
  arrowStyle[altSide] = ''; // make sure to remove any old style from the arrow

  data.offsets.arrow = arrowStyle;
  data.arrowElement = arrow;
  return data;
}; //
// Helpers
//

/**
 * Get the outer sizes of the given element (offset size + margins)
 * @function
 * @ignore
 * @argument {Element} element
 * @returns {Object} object containing width and height properties
 */


function getOuterSizes(element) {
  // NOTE: 1 DOM access here
  var _display = element.style.display,
      _visibility = element.style.visibility;
  element.style.display = 'block';
  element.style.visibility = 'hidden';
  var calcWidthToForceRepaint = element.offsetWidth; // original method

  var styles = root.getComputedStyle(element);
  var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
  var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
  var result = {
    width: element.offsetWidth + y,
    height: element.offsetHeight + x
  }; // reset element styles

  element.style.display = _display;
  element.style.visibility = _visibility;
  return result;
}
/**
 * Get the opposite placement of the given one/
 * @function
 * @ignore
 * @argument {String} placement
 * @returns {String} flipped placement
 */


function getOppositePlacement(placement) {
  var hash = {
    left: 'right',
    right: 'left',
    bottom: 'top',
    top: 'bottom'
  };
  return placement.replace(/left|right|bottom|top/g, function (matched) {
    return hash[matched];
  });
}
/**
 * Given the popper offsets, generate an output similar to getBoundingClientRect
 * @function
 * @ignore
 * @argument {Object} popperOffsets
 * @returns {Object} ClientRect like output
 */


function getPopperClientRect(popperOffsets) {
  var offsets = Object.assign({}, popperOffsets);
  offsets.right = offsets.left + offsets.width;
  offsets.bottom = offsets.top + offsets.height;
  return offsets;
}
/**
 * Given an array and the key to find, returns its index
 * @function
 * @ignore
 * @argument {Array} arr
 * @argument keyToFind
 * @returns index or null
 */


function getArrayKeyIndex(arr, keyToFind) {
  var i = 0,
      key;

  for (key in arr) {
    if (arr[key] === keyToFind) {
      return i;
    }

    i++;
  }

  return null;
}
/**
 * Get CSS computed property of the given element
 * @function
 * @ignore
 * @argument {Eement} element
 * @argument {String} property
 */


function getStyleComputedProperty(element, property) {
  // NOTE: 1 DOM access here
  var css = root.getComputedStyle(element, null);
  return css[property];
}
/**
 * Returns the offset parent of the given element
 * @function
 * @ignore
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getOffsetParent(element) {
  // NOTE: 1 DOM access here
  var offsetParent = element.offsetParent;
  return offsetParent === root.document.body || !offsetParent ? root.document.documentElement : offsetParent;
}
/**
 * Returns the scrolling parent of the given element
 * @function
 * @ignore
 * @argument {Element} element
 * @returns {Element} offset parent
 */


function getScrollParent(element) {
  var parent = element.parentNode;

  if (!parent) {
    return element;
  }

  if (parent === root.document) {
    // Firefox puts the scrollTOp value on `documentElement` instead of `body`, we then check which of them is
    // greater than 0 and return the proper element
    if (root.document.body.scrollTop || root.document.body.scrollLeft) {
      return root.document.body;
    } else {
      return root.document.documentElement;
    }
  } // Firefox want us to check `-x` and `-y` variations as well


  if (['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-x')) !== -1 || ['scroll', 'auto'].indexOf(getStyleComputedProperty(parent, 'overflow-y')) !== -1) {
    // If the detected scrollParent is body, we perform an additional check on its parentNode
    // in this way we'll get body if the browser is Chrome-ish, or documentElement otherwise
    // fixes issue #65
    return parent;
  }

  return getScrollParent(element.parentNode);
}
/**
 * Check if the given element is fixed or is inside a fixed parent
 * @function
 * @ignore
 * @argument {Element} element
 * @argument {Element} customContainer
 * @returns {Boolean} answer to "isFixed?"
 */


function isFixed(element) {
  if (element === root.document.body) {
    return false;
  }

  if (getStyleComputedProperty(element, 'position') === 'fixed') {
    return true;
  }

  return element.parentNode ? isFixed(element.parentNode) : element;
}
/**
 * Set the style to the given popper
 * @function
 * @ignore
 * @argument {Element} element - Element to apply the style to
 * @argument {Object} styles - Object with a list of properties and values which will be applied to the element
 */


function setStyle(element, styles) {
  function is_numeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }

  Object.keys(styles).forEach(function (prop) {
    var unit = ''; // add unit if the value is numeric and is one of the following

    if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && is_numeric(styles[prop])) {
      unit = 'px';
    }

    element.style[prop] = styles[prop] + unit;
  });
}
/**
 * Check if the given variable is a function
 * @function
 * @ignore
 * @argument {*} functionToCheck - variable to check
 * @returns {Boolean} answer to: is a function?
 */


function isFunction$1(functionToCheck) {
  var getType = {};
  return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
}
/**
 * Get the position of the given element, relative to its offset parent
 * @function
 * @ignore
 * @param {Element} element
 * @return {Object} position - Coordinates of the element and its `scrollTop`
 */


function getOffsetRect(element) {
  var elementRect = {
    width: element.offsetWidth,
    height: element.offsetHeight,
    left: element.offsetLeft,
    top: element.offsetTop
  };
  elementRect.right = elementRect.left + elementRect.width;
  elementRect.bottom = elementRect.top + elementRect.height; // position

  return elementRect;
}
/**
 * Get bounding client rect of given element
 * @function
 * @ignore
 * @param {HTMLElement} element
 * @return {Object} client rect
 */


function getBoundingClientRect(element) {
  var rect = element.getBoundingClientRect(); // whether the IE version is lower than 11

  var isIE = navigator.userAgent.indexOf('MSIE') != -1; // fix ie document bounding top always 0 bug

  var rectTop = isIE && element.tagName === 'HTML' ? -element.scrollTop : rect.top;
  return {
    left: rect.left,
    top: rectTop,
    right: rect.right,
    bottom: rect.bottom,
    width: rect.right - rect.left,
    height: rect.bottom - rectTop
  };
}
/**
 * Given an element and one of its parents, return the offset
 * @function
 * @ignore
 * @param {HTMLElement} element
 * @param {HTMLElement} parent
 * @return {Object} rect
 */


function getOffsetRectRelativeToCustomParent(element, parent, fixed) {
  var elementRect = getBoundingClientRect(element);
  var parentRect = getBoundingClientRect(parent);

  if (fixed) {
    var scrollParent = getScrollParent(parent);
    parentRect.top += scrollParent.scrollTop;
    parentRect.bottom += scrollParent.scrollTop;
    parentRect.left += scrollParent.scrollLeft;
    parentRect.right += scrollParent.scrollLeft;
  }

  var rect = {
    top: elementRect.top - parentRect.top,
    left: elementRect.left - parentRect.left,
    bottom: elementRect.top - parentRect.top + elementRect.height,
    right: elementRect.left - parentRect.left + elementRect.width,
    width: elementRect.width,
    height: elementRect.height
  };
  return rect;
}
/**
 * Get the prefixed supported property name
 * @function
 * @ignore
 * @argument {String} property (camelCase)
 * @returns {String} prefixed property (camelCase)
 */


function getSupportedPropertyName(property) {
  var prefixes = ['', 'ms', 'webkit', 'moz', 'o'];

  for (var i = 0; i < prefixes.length; i++) {
    var toCheck = prefixes[i] ? prefixes[i] + property.charAt(0).toUpperCase() + property.slice(1) : property;

    if (typeof root.document.body.style[toCheck] !== 'undefined') {
      return toCheck;
    }
  }

  return null;
}
/**
 * The Object.assign() method is used to copy the values of all enumerable own properties from one or more source
 * objects to a target object. It will return the target object.
 * This polyfill doesn't support symbol properties, since ES5 doesn't have symbols anyway
 * Source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
 * @function
 * @ignore
 */


if (!Object.assign) {
  Object.defineProperty(Object, 'assign', {
    enumerable: false,
    configurable: true,
    writable: true,
    value: function (target) {
      if (target === undefined || target === null) {
        throw new TypeError('Cannot convert first argument to object');
      }

      var to = Object(target);

      for (var i = 1; i < arguments.length; i++) {
        var nextSource = arguments[i];

        if (nextSource === undefined || nextSource === null) {
          continue;
        }

        nextSource = Object(nextSource);
        var keysArray = Object.keys(nextSource);

        for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
          var nextKey = keysArray[nextIndex];
          var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

          if (desc !== undefined && desc.enumerable) {
            to[nextKey] = nextSource[nextKey];
          }
        }
      }

      return to;
    }
  });
}

const stop = e => e.stopPropagation();

const popperProps = {
  transformOrigin: {
    type: [Boolean, String],
    default: true
  },
  placement: {
    type: String,
    default: 'bottom'
  },
  boundariesPadding: {
    type: Number,
    default: 5
  },
  reference: {},
  popper: {},
  offset: {
    default: 0
  },
  modelValue: Boolean,
  visibleArrow: Boolean,
  arrowOffset: {
    type: Number,
    default: 35
  },
  appendToBody: {
    type: Boolean,
    default: true
  },
  popperOptions: {
    type: Object,

    default() {
      return {
        gpuAcceleration: false
      };
    }

  },
  disabled: {
    type: Boolean,
    default: false
  }
};

function usePopper(props, {
  emit,
  slots
}, {
  referenceElm,
  popperElm
}) {
  const {
    transformOrigin,
    placement,
    reference,
    popper,
    offset,
    modelValue,
    visibleArrow,
    arrowOffset,
    appendToBody,
    popperOptions,
    disabled
  } = toRefs(props);
  const showPopper = ref(false);
  const currentPlacement = ref('');
  const popperJS = ref(null);
  const instance = getCurrentInstance();

  function createPopper() {
    if (instance.proxy.$isServer) return;
    currentPlacement.value = currentPlacement.value || placement.value;

    if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(currentPlacement.value)) {
      return;
    }

    const options = popperOptions.value;
    const popperRef = popperElm.value = popperElm.value || popper && popper.value || instance.proxy.$refs.popper;
    let referenceRef = referenceElm.value = referenceElm.value || reference && reference.value || instance.proxy.$refs.reference;

    if (!referenceRef && slots.reference && slots.reference() && slots.reference()[0]) {
      referenceRef = referenceElm.value = slots.reference()[0].el;
    }

    if (!popperRef || !referenceRef) return;
    if (visibleArrow.value) appendArrow(popperRef);
    if (appendToBody.value) document.body.appendChild(popperElm.value);

    if (popperJS.value && popperJS.value.destroy) {
      popperJS.value.destroy();
    }

    options.placement = currentPlacement.value;
    options.offset = offset.value;
    options.arrowOffset = arrowOffset.value;
    popperJS.value = new Popper(referenceRef, popperRef, options);
    popperJS.value.onCreate(() => {
      emit('created', instance.proxy);
      resetTransformOrigin();
      nextTick(() => updatePopper());
    });

    if (typeof options.onUpdate === 'function') {
      popperJS.value.onUpdate(options.onUpdate);
    }

    popperJS.value._popper.style.zIndex = PopupManager.nextZIndex();
    popperElm.value.addEventListener('click', stop);
  }

  function updatePopper() {
    const popperJSRef = popperJS.value;

    if (popperJSRef) {
      popperJSRef.update();

      if (popperJSRef._popper) {
        popperJSRef._popper.style.zIndex = PopupManager.nextZIndex();
      }
    } else {
      createPopper();
    }
  }

  function doDestroy(forceDestroy) {
    /* istanbul ignore if */
    if (!popperJS.value || showPopper.value && !forceDestroy) return;
    popperJS.value.destroy();
    popperJS.value = null;
  }

  function destroyPopper() {
    if (popperJS.value) {
      resetTransformOrigin();
    }
  }

  function resetTransformOrigin() {
    if (!transformOrigin.value) return;
    const placementMap = {
      top: 'bottom',
      bottom: 'top',
      left: 'right',
      right: 'left'
    };

    const placement = popperJS.value._popper.getAttribute('x-placement').split('-')[0];

    const origin = placementMap[placement];
    popperJS.value._popper.style.transformOrigin = typeof transformOrigin.value === 'string' ? transformOrigin.value : ['top', 'bottom'].indexOf(placement) > -1 ? `center ${origin}` : `${origin} center`;
  }

  const appended = ref(false);

  function appendArrow(element) {
    let hash;

    if (appended.value) {
      return;
    }

    appended.value = true;

    for (const item in element.attributes) {
      if (/^_v-/.test(element.attributes[item].name)) {
        hash = element.attributes[item].name;
        break;
      }
    }

    const arrow = document.createElement('div');

    if (hash) {
      arrow.setAttribute(hash, '');
    }

    arrow.setAttribute('x-arrow', '');
    arrow.className = 'popper__arrow';
    element.appendChild(arrow);
  }

  watch(modelValue, val => {
    showPopper.value = val;
    emit('update:modelValue', val);
  }, {
    immediate: true
  });
  watch(showPopper, val => {
    if (disabled.value) return;
    val ? updatePopper() : destroyPopper();
    emit('update:modelValue', val);
  });
  onBeforeUnmount(() => {
    doDestroy(true);

    if (popperElm.value && popperElm.value.parentNode === document.body) {
      popperElm.value.removeEventListener('click', stop);
      document.body.removeChild(popperElm.value);
    }
  });
  return {
    showPopper,
    currentPlacement,
    referenceElm,
    popperElm,
    popperJS,
    createPopper,
    updatePopper,
    doDestroy,
    destroyPopper,
    resetTransformOrigin,
    appendArrow
  };
}

var script$i = {
  name: 'ElSelectDropdown',
  componentName: 'ElSelectDropdown',
  props: { ...popperProps,
    placement: {
      default: 'bottom-start'
    },
    boundariesPadding: {
      default: 0
    },
    popperOptions: {
      default() {
        return {
          gpuAcceleration: false
        };
      }

    },
    visibleArrow: {
      default: true
    },
    appendToBody: {
      type: Boolean,
      default: true
    }
  },
  emits: ['update:blur', 'update:modelValue', 'created'],

  setup(props, ctx) {
    const elSelect = inject('select');
    const elms = usePopperElm(elSelect);
    const popper = usePopper(props, ctx, elms);
    usePopperUpdate(() => {
      if (elSelect.visible) {
        popper.updatePopper();
      }
    }, popper.destroyPopper);
    const popperClass = computed(() => {
      return elSelect.popperClass;
    });
    const minWidth = useMinWidth(elSelect);
    return {
      elSelect,
      minWidth,
      popperClass,
      ...popper
    };
  }

};

function usePopperElm(elSelect) {
  const {
    ctx
  } = getCurrentInstance();
  const elms = reactive({
    referenceElm: null,
    popperElm: null
  });
  onMounted(() => {
    elms.referenceElm = elSelect.$refs.reference.$el;
    elSelect.popperElm = elms.popperElm = ctx.$el;
  });
  return { ...toRefs(elms)
  };
}

function usePopperUpdate(updateFn, destroyFn) {
  const {
    on
  } = useEmitter();
  onMounted(() => {
    on('updatePopper', updateFn);
    on('destroyPopper', destroyFn);
  });
}

function useMinWidth(elSelect) {
  const minWidth = ref('');
  watch(() => elSelect.inputWidth, () => {
    minWidth.value = elSelect.$el.getBoundingClientRect().width + 'px';
  });
  return minWidth;
}

function render$h(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-select-dropdown el-popper", [{ 'is-multiple': $setup.elSelect.multiple }, $setup.popperClass]],
    style: { minWidth: $setup.minWidth }
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6 /* CLASS, STYLE */))
}

script$i.render = render$h;
script$i.__file = "packages/select/SelectDropdown.vue";

var script$j = {
  name: 'ElOption',
  componentName: 'ElOption',
  props: {
    value: {
      required: true
    },
    label: [String, Number],
    created: Boolean,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  setup(props) {
    const {
      on,
      dispatch
    } = useEmitter();
    const select = inject('select');
    const {
      proxy
    } = getCurrentInstance();
    const {
      value,
      label,
      disabled,
      created
    } = toRefs(props);
    const data = reactive({
      index: -1,
      groupDisabled: false,
      visible: true,
      hitState: false,
      hover: false
    });
    const isObject = computed(() => {
      const v = unref(value);
      return Object.prototype.toString.call(v).toLowerCase() === '[object object]';
    });
    const currentLabel = computed(() => {
      return unref(label) || (unref(isObject) ? '' : unref(value));
    });
    const currentValue = computed(() => {
      return unref(value) || label.value || '';
    });
    const itemSelected = computed(() => {
      if (!select.multiple) {
        return isEqual(unref(value), select.modelValue);
      } else {
        return contains(select.modelValue, unref(value));
      }
    });
    const limitReached = computed(() => {
      if (select.multiple) {
        return !unref(itemSelected) && (select.modelValue || []).length >= select.multipleLimit && select.multipleLimit > 0;
      } else {
        return false;
      }
    });

    function isEqual(a, b) {
      if (!unref(isObject)) {
        return a === b;
      } else {
        const valueKey = select.valueKey;
        return getValueByPath(a, valueKey) === getValueByPath(b, valueKey);
      }
    }

    function contains(arr = [], target) {
      if (!unref(isObject)) {
        return arr && arr.indexOf(target) > -1;
      } else {
        const valueKey = select.valueKey;
        return arr && arr.some(item => {
          return getValueByPath(item, valueKey) === getValueByPath(target, valueKey);
        });
      }
    }

    function handleGroupDisabled(val) {
      data.groupDisabled = val;
    }

    function hoverItem() {
      if (!disabled.value && !data.groupDisabled) {
        select.hoverIndex = select.options.indexOf(proxy);
      }
    }

    function selectOptionClick() {
      if (disabled.value !== true && data.groupDisabled !== true) {
        dispatch('handleOptionClick', {
          option: this,
          byClick: true
        });
      }
    }

    function queryChange(query) {
      data.visible = new RegExp(escapeRegexpString(query), 'i').test(unref(currentLabel)) || created.value;

      if (!data.visible) {
        select.filteredOptionsCount--;
      }
    }

    watch(currentLabel, () => {
      if (!created.value && !select.remote) dispatch('setSelected');
    });
    watch(value, (val, oldVal) => {
      const {
        remote,
        valueKey
      } = select;

      if (!created.value && !remote) {
        if (valueKey && typeof val === 'object' && typeof oldVal === 'object' && val[valueKey] === oldVal[valueKey]) {
          return;
        }

        dispatch('setSelected');
      }
    });
    onBeforeMount(() => {
      select.options.push(proxy);
      select.cachedOptions.push(proxy);
      select.optionsCount++;
      select.filteredOptionsCount++;
      on('queryChange', queryChange);
      on('handleGroupDisabled', handleGroupDisabled);
    });
    onBeforeUnmount(() => {
      const {
        selected,
        multiple
      } = select;
      const selectedOptions = multiple ? selected : [selected];
      const index = select.cachedOptions.indexOf(proxy);
      const selectedIndex = selectedOptions.indexOf(proxy); // if option is not selected, remove it from cache

      if (index > -1 && selectedIndex < 0) {
        select.cachedOptions.splice(index, 1);
      }

      select.onOptionDestroy(select.options.indexOf(proxy));
    });
    return { ...toRefs(data),
      selectOptionClick,
      itemSelected,
      limitReached,
      currentLabel,
      currentValue,
      hoverItem
    };
  }

};

function render$i(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createBlock("li", {
    onMouseenter: _cache[1] || (_cache[1] = (...args) => ($setup.hoverItem(...args))),
    onClick: _cache[2] || (_cache[2] = withModifiers((...args) => ($setup.selectOptionClick(...args)), ["stop"])),
    class: ["el-select-dropdown__item", {
      selected: $setup.itemSelected,
      'is-disabled': $props.disabled || _ctx.groupDisabled || $setup.limitReached,
      hover: _ctx.hover
    }]
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode("span", null, toDisplayString($setup.currentLabel), 1 /* TEXT */)
    ])
  ], 34 /* CLASS, HYDRATE_EVENTS */)), [
    [vShow, _ctx.visible]
  ])
}

script$j.render = render$i;
script$j.__file = "packages/option/Option.vue";

var script$k = {
  name: 'ElTag',
  props: {
    text: String,
    closable: Boolean,
    type: String,
    hit: Boolean,
    disableTransitions: Boolean,
    color: String,
    size: String,
    effect: {
      type: String,
      default: 'light',

      validator(val) {
        return ['dark', 'light', 'plain'].indexOf(val) !== -1;
      }

    }
  },
  emits: ['close', 'click'],

  setup(props, {
    emit,
    slots
  }) {
    const state = reactive({
      show: true
    });
    const tagSize = computed(() => {
      return props.size || (getCurrentInstance().proxy.$ELEMENT || {}).size;
    });

    const handleClose = event => {
      event.stopPropagation();
      state.show = false;
      emit('close', event);
    };

    const handleClick = event => {
      emit('click', event);
    };

    return () => {
      const classes = ['el-tag', props.type ? `el-tag--${props.type}` : '', tagSize.value ? `el-tag--${tagSize.value}` : '', props.effect ? `el-tag--${props.effect}` : '', props.hit && 'is-hit'];
      const tagEl = createVNode("span", {
        "class": classes,
        "style": {
          backgroundColor: props.color
        },
        "onClick": handleClick
      }, [slots.default && slots.default(), props.closable && createVNode("i", {
        "class": "el-tag__close el-icon-close",
        "onClick": handleClose
      }, null)]);
      return props.disableTransitions ? tagEl : createVNode(Transition, {
        "appear": true,
        "name": "el-zoom-in-center"
      }, {
        default: () => [state.show === true ? tagEl : '']
      });
    };
  }

};

script$k.__file = "packages/tag/Tag.vue";

/* istanbul ignore next */

script$k.install = function (app) {
  app.component(script$k.name, script$k);
};

/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */

/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = function () {
  if (typeof Map !== 'undefined') {
    return Map;
  }
  /**
   * Returns index in provided array that matches the specified key.
   *
   * @param {Array<Array>} arr
   * @param {*} key
   * @returns {number}
   */


  function getIndex(arr, key) {
    var result = -1;
    arr.some(function (entry, index) {
      if (entry[0] === key) {
        result = index;
        return true;
      }

      return false;
    });
    return result;
  }

  return (
    /** @class */
    function () {
      function class_1() {
        this.__entries__ = [];
      }

      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function () {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      /**
       * @param {*} key
       * @returns {*}
       */

      class_1.prototype.get = function (key) {
        var index = getIndex(this.__entries__, key);
        var entry = this.__entries__[index];
        return entry && entry[1];
      };
      /**
       * @param {*} key
       * @param {*} value
       * @returns {void}
       */


      class_1.prototype.set = function (key, value) {
        var index = getIndex(this.__entries__, key);

        if (~index) {
          this.__entries__[index][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.delete = function (key) {
        var entries = this.__entries__;
        var index = getIndex(entries, key);

        if (~index) {
          entries.splice(index, 1);
        }
      };
      /**
       * @param {*} key
       * @returns {void}
       */


      class_1.prototype.has = function (key) {
        return !!~getIndex(this.__entries__, key);
      };
      /**
       * @returns {void}
       */


      class_1.prototype.clear = function () {
        this.__entries__.splice(0);
      };
      /**
       * @param {Function} callback
       * @param {*} [ctx=null]
       * @returns {void}
       */


      class_1.prototype.forEach = function (callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }

        for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
          var entry = _a[_i];
          callback.call(ctx, entry[1], entry[0]);
        }
      };

      return class_1;
    }()
  );
}();
/**
 * Detects whether window and document objects are available in current environment.
 */


var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document; // Returns global object of a current environment.

var global$1 = function () {
  if (typeof global !== 'undefined' && global.Math === Math) {
    return global;
  }

  if (typeof self !== 'undefined' && self.Math === Math) {
    return self;
  }

  if (typeof window !== 'undefined' && window.Math === Math) {
    return window;
  } // eslint-disable-next-line no-new-func


  return Function('return this')();
}();
/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */


var requestAnimationFrame$1 = function () {
  if (typeof requestAnimationFrame === 'function') {
    // It's required to use a bounded function because IE sometimes throws
    // an "Invalid calling object" error if rAF is invoked without the global
    // object on the left hand side.
    return requestAnimationFrame.bind(global$1);
  }

  return function (callback) {
    return setTimeout(function () {
      return callback(Date.now());
    }, 1000 / 60);
  };
}(); // Defines minimum timeout before adding a trailing call.


var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */

function throttle(callback, delay) {
  var leadingCall = false,
      trailingCall = false,
      lastCallTime = 0;
  /**
   * Invokes the original callback function and schedules new invocation if
   * the "proxy" was called during current request.
   *
   * @returns {void}
   */

  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }

    if (trailingCall) {
      proxy();
    }
  }
  /**
   * Callback invoked after the specified delay. It will further postpone
   * invocation of the original function delegating it to the
   * requestAnimationFrame.
   *
   * @returns {void}
   */


  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  /**
   * Schedules invocation of the original function.
   *
   * @returns {void}
   */


  function proxy() {
    var timeStamp = Date.now();

    if (leadingCall) {
      // Reject immediately following calls.
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      } // Schedule new call to be in invoked when the pending one is resolved.
      // This is important for "transitions" which never actually start
      // immediately so there is a chance that we might miss one if change
      // happens amids the pending invocation.


      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay);
    }

    lastCallTime = timeStamp;
  }

  return proxy;
} // Minimum delay before invoking the update of observers.


var REFRESH_DELAY = 20; // A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.

var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight']; // Check if MutationObserver is available.

var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */

var ResizeObserverController =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserverController.
   *
   * @private
   */
  function ResizeObserverController() {
    /**
     * Indicates whether DOM listeners have been added.
     *
     * @private {boolean}
     */
    this.connected_ = false;
    /**
     * Tells that controller has subscribed for Mutation Events.
     *
     * @private {boolean}
     */

    this.mutationEventsAdded_ = false;
    /**
     * Keeps reference to the instance of MutationObserver.
     *
     * @private {MutationObserver}
     */

    this.mutationsObserver_ = null;
    /**
     * A list of connected observers.
     *
     * @private {Array<ResizeObserverSPI>}
     */

    this.observers_ = [];
    this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
    this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
  }
  /**
   * Adds observer to observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be added.
   * @returns {void}
   */


  ResizeObserverController.prototype.addObserver = function (observer) {
    if (!~this.observers_.indexOf(observer)) {
      this.observers_.push(observer);
    } // Add listeners if they haven't been added yet.


    if (!this.connected_) {
      this.connect_();
    }
  };
  /**
   * Removes observer from observers list.
   *
   * @param {ResizeObserverSPI} observer - Observer to be removed.
   * @returns {void}
   */


  ResizeObserverController.prototype.removeObserver = function (observer) {
    var observers = this.observers_;
    var index = observers.indexOf(observer); // Remove observer if it's present in registry.

    if (~index) {
      observers.splice(index, 1);
    } // Remove listeners if controller has no connected observers.


    if (!observers.length && this.connected_) {
      this.disconnect_();
    }
  };
  /**
   * Invokes the update of observers. It will continue running updates insofar
   * it detects changes.
   *
   * @returns {void}
   */


  ResizeObserverController.prototype.refresh = function () {
    var changesDetected = this.updateObservers_(); // Continue running updates if changes have been detected as there might
    // be future ones caused by CSS transitions.

    if (changesDetected) {
      this.refresh();
    }
  };
  /**
   * Updates every observer from observers list and notifies them of queued
   * entries.
   *
   * @private
   * @returns {boolean} Returns "true" if any observer has detected changes in
   *      dimensions of it's elements.
   */


  ResizeObserverController.prototype.updateObservers_ = function () {
    // Collect observers that have active observations.
    var activeObservers = this.observers_.filter(function (observer) {
      return observer.gatherActive(), observer.hasActive();
    }); // Deliver notifications in a separate cycle in order to avoid any
    // collisions between observers, e.g. when multiple instances of
    // ResizeObserver are tracking the same element and the callback of one
    // of them changes content dimensions of the observed target. Sometimes
    // this may result in notifications being blocked for the rest of observers.

    activeObservers.forEach(function (observer) {
      return observer.broadcastActive();
    });
    return activeObservers.length > 0;
  };
  /**
   * Initializes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.connect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already added.
    if (!isBrowser || this.connected_) {
      return;
    } // Subscription to the "Transitionend" event is used as a workaround for
    // delayed transitions. This way it's possible to capture at least the
    // final state of an element.


    document.addEventListener('transitionend', this.onTransitionEnd_);
    window.addEventListener('resize', this.refresh);

    if (mutationObserverSupported) {
      this.mutationsObserver_ = new MutationObserver(this.refresh);
      this.mutationsObserver_.observe(document, {
        attributes: true,
        childList: true,
        characterData: true,
        subtree: true
      });
    } else {
      document.addEventListener('DOMSubtreeModified', this.refresh);
      this.mutationEventsAdded_ = true;
    }

    this.connected_ = true;
  };
  /**
   * Removes DOM listeners.
   *
   * @private
   * @returns {void}
   */


  ResizeObserverController.prototype.disconnect_ = function () {
    // Do nothing if running in a non-browser environment or if listeners
    // have been already removed.
    if (!isBrowser || !this.connected_) {
      return;
    }

    document.removeEventListener('transitionend', this.onTransitionEnd_);
    window.removeEventListener('resize', this.refresh);

    if (this.mutationsObserver_) {
      this.mutationsObserver_.disconnect();
    }

    if (this.mutationEventsAdded_) {
      document.removeEventListener('DOMSubtreeModified', this.refresh);
    }

    this.mutationsObserver_ = null;
    this.mutationEventsAdded_ = false;
    this.connected_ = false;
  };
  /**
   * "Transitionend" event handler.
   *
   * @private
   * @param {TransitionEvent} event
   * @returns {void}
   */


  ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
    var _b = _a.propertyName,
        propertyName = _b === void 0 ? '' : _b; // Detect whether transition may affect dimensions of an element.

    var isReflowProperty = transitionKeys.some(function (key) {
      return !!~propertyName.indexOf(key);
    });

    if (isReflowProperty) {
      this.refresh();
    }
  };
  /**
   * Returns instance of the ResizeObserverController.
   *
   * @returns {ResizeObserverController}
   */


  ResizeObserverController.getInstance = function () {
    if (!this.instance_) {
      this.instance_ = new ResizeObserverController();
    }

    return this.instance_;
  };
  /**
   * Holds reference to the controller's instance.
   *
   * @private {ResizeObserverController}
   */


  ResizeObserverController.instance_ = null;
  return ResizeObserverController;
}();
/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */


var defineConfigurable = function (target, props) {
  for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
    var key = _a[_i];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }

  return target;
};
/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */


var getWindowOf = function (target) {
  // Assume that the element is an instance of Node, which means that it
  // has the "ownerDocument" property from which we can retrieve a
  // corresponding global object.
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView; // Return the local global object if it's not possible extract one from
  // provided element.

  return ownerGlobal || global$1;
}; // Placeholder of an empty content rectangle.


var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */

function toFloat(value) {
  return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */


function getBordersSize(styles) {
  var positions = [];

  for (var _i = 1; _i < arguments.length; _i++) {
    positions[_i - 1] = arguments[_i];
  }

  return positions.reduce(function (size, position) {
    var value = styles['border-' + position + '-width'];
    return size + toFloat(value);
  }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */


function getPaddings(styles) {
  var positions = ['top', 'right', 'bottom', 'left'];
  var paddings = {};

  for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
    var position = positions_1[_i];
    var value = styles['padding-' + position];
    paddings[position] = toFloat(value);
  }

  return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */


function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */


function getHTMLElementContentRect(target) {
  // Client width & height properties can't be
  // used exclusively as they provide rounded values.
  var clientWidth = target.clientWidth,
      clientHeight = target.clientHeight; // By this condition we can catch all non-replaced inline, hidden and
  // detached elements. Though elements with width & height properties less
  // than 0.5 will be discarded as well.
  //
  // Without it we would need to implement separate methods for each of
  // those cases and it's not possible to perform a precise and performance
  // effective test for hidden elements. E.g. even jQuery's ':visible' filter
  // gives wrong results for elements with width & height less than 0.5.

  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }

  var styles = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom; // Computed styles of width & height are being used because they are the
  // only dimensions available to JS that contain non-rounded values. It could
  // be possible to utilize the getBoundingClientRect if only it's data wasn't
  // affected by CSS transformations let alone paddings, borders and scroll bars.

  var width = toFloat(styles.width),
      height = toFloat(styles.height); // Width & height include paddings and borders when the 'border-box' box
  // model is applied (except for IE).

  if (styles.boxSizing === 'border-box') {
    // Following conditions are required to handle Internet Explorer which
    // doesn't include paddings and borders to computed CSS dimensions.
    //
    // We can say that if CSS dimensions + paddings are equal to the "client"
    // properties then it's either IE, and thus we don't need to subtract
    // anything, or an element merely doesn't have paddings/borders styles.
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles, 'left', 'right') + horizPad;
    }

    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
    }
  } // Following steps can't be applied to the document's root element as its
  // client[Width/Height] properties represent viewport area of the window.
  // Besides, it's as well not necessary as the <html> itself neither has
  // rendered scroll bars nor it can be clipped.


  if (!isDocumentElement(target)) {
    // In some browsers (only in Firefox, actually) CSS width & height
    // include scroll bars size which can be removed at this step as scroll
    // bars are the only difference between rounded dimensions + paddings
    // and "client" properties, though that is not always true in Chrome.
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight; // Chrome has a rather weird rounding of "client" properties.
    // E.g. for an element with content width of 314.2px it sometimes gives
    // the client width of 315px and for the width of 314.7px it may give
    // 314px. And it doesn't happen all the time. So just ignore this delta
    // as a non-relevant.

    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }

    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }

  return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


var isSVGGraphicsElement = function () {
  // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
  // interface.
  if (typeof SVGGraphicsElement !== 'undefined') {
    return function (target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  } // If it's so, then check that element is at least an instance of the
  // SVGElement and that it has the "getBBox" method.
  // eslint-disable-next-line no-extra-parens


  return function (target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === 'function';
  };
}();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */


function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */


function getContentRect(target) {
  if (!isBrowser) {
    return emptyRect;
  }

  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }

  return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */


function createReadOnlyRect(_a) {
  var x = _a.x,
      y = _a.y,
      width = _a.width,
      height = _a.height; // If DOMRectReadOnly is available use it as a prototype for the rectangle.

  var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype); // Rectangle's properties are not writable and non-enumerable.

  defineConfigurable(rect, {
    x: x,
    y: y,
    width: width,
    height: height,
    top: y,
    right: x + width,
    bottom: height + y,
    left: x
  });
  return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */


function createRectInit(x, y, width, height) {
  return {
    x: x,
    y: y,
    width: width,
    height: height
  };
}
/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */


var ResizeObservation =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObservation.
   *
   * @param {Element} target - Element to be observed.
   */
  function ResizeObservation(target) {
    /**
     * Broadcasted width of content rectangle.
     *
     * @type {number}
     */
    this.broadcastWidth = 0;
    /**
     * Broadcasted height of content rectangle.
     *
     * @type {number}
     */

    this.broadcastHeight = 0;
    /**
     * Reference to the last observed content rectangle.
     *
     * @private {DOMRectInit}
     */

    this.contentRect_ = createRectInit(0, 0, 0, 0);
    this.target = target;
  }
  /**
   * Updates content rectangle and tells whether it's width or height properties
   * have changed since the last broadcast.
   *
   * @returns {boolean}
   */


  ResizeObservation.prototype.isActive = function () {
    var rect = getContentRect(this.target);
    this.contentRect_ = rect;
    return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
  };
  /**
   * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
   * from the corresponding properties of the last observed content rectangle.
   *
   * @returns {DOMRectInit} Last observed content rectangle.
   */


  ResizeObservation.prototype.broadcastRect = function () {
    var rect = this.contentRect_;
    this.broadcastWidth = rect.width;
    this.broadcastHeight = rect.height;
    return rect;
  };

  return ResizeObservation;
}();

var ResizeObserverEntry =
/** @class */
function () {
  /**
   * Creates an instance of ResizeObserverEntry.
   *
   * @param {Element} target - Element that is being observed.
   * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
   */
  function ResizeObserverEntry(target, rectInit) {
    var contentRect = createReadOnlyRect(rectInit); // According to the specification following properties are not writable
    // and are also not enumerable in the native implementation.
    //
    // Property accessors are not being used as they'd require to define a
    // private WeakMap storage which may cause memory leaks in browsers that
    // don't support this type of collections.

    defineConfigurable(this, {
      target: target,
      contentRect: contentRect
    });
  }

  return ResizeObserverEntry;
}();

var ResizeObserverSPI =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback function that is invoked
   *      when one of the observed elements changes it's content dimensions.
   * @param {ResizeObserverController} controller - Controller instance which
   *      is responsible for the updates of observer.
   * @param {ResizeObserver} callbackCtx - Reference to the public
   *      ResizeObserver instance which will be passed to callback function.
   */
  function ResizeObserverSPI(callback, controller, callbackCtx) {
    /**
     * Collection of resize observations that have detected changes in dimensions
     * of elements.
     *
     * @private {Array<ResizeObservation>}
     */
    this.activeObservations_ = [];
    /**
     * Registry of the ResizeObservation instances.
     *
     * @private {Map<Element, ResizeObservation>}
     */

    this.observations_ = new MapShim();

    if (typeof callback !== 'function') {
      throw new TypeError('The callback provided as parameter 1 is not a function.');
    }

    this.callback_ = callback;
    this.controller_ = controller;
    this.callbackCtx_ = callbackCtx;
  }
  /**
   * Starts observing provided element.
   *
   * @param {Element} target - Element to be observed.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.observe = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is already being observed.

    if (observations.has(target)) {
      return;
    }

    observations.set(target, new ResizeObservation(target));
    this.controller_.addObserver(this); // Force the update of observations.

    this.controller_.refresh();
  };
  /**
   * Stops observing provided element.
   *
   * @param {Element} target - Element to stop observing.
   * @returns {void}
   */


  ResizeObserverSPI.prototype.unobserve = function (target) {
    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    } // Do nothing if current environment doesn't have the Element interface.


    if (typeof Element === 'undefined' || !(Element instanceof Object)) {
      return;
    }

    if (!(target instanceof getWindowOf(target).Element)) {
      throw new TypeError('parameter 1 is not of type "Element".');
    }

    var observations = this.observations_; // Do nothing if element is not being observed.

    if (!observations.has(target)) {
      return;
    }

    observations.delete(target);

    if (!observations.size) {
      this.controller_.removeObserver(this);
    }
  };
  /**
   * Stops observing all elements.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.disconnect = function () {
    this.clearActive();
    this.observations_.clear();
    this.controller_.removeObserver(this);
  };
  /**
   * Collects observation instances the associated element of which has changed
   * it's content rectangle.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.gatherActive = function () {
    var _this = this;

    this.clearActive();
    this.observations_.forEach(function (observation) {
      if (observation.isActive()) {
        _this.activeObservations_.push(observation);
      }
    });
  };
  /**
   * Invokes initial callback function with a list of ResizeObserverEntry
   * instances collected from active resize observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.broadcastActive = function () {
    // Do nothing if observer doesn't have active observations.
    if (!this.hasActive()) {
      return;
    }

    var ctx = this.callbackCtx_; // Create ResizeObserverEntry instance for every active observation.

    var entries = this.activeObservations_.map(function (observation) {
      return new ResizeObserverEntry(observation.target, observation.broadcastRect());
    });
    this.callback_.call(ctx, entries, ctx);
    this.clearActive();
  };
  /**
   * Clears the collection of active observations.
   *
   * @returns {void}
   */


  ResizeObserverSPI.prototype.clearActive = function () {
    this.activeObservations_.splice(0);
  };
  /**
   * Tells whether observer has active observations.
   *
   * @returns {boolean}
   */


  ResizeObserverSPI.prototype.hasActive = function () {
    return this.activeObservations_.length > 0;
  };

  return ResizeObserverSPI;
}(); // Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.


var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */

var ResizeObserver =
/** @class */
function () {
  /**
   * Creates a new instance of ResizeObserver.
   *
   * @param {ResizeObserverCallback} callback - Callback that is invoked when
   *      dimensions of the observed elements change.
   */
  function ResizeObserver(callback) {
    if (!(this instanceof ResizeObserver)) {
      throw new TypeError('Cannot call a class as a function.');
    }

    if (!arguments.length) {
      throw new TypeError('1 argument required, but only 0 present.');
    }

    var controller = ResizeObserverController.getInstance();
    var observer = new ResizeObserverSPI(callback, controller, this);
    observers.set(this, observer);
  }

  return ResizeObserver;
}(); // Expose public methods of ResizeObserver.


['observe', 'unobserve', 'disconnect'].forEach(function (method) {
  ResizeObserver.prototype[method] = function () {
    var _a;

    return (_a = observers.get(this))[method].apply(_a, arguments);
  };
});

var index = function () {
  // Export existing implementation if available.
  if (typeof global$1.ResizeObserver !== 'undefined') {
    return global$1.ResizeObserver;
  }

  return ResizeObserver;
}();

const isServer = typeof window === 'undefined';
/* istanbul ignore next */

const resizeHandler = function (entries) {
  for (const entry of entries) {
    const listeners = entry.target.__resizeListeners__ || [];

    if (listeners.length) {
      listeners.forEach(fn => {
        fn();
      });
    }
  }
};

const useResizeEvent = () => {
  let element = null;

  const addResizeListener = fn => {
    element.__resizeListeners__.push(fn);
  };

  const removeResizeListener = fn => {
    if (!element || !element.__resizeListeners__) return;

    element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

    if (!element.__resizeListeners__.length) {
      element.__ro__.disconnect();
    }
  };

  onMounted(() => {
    element = getCurrentInstance().vnode.el;
    if (isServer) return;

    if (!element.__resizeListeners__) {
      element.__resizeListeners__ = [];
      element.__ro__ = new index(resizeHandler);

      element.__ro__.observe(element);
    }
  });
  return {
    addResizeListener,
    removeResizeListener
  };
};
/* istanbul ignore next */

const addResizeListener = function (element, fn) {
  if (isServer) return;

  if (!element.__resizeListeners__) {
    element.__resizeListeners__ = [];
    element.__ro__ = new index(resizeHandler);

    element.__ro__.observe(element);
  }

  element.__resizeListeners__.push(fn);
};
/* istanbul ignore next */

const removeResizeListener = function (element, fn) {
  if (!element || !element.__resizeListeners__) return;

  element.__resizeListeners__.splice(element.__resizeListeners__.indexOf(fn), 1);

  if (!element.__resizeListeners__.length) {
    element.__ro__.disconnect();
  }
};

const BAR_MAP = {
  vertical: {
    offset: 'offsetHeight',
    scroll: 'scrollTop',
    scrollSize: 'scrollHeight',
    size: 'height',
    key: 'vertical',
    axis: 'Y',
    client: 'clientY',
    direction: 'top'
  },
  horizontal: {
    offset: 'offsetWidth',
    scroll: 'scrollLeft',
    scrollSize: 'scrollWidth',
    size: 'width',
    key: 'horizontal',
    axis: 'X',
    client: 'clientX',
    direction: 'left'
  }
};
function renderThumbStyle({
  move,
  size,
  bar
}) {
  const style = {};
  const translate = `translate${bar.value.axis}(${move.value}%)`;
  style[bar.value.size] = size.value;
  style.transform = translate;
  style.msTransform = translate;
  style.webkitTransform = translate;
  return style;
}

const useDrag = ({
  bar,
  state,
  thumb,
  cursorDown
}) => {
  const instance = getCurrentInstance();
  const {
    ctx
  } = instance;
  const wrap = computed(() => instance.parent.ctx.wrap);

  const startDrag = e => {
    e.stopImmediatePropagation();
    cursorDown.value = true;
    on(document, 'mousemove', mouseMoveDocumentHandler);
    on(document, 'mouseup', mouseUpDocumentHandler);

    document.onselectstart = () => false;
  };

  const mouseMoveDocumentHandler = e => {
    if (cursorDown.value === false) return;
    const prevPage = state[bar.value.axis];
    if (!prevPage) return;
    const offset = (ctx.$el.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]) * -1;
    const thumbClickPosition = thumb.value[bar.value.offset] - prevPage;
    const thumbPositionPercentage = (offset - thumbClickPosition) * 100 / ctx.$el[bar.value.offset];
    wrap.value[bar.value.scroll] = thumbPositionPercentage * wrap.value[bar.value.scrollSize] / 100;
  };

  const mouseUpDocumentHandler = () => {
    cursorDown.value = false;
    state[bar.value.axis] = 0;
    off(document, 'mousemove', mouseMoveDocumentHandler);
    document.onselectstart = null;
  };

  const clickThumbHandler = e => {
    // prevent click event of right button
    if (e.ctrlKey || e.button === 2) {
      return;
    }

    startDrag(e);
    state[bar.value.axis] = e.currentTarget[bar.value.offset] - (e[bar.value.client] - e.currentTarget.getBoundingClientRect()[bar.value.direction]);
  };

  const clickTrackHandler = e => {
    const offset = Math.abs(e.target.getBoundingClientRect()[bar.value.direction] - e[bar.value.client]);
    const thumbHalf = thumb.value[bar.value.offset] / 2;
    const thumbPositionPercentage = (offset - thumbHalf) * 100 / ctx.$el[bar.value.offset];
    wrap.value[bar.value.scroll] = thumbPositionPercentage * wrap.value[bar.value.scrollSize] / 100;
  };

  onUnmounted(() => {
    off(document, 'mouseup', mouseUpDocumentHandler);
  });
  return {
    clickThumbHandler,
    clickTrackHandler
  };
};
/* istanbul ignore next */


var Bar = {
  name: 'Bar',
  props: {
    vertical: Boolean,
    size: String,
    move: Number
  },

  setup(props) {
    const {
      size,
      move,
      vertical
    } = toRefs(props);
    const bar = computed(() => BAR_MAP[vertical.value ? 'vertical' : 'horizontal']);
    const state = reactive({});
    const cursorDown = ref(false);
    const thumb = ref(null);
    const {
      clickThumbHandler,
      clickTrackHandler
    } = useDrag({
      bar,
      state,
      thumb,
      cursorDown
    });
    return () => createVNode("div", {
      "class": ['el-scrollbar__bar', 'is-' + bar.value.key],
      "onMouseDown": clickTrackHandler
    }, [createVNode("div", {
      "ref": thumb,
      "className": "el-scrollbar__thumb",
      "onMouseDown": clickThumbHandler,
      "style": renderThumbStyle({
        size,
        move,
        bar
      })
    }, null)]);
  }

};

const useScroll = (wrap, native, resize, noresize) => {
  const data = reactive({
    sizeWidth: '0',
    sizeHeight: '0',
    moveX: 0,
    moveY: 0
  });

  const handleScroll = () => {
    data.moveY = wrap.value.scrollTop * 100 / wrap.value.clientHeight;
    data.moveX = wrap.value.scrollLeft * 100 / wrap.value.clientWidth;
  };

  const update = () => {
    if (!(wrap === null || wrap === void 0 ? void 0 : wrap.value)) return;
    const heightPercentage = wrap.value.clientHeight * 100 / wrap.value.scrollHeight;
    const widthPercentage = wrap.value.clientWidth * 100 / wrap.value.scrollWidth;
    data.sizeHeight = heightPercentage < 100 ? heightPercentage + '%' : '';
    data.sizeWidth = widthPercentage < 100 ? widthPercentage + '%' : '';
  };

  onMounted(() => {
    if (native.value) return;
    nextTick(update);
    !noresize.value && addResizeListener(resize.value, update);
  });
  onUnmounted(() => {
    if (native.value) return;
    !noresize.value && removeResizeListener(resize.value, update);
  });
  return {
    data,
    update,
    handleScroll
  };
};
/* istanbul ignore next */


var ElScrollbar = {
  name: 'ElScrollbar',
  components: {
    Bar
  },
  props: {
    native: Boolean,
    wrapStyle: {},
    wrapClass: {},
    viewClass: {},
    viewStyle: {},
    noresize: Boolean,
    // 如果 container 尺寸不会发生变化，最好设置它可以优化性能
    tag: {
      type: String,
      default: 'div'
    }
  },

  setup(props) {
    const wrap = ref(null);
    const resize = ref(null);
    const {
      wrapStyle,
      tag,
      native,
      noresize
    } = toRefs(props);
    const gutter = getScrollBarWidth();
    let style = wrapStyle === null || wrapStyle === void 0 ? void 0 : wrapStyle.value;
    const ComponentName = tag.value;

    if (gutter) {
      const gutterWith = `-${gutter}px`;
      const gutterStyle = `margin-bottom: ${gutterWith}; margin-right: ${gutterWith};`;

      if (Array.isArray(wrapStyle === null || wrapStyle === void 0 ? void 0 : wrapStyle.value)) {
        style = toObject(wrapStyle === null || wrapStyle === void 0 ? void 0 : wrapStyle.value);
        style.marginRight = style.marginBottom = gutterWith;
      } else if (typeof wrapStyle === 'string') {
        style += gutterStyle;
      } else {
        style = gutterStyle;
      }
    }

    const {
      data,
      handleScroll,
      update
    } = useScroll(wrap, native, resize, noresize);
    return {
      // state
      data,
      style,
      native,
      gutter,
      wrap,
      resize,
      ComponentName,
      // methods
      handleScroll,
      update
    };
  },

  render() {
    const ComponentName = this.ComponentName;
    return createVNode("div", {
      "class": "el-scrollbar"
    }, [createVNode("div", {
      "ref": "wrap",
      "class": [this.wrapClass, 'el-scrollbar__wrap', {
        'el-scrollbar__wrap--hidden-default': !this.native && !this.gutter
      }],
      "onScroll": () => {
        !this.native && this.handleScroll();
      },
      "style": this.style
    }, [createVNode(ComponentName, {
      "ref": "resize",
      "class": ['el-scrollbar__view', this.viewClass],
      "style": this.viewStyle
    }, {
      default: () => [this.$slots.default()]
    })]), !this.native.value && [createVNode(Bar, {
      "move": this.data.moveX,
      "size": this.data.sizeWidth
    }, null), createVNode(Bar, {
      "vertical": true,
      "move": this.data.moveY,
      "size": this.data.sizeHeight
    }, null)]]);
  }

};

/* istanbul ignore next */

ElScrollbar.install = function (app) {
  app.component(ElScrollbar.name, ElScrollbar);
};

/* eslint-disable no-undefined,no-param-reassign,no-shadow */

/**
 * Throttle execution of a function. Especially useful for rate limiting
 * execution of handlers on events like resize and scroll.
 *
 * @param  {number}    delay -          A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}   [noTrailing] -   Optional, defaults to false. If noTrailing is true, callback will only execute every `delay` milliseconds while the
 *                                    throttled-function is being called. If noTrailing is false or unspecified, callback will be executed one final time
 *                                    after the last throttled-function call. (After the throttled-function has not been called for `delay` milliseconds,
 *                                    the internal counter is reset).
 * @param  {Function}  callback -       A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                    to `callback` when the throttled-function is executed.
 * @param  {boolean}   [debounceMode] - If `debounceMode` is true (at begin), schedule `clear` to execute after `delay` ms. If `debounceMode` is false (at end),
 *                                    schedule `callback` to execute after `delay` ms.
 *
 * @returns {Function}  A new, throttled, function.
 */
function throttle$1(delay, noTrailing, callback, debounceMode) {
  /*
   * After wrapper has stopped being called, this timeout ensures that
   * `callback` is executed at the proper times in `throttle` and `end`
   * debounce modes.
   */
  var timeoutID;
  var cancelled = false; // Keep track of the last time `callback` was executed.

  var lastExec = 0; // Function to clear existing timeout

  function clearExistingTimeout() {
    if (timeoutID) {
      clearTimeout(timeoutID);
    }
  } // Function to cancel next exec


  function cancel() {
    clearExistingTimeout();
    cancelled = true;
  } // `noTrailing` defaults to falsy.


  if (typeof noTrailing !== 'boolean') {
    debounceMode = callback;
    callback = noTrailing;
    noTrailing = undefined;
  }
  /*
   * The `wrapper` function encapsulates all of the throttling / debouncing
   * functionality and when executed will limit the rate at which `callback`
   * is executed.
   */


  function wrapper() {
    for (var _len = arguments.length, arguments_ = new Array(_len), _key = 0; _key < _len; _key++) {
      arguments_[_key] = arguments[_key];
    }

    var self = this;
    var elapsed = Date.now() - lastExec;

    if (cancelled) {
      return;
    } // Execute `callback` and update the `lastExec` timestamp.


    function exec() {
      lastExec = Date.now();
      callback.apply(self, arguments_);
    }
    /*
     * If `debounceMode` is true (at begin) this is used to clear the flag
     * to allow future `callback` executions.
     */


    function clear() {
      timeoutID = undefined;
    }

    if (debounceMode && !timeoutID) {
      /*
       * Since `wrapper` is being called for the first time and
       * `debounceMode` is true (at begin), execute `callback`.
       */
      exec();
    }

    clearExistingTimeout();

    if (debounceMode === undefined && elapsed > delay) {
      /*
       * In throttle mode, if `delay` time has been exceeded, execute
       * `callback`.
       */
      exec();
    } else if (noTrailing !== true) {
      /*
       * In trailing throttle mode, since `delay` time has not been
       * exceeded, schedule `callback` to execute `delay` ms after most
       * recent execution.
       *
       * If `debounceMode` is true (at begin), schedule `clear` to execute
       * after `delay` ms.
       *
       * If `debounceMode` is false (at end), schedule `callback` to
       * execute after `delay` ms.
       */
      timeoutID = setTimeout(debounceMode ? clear : exec, debounceMode === undefined ? delay - elapsed : delay);
    }
  }

  wrapper.cancel = cancel; // Return the wrapper function.

  return wrapper;
}
/* eslint-disable no-undefined */

/**
 * Debounce execution of a function. Debouncing, unlike throttling,
 * guarantees that a function is only executed a single time, either at the
 * very beginning of a series of calls, or at the very end.
 *
 * @param  {number}   delay -         A zero-or-greater delay in milliseconds. For event callbacks, values around 100 or 250 (or even higher) are most useful.
 * @param  {boolean}  [atBegin] -     Optional, defaults to false. If atBegin is false or unspecified, callback will only be executed `delay` milliseconds
 *                                  after the last debounced-function call. If atBegin is true, callback will be executed only at the first debounced-function call.
 *                                  (After the throttled-function has not been called for `delay` milliseconds, the internal counter is reset).
 * @param  {Function} callback -      A function to be executed after delay milliseconds. The `this` context and all arguments are passed through, as-is,
 *                                  to `callback` when the debounced-function is executed.
 *
 * @returns {Function} A new, debounced function.
 */


function debounce(delay, atBegin, callback) {
  return callback === undefined ? throttle$1(delay, atBegin, false) : throttle$1(delay, callback, atBegin !== false);
}

const nodeList = [];
const ctx = '@@clickoutsideContext';
let startClick;
let seed = 0; // !Vue.prototype.$isServer && on(document, 'mousedown', e => (startClick = e))

on(document, 'mousedown', e => startClick = e);
on(document, 'mouseup', e => {
  // !Vue.prototype.$isServer && on(document, 'mouseup', e => {
  nodeList.forEach(node => node[ctx].documentHandler(e, startClick));
});

function createDocumentHandler(el, binding, vnode) {
  return function (mouseup = {}, mousedown = {}) {
    if (!vnode || !binding.instance || !mouseup.target || !mousedown.target || el.contains(mouseup.target) || el.contains(mousedown.target) || el === mouseup.target || binding.instance.popperElm && (binding.instance.popperElm.contains(mouseup.target) || binding.instance.popperElm.contains(mousedown.target))) return;

    if (binding.expression && el[ctx].methodName && binding.instance[el[ctx].methodName]) {
      binding.instance[el[ctx].methodName]();
    } else {
      el[ctx].bindingFn && el[ctx].bindingFn();
    }
  };
}
/**
 * v-clickoutside
 * @desc 点击元素外面才会触发的事件
 * @example
 * ```vue
 * <div v-element-clickoutside="handleClose">
 * ```
 */


var Clickoutside = {
  beforeMount(el, binding, vnode) {
    nodeList.push(el);
    const id = seed++;
    el[ctx] = {
      id,
      documentHandler: createDocumentHandler(el, binding, vnode),
      methodName: binding.expression,
      bindingFn: binding.value
    };
  },

  updated(el, binding, vnode) {
    el[ctx].documentHandler = createDocumentHandler(el, binding, vnode);
    el[ctx].methodName = binding.expression;
    el[ctx].bindingFn = binding.value;
  },

  unmounted(el) {
    const len = nodeList.length;

    for (let i = 0; i < len; i++) {
      if (nodeList[i][ctx].id === el[ctx].id) {
        nodeList.splice(i, 1);
        break;
      }
    }

    delete el[ctx];
  }

};

function scrollIntoView(container, selected) {
  // if (Vue.prototype.$isServer) return
  if (!selected) {
    container.scrollTop = 0;
    return;
  }

  const offsetParents = [];
  let pointer = selected.offsetParent;

  while (pointer && container !== pointer && container.contains(pointer)) {
    offsetParents.push(pointer);
    pointer = pointer.offsetParent;
  }

  const top = selected.offsetTop + offsetParents.reduce((prev, curr) => prev + curr.offsetTop, 0);
  const bottom = top + selected.offsetHeight;
  const viewRectTop = container.scrollTop;
  const viewRectBottom = viewRectTop + container.clientHeight;

  if (top < viewRectTop) {
    container.scrollTop = top;
  } else if (bottom > viewRectBottom) {
    container.scrollTop = bottom - container.clientHeight;
  }
}

var NavigationMixin = {
  data() {
    return {
      hoverOption: -1
    };
  },

  computed: {
    optionsAllDisabled() {
      return this.options.filter(option => option.visible).every(option => option.disabled);
    }

  },
  watch: {
    hoverIndex(val) {
      if (typeof val === 'number' && val > -1) {
        this.hoverOption = this.options[val] || {};
      }

      this.options.forEach(option => {
        option.hover = this.hoverOption === option;
      });
    }

  },
  methods: {
    navigateOptions(direction) {
      if (!this.visible) {
        this.visible = true;
        return;
      }

      if (this.options.length === 0 || this.filteredOptionsCount === 0) return;

      if (!this.optionsAllDisabled) {
        if (direction === 'next') {
          this.hoverIndex++;

          if (this.hoverIndex === this.options.length) {
            this.hoverIndex = 0;
          }
        } else if (direction === 'prev') {
          this.hoverIndex--;

          if (this.hoverIndex < 0) {
            this.hoverIndex = this.options.length - 1;
          }
        }

        const option = this.options[this.hoverIndex];

        if (option.disabled === true || option.groupDisabled === true || !option.visible) {
          this.navigateOptions(direction);
        }

        this.$nextTick(() => this.scrollToOption(this.hoverOption));
      }
    }

  }
};

var script$l = {
  mixins: [Locale, Focus('reference'), NavigationMixin],
  name: 'ElSelect',
  componentName: 'ElSelect',
  inject: {
    elForm: {
      default: ''
    },
    elFormItem: {
      default: ''
    }
  },

  provide() {
    return {
      select: this
    };
  },

  computed: {
    _elFormItemSize() {
      return (this.elFormItem || {}).elFormItemSize;
    },

    readonly() {
      return !this.filterable || this.multiple || !isIE() && !isEdge() && !this.visible;
    },

    showClose() {
      const hasValue = this.multiple ? Array.isArray(this.modelValue) && this.modelValue.length > 0 : this.modelValue !== undefined && this.modelValue !== null && this.modelValue !== '';
      const criteria = this.clearable && !this.selectDisabled && this.inputHovering && hasValue;
      return criteria;
    },

    iconClass() {
      return this.remote && this.filterable ? '' : this.visible ? 'arrow-up is-reverse' : 'arrow-up';
    },

    debounce() {
      return this.remote ? 300 : 0;
    },

    emptyText() {
      if (this.loading) {
        return this.loadingText || this.t('el.select.loading');
      } else {
        if (this.remote && this.query === '' && this.options.length === 0) return false;

        if (this.filterable && this.query && this.options.length > 0 && this.filteredOptionsCount === 0) {
          return this.noMatchText || this.t('el.select.noMatch');
        }

        if (this.options.length === 0) {
          return this.noDataText || this.t('el.select.noData');
        }
      }

      return null;
    },

    showNewOption() {
      const hasExistingOption = this.options.filter(option => !option.created).some(option => option.currentLabel === this.query);
      return this.filterable && this.allowCreate && this.query !== '' && !hasExistingOption;
    },

    selectSize() {
      return this.size || this._elFormItemSize || (this.$ELEMENT || {}).size;
    },

    selectDisabled() {
      return this.disabled || (this.elForm || {}).disabled;
    },

    collapseTagSize() {
      return ['small', 'mini'].indexOf(this.selectSize) > -1 ? 'mini' : 'small';
    }

  },
  components: {
    ElInput: script$g,
    ElSelectMenu: script$i,
    ElOption: script$j,
    ElTag: script$k,
    ElScrollbar
  },
  directives: {
    Clickoutside
  },
  props: {
    name: String,
    id: String,
    modelValue: {
      required: true
    },
    autocomplete: {
      type: String,
      default: 'off'
    },

    /** @Deprecated in next major version */
    autoComplete: {
      type: String,

      validator() {
        process.env.NODE_ENV !== 'production' && console.warn("[Element Warn][Select]'auto-complete' property will be deprecated in next major version. please use 'autocomplete' instead.");
        return true;
      }

    },
    automaticDropdown: Boolean,
    size: String,
    disabled: Boolean,
    clearable: Boolean,
    filterable: Boolean,
    allowCreate: Boolean,
    loading: Boolean,
    popperClass: String,
    remote: Boolean,
    loadingText: String,
    noMatchText: String,
    noDataText: String,
    remoteMethod: Function,
    filterMethod: Function,
    multiple: Boolean,
    multipleLimit: {
      type: Number,
      default: 0
    },
    placeholder: {
      type: String,

      default() {
        return t('el.select.placeholder');
      }

    },
    defaultFirstOption: Boolean,
    reserveKeyword: Boolean,
    valueKey: {
      type: String,
      default: 'value'
    },
    collapseTags: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: true
    }
  },
  emits: ['update:modelValue', 'input', 'change', 'blur', 'focus', 'clear', 'visible-change', 'remove-tag', 'setSelected'],

  setup() {
    const {
      dispatch,
      broadcast,
      on
    } = useEmitter();
    return {
      dispatch,
      broadcast,
      on
    };
  },

  data() {
    return {
      options: [],
      cachedOptions: [],
      createdLabel: null,
      createdSelected: false,
      selected: this.multiple ? [] : {},
      inputLength: 20,
      inputWidth: 0,
      initialInputHeight: 0,
      cachedPlaceHolder: '',
      optionsCount: 0,
      filteredOptionsCount: 0,
      visible: false,
      softFocus: false,
      selectedLabel: '',
      hoverIndex: -1,
      query: '',
      previousQuery: null,
      inputHovering: false,
      currentPlaceholder: '',
      menuVisibleOnFocus: false,
      isOnComposition: false,
      isSilentBlur: false
    };
  },

  watch: {
    selectDisabled() {
      this.$nextTick(() => {
        this.resetInputHeight();
      });
    },

    placeholder(val) {
      this.cachedPlaceHolder = this.currentPlaceholder = val;
    },

    modelValue(val, oldVal) {
      if (this.multiple) {
        this.resetInputHeight();

        if (val && val.length > 0 || this.$refs.input && this.query !== '') {
          this.currentPlaceholder = '';
        } else {
          this.currentPlaceholder = this.cachedPlaceHolder;
        }

        if (this.filterable && !this.reserveKeyword) {
          this.query = '';
          this.handleQueryChange(this.query);
        }
      }

      this.setSelected();

      if (this.filterable && !this.multiple) {
        this.inputLength = 20;
      }

      if (!valueEquals(val, oldVal)) {
        this.dispatch('el.form.change', val);
      }
    },

    visible(val) {
      if (!val) {
        this.broadcast('destroyPopper');

        if (this.$refs.input) {
          this.$refs.input.blur();
        }

        this.query = '';
        this.previousQuery = null;
        this.selectedLabel = '';
        this.inputLength = 20;
        this.menuVisibleOnFocus = false;
        this.resetHoverIndex();
        this.$nextTick(() => {
          if (this.$refs.input && this.$refs.input.value === '' && this.selected.length === 0) {
            this.currentPlaceholder = this.cachedPlaceHolder;
          }
        });

        if (!this.multiple) {
          if (this.selected) {
            if (this.filterable && this.allowCreate && this.createdSelected && this.createdLabel) {
              this.selectedLabel = this.createdLabel;
            } else {
              this.selectedLabel = this.selected.currentLabel;
            }

            if (this.filterable) this.query = this.selectedLabel;
          }

          if (this.filterable) {
            this.currentPlaceholder = this.cachedPlaceHolder;
          }
        }
      } else {
        this.broadcast('updatePopper');

        if (this.filterable) {
          this.query = this.remote ? '' : this.selectedLabel;
          this.handleQueryChange(this.query);

          if (this.multiple) {
            this.$refs.input.focus();
          } else {
            if (!this.remote) {
              this.broadcast('queryChange', '');
              this.broadcast('optionGroup.queryChange');
            }

            if (this.selectedLabel) {
              this.currentPlaceholder = this.selectedLabel;
              this.selectedLabel = '';
            }
          }
        }
      }

      this.$emit('visible-change', val);
    },

    options() {
      if (this.$isServer) return;
      this.$nextTick(() => {
        this.broadcast('updatePopper');
      });

      if (this.multiple) {
        this.resetInputHeight();
      }

      const inputs = this.$el.querySelectorAll('input');

      if ([].indexOf.call(inputs, document.activeElement) === -1) {
        this.setSelected();
      }

      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
        this.checkDefaultFirstOption();
      }
    }

  },
  methods: {
    handleComposition(event) {
      const text = event.target.value;

      if (event.type === 'compositionend') {
        this.isOnComposition = false;
        this.$nextTick(() => this.handleQueryChange(text));
      } else {
        const lastCharacter = text[text.length - 1] || '';
        this.isOnComposition = !isKorean(lastCharacter);
      }
    },

    handleQueryChange(val) {
      if (this.previousQuery === val || this.isOnComposition) return;

      if (this.previousQuery === null && (typeof this.filterMethod === 'function' || typeof this.remoteMethod === 'function')) {
        this.previousQuery = val;
        return;
      }

      this.previousQuery = val;
      this.$nextTick(() => {
        if (this.visible) {
          this.broadcast('updatePopper');
        }
      });
      this.hoverIndex = -1;

      if (this.multiple && this.filterable) {
        this.$nextTick(() => {
          const length = this.$refs.input.value.length * 15 + 20;
          this.inputLength = this.collapseTags ? Math.min(50, length) : length;
          this.managePlaceholder();
          this.resetInputHeight();
        });
      }

      if (this.remote && typeof this.remoteMethod === 'function') {
        this.hoverIndex = -1;
        this.remoteMethod(val);
      } else if (typeof this.filterMethod === 'function') {
        this.filterMethod(val);
        this.broadcast('optionGroup.queryChange');
      } else {
        this.filteredOptionsCount = this.optionsCount;
        this.broadcast('queryChange', val);
        this.broadcast('optionGroup.queryChange');
      }

      if (this.defaultFirstOption && (this.filterable || this.remote) && this.filteredOptionsCount) {
        this.checkDefaultFirstOption();
      }
    },

    scrollToOption(option) {
      const target = Array.isArray(option) && option[0] ? option[0].$el : option.$el;

      if (this.$refs.popper && target) {
        const menu = this.$refs.popper.$el.querySelector('.el-select-dropdown__wrap');
        scrollIntoView(menu, target);
      }

      this.$refs.scrollbar && this.$refs.scrollbar.handleScroll();
    },

    handleMenuEnter() {
      this.$nextTick(() => this.scrollToOption(this.selected));
    },

    emitChange(val) {
      if (!valueEquals(this.modelValue, val)) {
        this.$emit('change', val);
      }
    },

    getOption(value) {
      let option;
      const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';
      const isNull = Object.prototype.toString.call(value).toLowerCase() === '[object null]';
      const isUndefined = Object.prototype.toString.call(value).toLowerCase() === '[object undefined]';

      for (let i = this.cachedOptions.length - 1; i >= 0; i--) {
        const cachedOption = this.cachedOptions[i];
        const isEqual = isObject ? getValueByPath(cachedOption.value, this.valueKey) === getValueByPath(value, this.valueKey) : cachedOption.value === value;

        if (isEqual) {
          option = cachedOption;
          break;
        }
      }

      if (option) return option;
      const label = !isObject && !isNull && !isUndefined ? value : '';
      const newOption = {
        value: value,
        currentLabel: label
      };

      if (this.multiple) {
        newOption.hitState = false;
      }

      return newOption;
    },

    setSelected() {
      if (!this.multiple) {
        const option = this.getOption(this.modelValue);

        if (option.created) {
          this.createdLabel = option.currentLabel;
          this.createdSelected = true;
        } else {
          this.createdSelected = false;
        }

        this.selectedLabel = option.currentLabel;
        this.selected = option;
        if (this.filterable) this.query = this.selectedLabel;
        return;
      }

      const result = [];

      if (Array.isArray(this.modelValue)) {
        this.modelValue.forEach(value => {
          result.push(this.getOption(value));
        });
      }

      this.selected = result;
      this.$nextTick(() => {
        this.resetInputHeight();
      });
    },

    handleFocus(event) {
      if (!this.softFocus) {
        if (this.automaticDropdown || this.filterable) {
          this.visible = true;

          if (this.filterable) {
            this.menuVisibleOnFocus = true;
          }
        }

        this.$emit('focus', event);
      } else {
        this.softFocus = false;
      }
    },

    blur() {
      this.visible = false;
      this.$refs.reference.blur();
    },

    handleBlur(event) {
      setTimeout(() => {
        if (this.isSilentBlur) {
          this.isSilentBlur = false;
        } else {
          this.$emit('blur', event);
        }
      }, 50);
      this.softFocus = false;
    },

    handleClearClick(event) {
      this.deleteSelected(event);
    },

    doDestroy() {
      this.$refs.popper && this.$refs.popper.doDestroy();
    },

    handleClose() {
      this.visible = false;
    },

    toggleLastOptionHitState(hit) {
      if (!Array.isArray(this.selected)) return;
      const option = this.selected[this.selected.length - 1];
      if (!option) return;

      if (hit === true || hit === false) {
        option.hitState = hit;
        return hit;
      }

      option.hitState = !option.hitState;
      return option.hitState;
    },

    deletePrevTag(e) {
      if (e.target.value.length <= 0 && !this.toggleLastOptionHitState()) {
        const value = this.modelValue.slice();
        value.pop();
        this.$emit('update:modelValue', value);
        this.emitChange(value);
      }
    },

    managePlaceholder() {
      if (this.currentPlaceholder !== '') {
        this.currentPlaceholder = this.$refs.input.value ? '' : this.cachedPlaceHolder;
      }
    },

    resetInputState(e) {
      if (e.keyCode !== 8) this.toggleLastOptionHitState(false);
      this.inputLength = this.$refs.input.value.length * 15 + 20;
      this.resetInputHeight();
    },

    resetInputHeight() {
      if (this.collapseTags && !this.filterable) return;
      this.$nextTick(() => {
        if (!this.$refs.reference) return;
        const inputChildNodes = this.$refs.reference.$el.childNodes;
        const input = [].filter.call(inputChildNodes, item => item.tagName === 'INPUT')[0];
        const tags = this.$refs.tags;
        const sizeInMap = this.initialInputHeight || 40;

        if (input) {
          input.style.height = this.selected.length === 0 ? sizeInMap + 'px' : Math.max(tags ? tags.clientHeight + (tags.clientHeight > sizeInMap ? 6 : 0) : 0, sizeInMap) + 'px';
        }

        if (this.visible && this.emptyText !== false) {
          this.broadcast('updatePopper');
        }
      });
    },

    resetHoverIndex() {
      setTimeout(() => {
        if (!this.multiple) {
          this.hoverIndex = this.options.indexOf(this.selected);
        } else {
          if (this.selected.length > 0) {
            this.hoverIndex = Math.min.apply(null, this.selected.map(item => this.options.indexOf(item)));
          } else {
            this.hoverIndex = -1;
          }
        }
      }, 300);
    },

    handleOptionSelect({
      option,
      byClick
    }) {
      if (this.multiple) {
        const value = (this.modelValue || []).slice();
        const optionIndex = this.getValueIndex(value, option.value);

        if (optionIndex > -1) {
          value.splice(optionIndex, 1);
        } else if (this.multipleLimit <= 0 || value.length < this.multipleLimit) {
          value.push(option.value);
        }

        this.$emit('update:modelValue', value);
        this.emitChange(value);

        if (option.created) {
          this.query = '';
          this.handleQueryChange('');
          this.inputLength = 20;
        }

        if (this.filterable) this.$refs.input.focus();
      } else {
        this.$emit('update:modelValue', option.value);
        this.emitChange(option.value);
        this.visible = false;
      }

      this.isSilentBlur = byClick;
      this.setSoftFocus();
      if (this.visible) return;
      this.$nextTick(() => {
        this.scrollToOption(option);
      });
    },

    setSoftFocus() {
      this.softFocus = true;
      const input = this.$refs.input || this.$refs.reference;

      if (input) {
        input.focus();
      }
    },

    getValueIndex(arr = [], value) {
      const isObject = Object.prototype.toString.call(value).toLowerCase() === '[object object]';

      if (!isObject) {
        return arr.indexOf(value);
      } else {
        const valueKey = this.valueKey;
        let index = -1;
        arr.some((item, i) => {
          if (getValueByPath(item, valueKey) === getValueByPath(value, valueKey)) {
            index = i;
            return true;
          }

          return false;
        });
        return index;
      }
    },

    toggleMenu() {
      if (!this.selectDisabled) {
        if (this.menuVisibleOnFocus) {
          this.menuVisibleOnFocus = false;
        } else {
          this.visible = !this.visible;
        }

        if (this.visible) {
          (this.$refs.input || this.$refs.reference).focus();
        }
      }
    },

    selectOption() {
      if (!this.visible) {
        this.toggleMenu();
      } else {
        if (this.options[this.hoverIndex]) {
          this.handleOptionSelect({
            option: this.options[this.hoverIndex]
          });
        }
      }
    },

    deleteSelected(event) {
      event.stopPropagation();
      const value = this.multiple ? [] : '';
      this.$emit('update:modelValue', value);
      this.emitChange(value);
      this.visible = false;
      this.$emit('clear');
    },

    deleteTag(event, tag) {
      const index = this.selected.indexOf(tag);

      if (index > -1 && !this.selectDisabled) {
        const value = this.modelValue.slice();
        value.splice(index, 1); // this.$emit('input', value)

        this.$emit('update:modelValue', value);
        this.emitChange(value);
        this.$emit('remove-tag', tag.value);
      }

      event.stopPropagation();
    },

    onInputChange() {
      if (this.filterable && this.query !== this.selectedLabel) {
        this.query = this.selectedLabel;
        this.handleQueryChange(this.query);
      }
    },

    onOptionDestroy(index) {
      if (index > -1) {
        this.optionsCount--;
        this.filteredOptionsCount--;
        this.options.splice(index, 1);
      }
    },

    resetInputWidth() {
      this.inputWidth = this.$refs.reference.$el.getBoundingClientRect().width;
    },

    handleResize() {
      this.resetInputWidth();
      if (this.multiple) this.resetInputHeight();
    },

    checkDefaultFirstOption() {
      this.hoverIndex = -1; // highlight the created option

      let hasCreated = false;

      for (let i = this.options.length - 1; i >= 0; i--) {
        if (this.options[i].created) {
          hasCreated = true;
          this.hoverIndex = i;
          break;
        }
      }

      if (hasCreated) return;

      for (let i = 0; i !== this.options.length; ++i) {
        const option = this.options[i];

        if (this.query) {
          // highlight first options that passes the filter
          if (!option.disabled && !option.groupDisabled && option.visible) {
            this.hoverIndex = i;
            break;
          }
        } else {
          // highlight currently selected option
          if (option.itemSelected) {
            this.hoverIndex = i;
            break;
          }
        }
      }
    },

    getValueKey(item) {
      if (Object.prototype.toString.call(item.value).toLowerCase() !== '[object object]') {
        return item.value;
      } else {
        return getValueByPath(item.value, this.valueKey);
      }
    }

  },

  created() {
    this.cachedPlaceHolder = this.currentPlaceholder = this.placeholder;

    if (this.multiple && !Array.isArray(this.modelValue)) {
      // this.$emit('input', [])
      this.$emit('update:modelValue', []);
    }

    if (!this.multiple && Array.isArray(this.modelValue)) {
      // this.$emit('input', '')
      this.$emit('update:modelValue', '');
    }

    this.debouncedOnInputChange = debounce(this.debounce, () => {
      this.onInputChange();
    });
    this.debouncedQueryChange = debounce(this.debounce, e => {
      this.handleQueryChange(e.target.value);
    });
    this.on('handleOptionClick', this.handleOptionSelect);
    this.on('setSelected', this.setSelected);
  },

  mounted() {
    if (this.multiple && Array.isArray(this.modelValue) && this.modelValue.length > 0) {
      this.currentPlaceholder = '';
    }

    addResizeListener(this.$el, this.handleResize);
    const reference = this.$refs.reference;

    if (reference && reference.$el) {
      const sizeMap = {
        medium: 36,
        small: 32,
        mini: 28
      };
      const input = reference.$el.querySelector('input');
      this.initialInputHeight = input.getBoundingClientRect().height || sizeMap[this.selectSize];
    }

    if (this.remote && this.multiple) {
      this.resetInputHeight();
    }

    this.$nextTick(() => {
      if (reference && reference.$el) {
        this.inputWidth = reference.$el.getBoundingClientRect().width;
      }
    });
    this.setSelected();
  },

  beforeUnmount() {
    if (this.$el && this.handleResize) removeResizeListener(this.$el, this.handleResize);
  }

};

const _hoisted_1$8 = { key: 0 };
const _hoisted_2$3 = { class: "el-select__tags-text" };
const _hoisted_3$1 = { class: "el-select__tags-text" };
const _hoisted_4$1 = { class: "el-select__tags-text" };
const _hoisted_5$1 = {
  key: 1,
  class: "el-select-dropdown__empty"
};

function render$j(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_option = resolveComponent("el-option");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _component_el_select_menu = resolveComponent("el-select-menu");
  const _directive_clickoutside = resolveDirective("clickoutside");

  return withDirectives((openBlock(), createBlock("div", {
    class: ["el-select", [$options.selectSize ? 'el-select--' + $options.selectSize : '']],
    onClick: _cache[23] || (_cache[23] = withModifiers((...args) => ($options.toggleMenu(...args)), ["stop"])),
    onMouseenter: _cache[24] || (_cache[24] = $event => ($data.inputHovering = true)),
    onMouseleave: _cache[25] || (_cache[25] = $event => ($data.inputHovering = false))
  }, [
    ($props.multiple)
      ? (openBlock(), createBlock("div", {
          key: 0,
          class: "el-select__tags",
          ref: "tags",
          style: { 'max-width': $data.inputWidth - 32 + 'px', width: '100%' }
        }, [
          ($props.collapseTags && $data.selected.length)
            ? (openBlock(), createBlock("span", _hoisted_1$8, [
                createVNode(_component_el_tag, {
                  closable: !$options.selectDisabled,
                  size: $options.collapseTagSize,
                  hit: $data.selected[0].hitState,
                  type: "info",
                  onClose: _cache[1] || (_cache[1] = $event => ($options.deleteTag($event, $data.selected[0]))),
                  "disable-transitions": ""
                }, {
                  default: withCtx(() => [
                    createVNode("span", _hoisted_2$3, toDisplayString($data.selected[0].currentLabel), 1 /* TEXT */)
                  ]),
                  _: 1
                }, 8 /* PROPS */, ["closable", "size", "hit"]),
                ($data.selected.length > 1)
                  ? (openBlock(), createBlock(_component_el_tag, {
                      key: 0,
                      closable: false,
                      size: $options.collapseTagSize,
                      type: "info",
                      "disable-transitions": ""
                    }, {
                      default: withCtx(() => [
                        createVNode("span", _hoisted_3$1, "+ " + toDisplayString($data.selected.length - 1), 1 /* TEXT */)
                      ]),
                      _: 1
                    }, 8 /* PROPS */, ["size"]))
                  : createCommentVNode("v-if", true)
              ]))
            : createCommentVNode("v-if", true),
          (!$props.collapseTags)
            ? (openBlock(), createBlock(TransitionGroup, {
                key: 1,
                onAfterLeave: $options.resetInputHeight
              }, {
                default: withCtx(() => [
                  createVNode("span", null, [
                    (openBlock(true), createBlock(Fragment, null, renderList($data.selected, (item) => {
                      return (openBlock(), createBlock(_component_el_tag, {
                        key: $options.getValueKey(item),
                        closable: !$options.selectDisabled,
                        size: $options.collapseTagSize,
                        hit: item.hitState,
                        type: "info",
                        onClose: $event => ($options.deleteTag($event, item)),
                        "disable-transitions": ""
                      }, {
                        default: withCtx(() => [
                          createVNode("span", _hoisted_4$1, toDisplayString(item.currentLabel), 1 /* TEXT */)
                        ]),
                        _: 2
                      }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["closable", "size", "hit", "onClose"]))
                    }), 128 /* KEYED_FRAGMENT */))
                  ])
                ]),
                _: 1
              }, 8 /* PROPS */, ["onAfterLeave"]))
            : createCommentVNode("v-if", true),
          ($props.filterable)
            ? withDirectives((openBlock(), createBlock("input", {
                key: 2,
                type: "text",
                class: ["el-select__input", [$options.selectSize ? `is-${$options.selectSize}` : '']],
                disabled: $options.selectDisabled,
                autocomplete: $props.autoComplete || $props.autocomplete,
                onFocus: _cache[2] || (_cache[2] = (...args) => ($options.handleFocus(...args))),
                onBlur: _cache[3] || (_cache[3] = $event => ($data.softFocus = false)),
                onKeyup: _cache[4] || (_cache[4] = (...args) => ($options.managePlaceholder(...args))),
                onKeydown: [
                  _cache[5] || (_cache[5] = (...args) => ($options.resetInputState(...args))),
                  _cache[6] || (_cache[6] = withKeys(withModifiers($event => (_ctx.navigateOptions('next')), ["prevent"]), ["down"])),
                  _cache[7] || (_cache[7] = withKeys(withModifiers($event => (_ctx.navigateOptions('prev')), ["prevent"]), ["up"])),
                  _cache[8] || (_cache[8] = withKeys(withModifiers((...args) => ($options.selectOption(...args)), ["prevent"]), ["enter"])),
                  _cache[9] || (_cache[9] = withKeys(withModifiers($event => ($data.visible = false), ["stop","prevent"]), ["esc"])),
                  _cache[10] || (_cache[10] = withKeys((...args) => ($options.deletePrevTag(...args)), ["delete"])),
                  _cache[11] || (_cache[11] = withKeys($event => ($data.visible = false), ["tab"]))
                ],
                onCompositionstart: _cache[12] || (_cache[12] = (...args) => ($options.handleComposition(...args))),
                onCompositionupdate: _cache[13] || (_cache[13] = (...args) => ($options.handleComposition(...args))),
                onCompositionend: _cache[14] || (_cache[14] = (...args) => ($options.handleComposition(...args))),
                "onUpdate:modelValue": _cache[15] || (_cache[15] = $event => ($data.query = $event)),
                onInput: _cache[16] || (_cache[16] = (...args) => (_ctx.debouncedQueryChange(...args))),
                style: {
          'flex-grow': '1',
          width: $data.inputLength / ($data.inputWidth - 32) + '%',
          'max-width': $data.inputWidth - 42 + 'px'
        },
                ref: "input"
              }, null, 46 /* CLASS, STYLE, PROPS, HYDRATE_EVENTS */, ["disabled", "autocomplete"])), [
                [vModelText, $data.query]
              ])
            : createCommentVNode("v-if", true)
        ], 4 /* STYLE */))
      : createCommentVNode("v-if", true),
    createVNode(_component_el_input, {
      ref: "reference",
      modelValue: $data.selectedLabel,
      "onUpdate:modelValue": _cache[18] || (_cache[18] = $event => ($data.selectedLabel = $event)),
      type: "text",
      placeholder: $data.currentPlaceholder,
      name: $props.name,
      id: $props.id,
      autocomplete: $props.autoComplete || $props.autocomplete,
      size: $options.selectSize,
      disabled: $options.selectDisabled,
      readonly: $options.readonly,
      "validate-event": false,
      class: { 'is-focus': $data.visible },
      tabindex: $props.multiple && $props.filterable ? '-1' : null,
      onFocus: $options.handleFocus,
      onBlur: $options.handleBlur,
      onKeyup: _ctx.debouncedOnInputChange,
      onKeydown: [
        _cache[19] || (_cache[19] = withKeys(withModifiers($event => (_ctx.navigateOptions('next')), ["stop","prevent"]), ["down"])),
        _cache[20] || (_cache[20] = withKeys(withModifiers($event => (_ctx.navigateOptions('prev')), ["stop","prevent"]), ["up"])),
        withKeys(withModifiers($options.selectOption, ["prevent"]), ["enter"]),
        _cache[21] || (_cache[21] = withKeys(withModifiers($event => ($data.visible = false), ["stop","prevent"]), ["esc"])),
        _cache[22] || (_cache[22] = withKeys($event => ($data.visible = false), ["tab"]))
      ],
      onPaste: _ctx.debouncedOnInputChange
    }, createSlots({
      suffix: withCtx(() => [
        withDirectives(createVNode("i", {
          class: [
            'el-select__caret',
            'el-input__icon',
            'el-icon-' + $options.iconClass
          ]
        }, null, 2 /* CLASS */), [
          [vShow, !$options.showClose]
        ]),
        ($options.showClose)
          ? (openBlock(), createBlock("i", {
              key: 0,
              class: "el-select__caret el-input__icon el-icon-circle-close",
              onClick: _cache[17] || (_cache[17] = (...args) => ($options.handleClearClick(...args)))
            }))
          : createCommentVNode("v-if", true)
      ]),
      _: 2
    }, [
      (_ctx.$slots.prefix)
        ? {
            name: "prefix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prefix")
            ])
          }
        : undefined
    ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["modelValue", "placeholder", "name", "id", "autocomplete", "size", "disabled", "readonly", "class", "tabindex", "onFocus", "onBlur", "onKeyup", "onKeydown", "onPaste"]),
    createVNode(Transition, {
      name: "el-zoom-in-top",
      onBeforeEnter: $options.handleMenuEnter,
      onAfterLeave: $options.doDestroy
    }, {
      default: withCtx(() => [
        withDirectives(createVNode(_component_el_select_menu, {
          ref: "popper",
          "append-to-body": $props.popperAppendToBody
        }, {
          default: withCtx(() => [
            withDirectives(createVNode(_component_el_scrollbar, {
              tag: "ul",
              "wrap-class": "el-select-dropdown__wrap",
              "view-class": "el-select-dropdown__list",
              ref: "scrollbar",
              class: {
            'is-empty': !$props.allowCreate && $data.query && $data.filteredOptionsCount === 0
          }
            }, {
              default: withCtx(() => [
                ($options.showNewOption)
                  ? (openBlock(), createBlock(_component_el_option, {
                      key: 0,
                      value: $data.query,
                      created: ""
                    }, null, 8 /* PROPS */, ["value"]))
                  : createCommentVNode("v-if", true),
                renderSlot(_ctx.$slots, "default")
              ]),
              _: 3
            }, 8 /* PROPS */, ["class"]), [
              [vShow, $data.options.length > 0 && !$props.loading]
            ]),
            (
            $options.emptyText &&
            (!$props.allowCreate || $props.loading || ($props.allowCreate && $data.options.length === 0))
          )
              ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                  (_ctx.$slots.empty)
                    ? renderSlot(_ctx.$slots, "empty", { key: 0 })
                    : (openBlock(), createBlock("p", _hoisted_5$1, toDisplayString($options.emptyText), 1 /* TEXT */))
                ], 64 /* STABLE_FRAGMENT */))
              : createCommentVNode("v-if", true)
          ]),
          _: 1
        }, 8 /* PROPS */, ["append-to-body"]), [
          [vShow, $data.visible && $options.emptyText !== false]
        ])
      ]),
      _: 1
    }, 8 /* PROPS */, ["onBeforeEnter", "onAfterLeave"])
  ], 34 /* CLASS, HYDRATE_EVENTS */)), [
    [_directive_clickoutside, $options.handleClose]
  ])
}

script$l.render = render$j;
script$l.__file = "packages/select/Select.vue";

/* istanbul ignore next */

script$l.install = function (app) {
  app.component(script$l.name, script$l);
};

/* istanbul ignore next */

script$j.install = function (app) {
  app.component(script$j.name, script$j);
};

var script$m = {
  name: 'ElOptionGroup',
  componentName: 'ElOptionGroup',
  props: {
    label: String,
    disabled: {
      type: Boolean,
      default: false
    }
  },

  setup(props) {
    const {
      disabled
    } = toRefs(props);
    const visible = ref(true);
    const {
      on,
      broadcast
    } = useEmitter();
    const {
      ctx
    } = getCurrentInstance();
    watch(disabled, val => {
      broadcast('handleGroupDisabled', val);
    });

    function queryChange() {
      visible.value = ctx.$children && Array.isArray(ctx.$children) && ctx.$children.some(option => option.visible === true);
    }

    onBeforeMount(() => {
      on('optionGroup.queryChange', queryChange);
    });
    onMounted(() => {
      if (unref(disabled)) {
        broadcast('handleGroupDisabled', unref(disabled));
      }
    });
    return {
      visible
    };
  }

};

const _hoisted_1$9 = { class: "el-select-group__wrap" };
const _hoisted_2$4 = { class: "el-select-group__title" };
const _hoisted_3$2 = { class: "el-select-group" };

function render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createBlock("ul", _hoisted_1$9, [
    createVNode("li", _hoisted_2$4, toDisplayString($props.label), 1 /* TEXT */),
    createVNode("li", null, [
      createVNode("ul", _hoisted_3$2, [
        renderSlot(_ctx.$slots, "default")
      ])
    ])
  ], 512 /* NEED_PATCH */)), [
    [vShow, $setup.visible]
  ])
}

script$m.render = render$k;
script$m.__file = "packages/option-group/OptionGroup.vue";

/* istanbul ignore next */

script$m.install = function (app) {
  app.component(script$m.name, script$m);
};

const stop$1 = e => e.stopPropagation();
/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */


var Popper$1 = {
  props: {
    transformOrigin: {
      type: [Boolean, String],
      default: true
    },
    placement: {
      type: String,
      default: 'bottom'
    },
    boundariesPadding: {
      type: Number,
      default: 5
    },
    reference: {},
    popper: {},
    offset: {
      default: 0
    },
    value: Boolean,
    visibleArrow: Boolean,
    arrowOffset: {
      type: Number,
      default: 35
    },
    appendToBody: {
      type: Boolean,
      default: true
    },
    popperOptions: {
      type: Object,

      default() {
        return {
          gpuAcceleration: false
        };
      }

    }
  },

  data() {
    return {
      showPopper: false,
      currentPlacement: ''
    };
  },

  watch: {
    value: {
      immediate: true,

      handler(val) {
        this.showPopper = val;
        this.$emit('input', val);
      }

    },

    showPopper(val) {
      if (this.disabled) return;
      val ? this.updatePopper() : this.destroyPopper();
      this.$emit('input', val);
    }

  },
  methods: {
    createPopper() {
      if (this.$isServer) return;
      this.currentPlacement = this.currentPlacement || this.placement;

      if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(this.currentPlacement)) {
        return;
      }

      const options = this.popperOptions;
      const popper = this.popperElm = this.popperElm || this.popper || this.$refs.popper;
      let reference = this.referenceElm = this.referenceElm || this.reference || this.$refs.reference;

      if (!reference && this.$slots.reference && this.$slots.reference[0]) {
        reference = this.referenceElm = this.$slots.reference[0].elm;
      }

      if (!popper || !reference) return;
      if (this.visibleArrow) this.appendArrow(popper);
      if (this.appendToBody) document.body.appendChild(this.popperElm);

      if (this.popperJS && this.popperJS.destroy) {
        this.popperJS.destroy();
      }

      options.placement = this.currentPlacement;
      options.offset = this.offset;
      options.arrowOffset = this.arrowOffset;
      this.popperJS = new Popper(reference, popper, options);
      this.popperJS.onCreate(() => {
        this.$emit('created', this);
        this.resetTransformOrigin();
        this.$nextTick(this.updatePopper);
      });

      if (typeof options.onUpdate === 'function') {
        this.popperJS.onUpdate(options.onUpdate);
      }

      this.popperJS._popper.style.zIndex = PopupManager.nextZIndex();
      this.popperElm.addEventListener('click', stop$1);
    },

    updatePopper() {
      const popperJS = this.popperJS;

      if (popperJS) {
        popperJS.update();

        if (popperJS._popper) {
          popperJS._popper.style.zIndex = PopupManager.nextZIndex();
        }
      } else {
        this.createPopper();
      }
    },

    doDestroy(forceDestroy) {
      /* istanbul ignore if */
      if (!this.popperJS || this.showPopper && !forceDestroy) return;
      this.popperJS.destroy();
      this.popperJS = null;
    },

    destroyPopper() {
      if (this.popperJS) {
        this.resetTransformOrigin();
      }
    },

    resetTransformOrigin() {
      if (!this.transformOrigin) return;
      const placementMap = {
        top: 'bottom',
        bottom: 'top',
        left: 'right',
        right: 'left'
      };

      const placement = this.popperJS._popper.getAttribute('x-placement').split('-')[0];

      const origin = placementMap[placement];
      this.popperJS._popper.style.transformOrigin = typeof this.transformOrigin === 'string' ? this.transformOrigin : ['top', 'bottom'].indexOf(placement) > -1 ? `center ${origin}` : `${origin} center`;
    },

    appendArrow(element) {
      let hash;

      if (this.appended) {
        return;
      }

      this.appended = true;

      for (const item in element.attributes) {
        if (/^_v-/.test(element.attributes[item].name)) {
          hash = element.attributes[item].name;
          break;
        }
      }

      const arrow = document.createElement('div');

      if (hash) {
        arrow.setAttribute(hash, '');
      }

      arrow.setAttribute('x-arrow', '');
      arrow.className = 'popper__arrow';
      element.appendChild(arrow);
    }

  },

  beforeUnmount() {
    this.doDestroy(true);

    if (this.popperElm && this.popperElm.parentNode === document.body) {
      this.popperElm.removeEventListener('click', stop$1);
      document.body.removeChild(this.popperElm);
    }
  },

  // call destroy in keep-alive mode
  deactivated() {
    this.$options.beforeUnmount[0].call(this);
  }

};

function migrating(options) {
  onMounted(() => {
    const componentInstance = getCurrentInstance();
    const componentName = componentInstance.type.name || '';
    const attrs = componentInstance.proxy.$attrs;

    for (const key in options) {
      if (attrs[key]) {
        const warn = options[key];
        const type = isOn(key) ? 'Event' : 'Attribute';
        console.warn(`[Element Migrating][${componentName}][${type}]: ${warn}`);
      }
    }
  });
}

var script$n = {
  components: {
    ElCheckbox: script$d,
    ElRadio: script$a,

    renderHelper(props) {
      const {
        render,
        node
      } = props.nodeLabel;
      const vNode = render ? render({
        node: node.value,
        data: node.value.data
      }) : null;
      const res = vNode || node.value.label;
      return h(Fragment, {}, [res]);
    }

  },
  emits: ['created', 'expand'],
  props: {
    node: {
      required: true
    },
    nodeId: String
  },

  setup(props, {
    emit
  }) {
    const {
      node
    } = toRefs(props);
    const {
      panel,
      config,
      checkedValue,
      inActivePath,
      inCheckedPath
    } = usePanel(node);
    const {
      value,
      loading,
      isLeaf,
      isDisabled,
      isChecked
    } = useNode(node, checkedValue);
    const nodeLabel = computed(() => ({
      node
    }));
    const disabled = computed(() => !config.value.checkStrictly && isDisabled.value);
    watchEffect(() => {
      if (isEqual(value.value, checkedValue.value)) value.value = checkedValue.value;
    });

    const handleMultiCheckChange = checked => {
      node.value.doCheck(checked);
      panel.calculateMultiCheckedValue();
    };

    const handleExpand = () => {
      if (!config.value.checkStrictly && isDisabled.value || node.value.loading) return;

      if (config.value.lazy && !node.value.loaded) {
        panel.lazyLoad(node.value, () => {
          // do not use cached leaf value here, invoke this.isLeaf to get new value.
          if (!isLeaf.value) handleExpand();

          if (config.value.multiple) {
            // if leaf sync checked state, else clear checked state
            const checked = isLeaf.value ? node.value.checked : false;
            handleMultiCheckChange(checked);
          }
        });
      } else {
        panel.handleExpand(node.value);
      }
    };

    const handleCheckChange = () => {
      panel.handleCheckChange(value);
      panel.handleExpand(node.value);
    };

    const handleClick = () => {
      if (isLeaf.value && !isDisabled.value && !config.value.checkStrictly && !config.value.multiple) {
        handleCheckChange();
      }

      if (config.value.expandTrigger !== 'click') return;
      if (config.value.expandTrigger === 'click') handleExpand();
    };

    const handleMouseenter = e => {
      if (config.value.expandTrigger === 'click') return;
      handleExpand();
      emit('expand', e);
    };

    return {
      // state
      // data
      nodeLabel,
      disabled,
      // useNode
      value,
      loading,
      isChecked,
      isLeaf,
      isDisabled,
      // usePanel
      config,
      inActivePath,
      checkedValue,
      inCheckedPath,

      // methods
      strictlyEvent() {},

      handleClick,
      handleMouseenter,
      handleCheckChange,
      handleMultiCheckChange,
      handleExpand
    };
  }

};

const useNode = (node, checkedValue) => {
  let value = node.value.getValueByOption();
  watch(node.value, newValue => {
    value = newValue.getValueByOption();
  });
  const loading = computed(() => node.value.loading);
  const isLeaf = computed(() => node.value.isLeaf);
  const isDisabled = computed(() => node.value.isDisabled);
  const isChecked = computed(() => node.value.isSameNode(checkedValue.value));
  return {
    value,
    loading,
    isLeaf,
    isDisabled,
    isChecked
  };
};

const usePanel = node => {
  const isInPath = pathNodes => {
    const selectedPathNode = (pathNodes === null || pathNodes === void 0 ? void 0 : pathNodes[(node === null || node === void 0 ? void 0 : node.value.level) - 1]) || {};
    return selectedPathNode.uid === (node === null || node === void 0 ? void 0 : node.value.uid);
  };

  const panel = inject('panel');
  const config = computed(() => panel.config);
  const checkedValue = computed(() => panel.checkedValue);
  const inActivePath = computed(() => isInPath(panel.activePath));
  const inCheckedPath = computed(() => {
    if (!config.value.checkStrictly) return false;
    return panel.checkedNodePaths.some(checkedPath => isInPath(checkedPath));
  });
  return {
    panel,
    config,
    checkedValue,
    inActivePath,
    inCheckedPath
  };
};

const _hoisted_1$a = /*#__PURE__*/createVNode("span", null, null, -1 /* HOISTED */);
const _hoisted_2$5 = {
  key: 2,
  class: "el-icon-check el-cascader-node__prefix"
};
const _hoisted_3$3 = { class: "el-cascader-node__label" };
const _hoisted_4$2 = {
  key: 1,
  class: "el-icon-loading el-cascader-node__postfix"
};
const _hoisted_5$2 = {
  key: 2,
  class: "el-icon-arrow-right el-cascader-node__postfix"
};

function render$l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_radio = resolveComponent("el-radio");
  const _component_render_helper = resolveComponent("render-helper");

  return (openBlock(), createBlock("li", {
    role: "menuitem",
    id: $props.nodeId,
    "aria-expanded": $setup.inActivePath,
    tabindex: !$setup.config.checkStrictly && $setup.isDisabled ? null : -1,
    class: {
      'el-cascader-node': true,
      'is-selectable': $setup.config.checkStrictly,
      'in-active-path': $setup.inActivePath,
      'in-checked-path': $setup.inCheckedPath,
      'is-active': $setup.isChecked,
      'is-disabled': $setup.disabled
    },
    onClick: _cache[2] || (_cache[2] = (...args) => ($setup.handleClick(...args))),
    onMouseenter: _cache[3] || (_cache[3] = (...args) => ($setup.handleMouseenter(...args))),
    onFocus: _cache[4] || (_cache[4] = (...args) => ($setup.handleMouseenter(...args)))
  }, [
    ($setup.config.multiple || $setup.config.checkStrictly || ($setup.isLeaf && $setup.isChecked))
      ? (openBlock(), createBlock(Fragment, { key: 0 }, [
          ($setup.config.multiple)
            ? (openBlock(), createBlock(_component_el_checkbox, {
                key: 0,
                modelValue: $props.node.checked,
                indeterminate: $props.node.indeterminate,
                disabled: $setup.isDisabled,
                "onUpdate:modelValue": $setup.handleMultiCheckChange,
                onClick: _cache[1] || (_cache[1] = withModifiers(
          () => {
            $setup.config.checkStrictly && $setup.strictlyEvent();
          }
        , ["stop"]))
              }, null, 8 /* PROPS */, ["modelValue", "indeterminate", "disabled", "onUpdate:modelValue"]))
            : ($setup.config.checkStrictly)
              ? (openBlock(), createBlock(_component_el_radio, {
                  key: 1,
                  modelValue: $setup.checkedValue,
                  label: $setup.value,
                  disabled: $setup.isDisabled,
                  onChange: $setup.handleCheckChange,
                  onClick: $setup.strictlyEvent
                }, {
                  default: withCtx(() => [
                    _hoisted_1$a
                  ]),
                  _: 1
                }, 8 /* PROPS */, ["modelValue", "label", "disabled", "onChange", "onClick"]))
              : ($setup.isLeaf && $setup.isChecked)
                ? (openBlock(), createBlock("i", _hoisted_2$5))
                : createCommentVNode("v-if", true)
        ], 64 /* STABLE_FRAGMENT */))
      : createCommentVNode("v-if", true),
    createVNode("span", _hoisted_3$3, [
      createVNode(_component_render_helper, { nodeLabel: $setup.nodeLabel }, null, 8 /* PROPS */, ["nodeLabel"])
    ]),
    ($setup.loading)
      ? (openBlock(), createBlock("i", _hoisted_4$2))
      : (!$setup.isLeaf)
        ? (openBlock(), createBlock("i", _hoisted_5$2))
        : createCommentVNode("v-if", true)
  ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["id", "aria-expanded", "tabindex"]))
}

script$n.render = render$l;
script$n.__file = "packages/cascader-panel/CascaderNode.vue";

function useLocale() {
  return function (...args) {
    const instance = getCurrentInstance();
    return t.apply(instance, args);
  };
}

var script$o = {
  name: 'ElCascaderMenu',
  components: {
    ElScrollbar,
    CascaderNode: script$n
  },
  props: {
    nodes: {
      type: Array,
      required: true
    },
    index: Number
  },

  setup(props) {
    const instance = getCurrentInstance();
    const t = useLocale();
    const {
      index,
      nodes
    } = toRefs(props);
    const {
      ctx
    } = instance;
    const panel = inject('panel');
    const hoverZone = ref(null);
    const data = {
      activeNode: null,
      hoverTimer: null,
      id: generateId()
    };
    const isEmpty = computed(() => !nodes.value.length);
    const menuId = `cascader-menu-${data.id}-${index.value}`;

    const clearHoverZone = () => {
      if (!hoverZone.value) return;
      hoverZone.value.innerHTML = '';
    };

    const handleExpand = e => {
      if (!panel.isHoverMenu) return;
      data.activeNode = e.target;
    };

    const handleMouseMove = e => {
      if (!panel.isHoverMenu) return;
      if (!data.activeNode || !hoverZone.value) return;

      if (data.activeNode.contains(e.target)) {
        clearTimeout(data.hoverTimer);
        const {
          left
        } = ctx.$el.getBoundingClientRect();
        const startX = e.clientX - left;
        const {
          offsetWidth,
          offsetHeight
        } = ctx.$el;
        const top = data.activeNode.offsetTop;
        const bottom = top + data.activeNode.offsetHeight;
        hoverZone.value.innerHTML = `
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${top} L${offsetWidth} 0 V${top} Z" />
          <path style="pointer-events: auto;" fill="transparent" d="M${startX} ${bottom} L${offsetWidth} ${offsetHeight} V${bottom} Z" />
        `;
      } else if (!data.hoverTimer) {
        data.hoverTimer = setTimeout(clearHoverZone, panel.config.hoverThreshold);
      }
    };

    return {
      // state
      data,
      isEmpty,
      menuId,
      hoverZone,
      panel,
      // methods
      t,
      handleExpand,
      handleMouseMove
    };
  }

};

const _hoisted_1$b = {
  key: 0,
  class: "el-cascader-menu__empty-text"
};
const _hoisted_2$6 = {
  key: 0,
  ref: "hoverZone",
  class: "el-cascader-menu__hover-zone"
};

function render$m(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_cascader_node = resolveComponent("cascader-node");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");

  return (openBlock(), createBlock(_component_el_scrollbar, {
    tag: "ul",
    role: "menu",
    id: $setup.menuId,
    class: "el-cascader-menu",
    "wrap-class": "el-cascader-menu__wrap",
    "view-class": {
      'el-cascader-menu__list': true,
      'is-empty': $setup.isEmpty
    },
    onMousemove: $setup.handleMouseMove
  }, {
    default: withCtx(() => [
      ($setup.isEmpty)
        ? (openBlock(), createBlock("div", _hoisted_1$b, toDisplayString($setup.t('el.cascader.noData')), 1 /* TEXT */))
        : (openBlock(), createBlock(Fragment, { key: 1 }, [
            (openBlock(true), createBlock(Fragment, null, renderList($props.nodes, (node, index) => {
              return (openBlock(), createBlock(_component_cascader_node, {
                key: node.uid,
                node: node,
                "node-id": `${$setup.menuId}-${index}`,
                "aria-haspopup": node.hasChildren,
                "aria-owns": node.hasChildren ? $setup.menuId : null,
                onExpand: $setup.handleExpand
              }, null, 8 /* PROPS */, ["node", "node-id", "aria-haspopup", "aria-owns", "onExpand"]))
            }), 128 /* KEYED_FRAGMENT */)),
            ($setup.panel.isHoverMenu)
              ? (openBlock(), createBlock("svg", _hoisted_2$6, null, 512 /* NEED_PATCH */))
              : createCommentVNode("v-if", true)
          ], 64 /* STABLE_FRAGMENT */))
    ]),
    _: 1
  }, 8 /* PROPS */, ["id", "view-class", "onMousemove"]))
}

script$o.render = render$m;
script$o.__file = "packages/cascader-panel/CascaderMenu.vue";

let uid = 0;
class Node$1 {
  constructor(data, config, parentNode) {
    this.data = data;
    this.config = config;
    this.parent = parentNode || null;
    this.level = !this.parent ? 1 : this.parent.level + 1;
    this.uid = uid++;
    this.initState();
    this.initChildren();
  }

  initState() {
    const {
      value: valueKey,
      label: labelKey
    } = this.config;
    this.value = this.data[valueKey];
    this.label = this.data[labelKey];
    this.pathNodes = this.calculatePathNodes();
    this.path = this.pathNodes.map(node => node.value);
    this.pathLabels = this.pathNodes.map(node => node.label); // lazy load

    this.loading = false;
    this.loaded = false;
  }

  initChildren() {
    const {
      config
    } = this;
    const childrenKey = config.children;
    const childrenData = this.data[childrenKey];
    this.hasChildren = Array.isArray(childrenData);
    this.children = (childrenData || []).map(child => new Node$1(child, config, this));
  }

  get isDisabled() {
    const {
      data,
      parent,
      config
    } = this;
    const disabledKey = config.disabled;
    const {
      checkStrictly
    } = config;
    return data[disabledKey] || !checkStrictly && parent && parent.isDisabled;
  }

  get isLeaf() {
    const {
      data,
      loaded,
      hasChildren,
      children
    } = this;
    const {
      lazy,
      leaf: leafKey
    } = this.config;

    if (lazy) {
      const isLeaf = isDef(data[leafKey]) ? data[leafKey] : loaded ? !children.length : false;
      this.hasChildren = !isLeaf;
      return isLeaf;
    }

    return !hasChildren;
  }

  calculatePathNodes() {
    const nodes = [this];
    let parent = this.parent;

    while (parent) {
      nodes.unshift(parent);
      parent = parent.parent;
    }

    return nodes;
  }

  getPath() {
    return this.path;
  }

  getValue() {
    return this.value;
  }

  getValueByOption() {
    return this.config.emitPath ? this.getPath() : this.getValue();
  }

  getText(allLevels, separator) {
    return allLevels ? this.pathLabels.join(separator) : this.label;
  }

  isSameNode(checkedValue) {
    const value = this.getValueByOption();
    return this.config.multiple && Array.isArray(checkedValue) ? checkedValue.some(val => isEqual(val, value)) : isEqual(checkedValue, value);
  }

  broadcast(event, ...args) {
    const handlerName = `onParent${capitalize(event)}`;
    this.children.forEach(child => {
      if (child) {
        // bottom up
        child.broadcast(event, ...args);
        child[handlerName] && child[handlerName](...args);
      }
    });
  }

  emit(event, ...args) {
    const {
      parent
    } = this;
    const handlerName = `onChild${capitalize(event)}`;

    if (parent) {
      parent[handlerName] && parent[handlerName](...args);
      parent.emit(event, ...args);
    }
  }

  onParentCheck(checked) {
    if (!this.isDisabled) {
      this.setCheckState(checked);
    }
  }

  onChildCheck() {
    const {
      children
    } = this;
    const validChildren = children.filter(child => !child.isDisabled);
    const checked = validChildren.length ? validChildren.every(child => child.checked) : false;
    this.setCheckState(checked);
  }

  setCheckState(checked) {
    const totalNum = this.children.length;
    const checkedNum = this.children.reduce((c, p) => {
      const num = p.checked ? 1 : p.indeterminate ? 0.5 : 0;
      return c + num;
    }, 0);
    this.checked = checked;
    this.indeterminate = checkedNum !== totalNum && checkedNum > 0;
  }

  syncCheckState(checkedValue) {
    const value = this.getValueByOption();
    const checked = this.isSameNode(checkedValue, value);
    this.doCheck(checked);
  }

  doCheck(checked) {
    if (this.checked !== checked) {
      if (this.config.checkStrictly) {
        this.checked = checked;
      } else {
        // bottom up to unify the calculation of the indeterminate state
        this.broadcast('check', checked);
        this.setCheckState(checked);
        this.emit('check');
      }
    }
  }

}

const flatNodes = (data, leafOnly) => {
  return data.reduce((res, node) => {
    if (node.isLeaf) {
      res.push(node);
    } else {
      !leafOnly && res.push(node);
      res = res.concat(flatNodes(node.children, leafOnly));
    }

    return res;
  }, []);
};

class Store {
  constructor(data, config) {
    this.config = config;
    this.initNodes(data);
  }

  initNodes(data) {
    data = coerceTruthyValueToArray(data);
    this.nodes = data.map(nodeData => new Node$1(nodeData, this.config));
    this.flattedNodes = this.getFlattedNodes(false, false);
    this.leafNodes = this.getFlattedNodes(true, false);
  }

  appendNode(nodeData, parentNode) {
    const node = new Node$1(nodeData, this.config, parentNode);
    const children = parentNode ? parentNode.children : this.nodes;
    children.push(node);
  }

  appendNodes(nodeDataList, parentNode) {
    nodeDataList = coerceTruthyValueToArray(nodeDataList);
    nodeDataList.forEach(nodeData => this.appendNode(nodeData, parentNode));
  }

  getNodes() {
    return this.nodes;
  }

  getFlattedNodes(leafOnly, cached = true) {
    const cachedNodes = leafOnly ? this.leafNodes : this.flattedNodes;
    return cached ? cachedNodes : flatNodes(this.nodes, leafOnly);
  }

  getNodeByValue(value) {
    if (value) {
      const nodes = this.getFlattedNodes(false, !this.config.lazy).filter(node => valueEquals(node.path, value) || node.value === value);
      return nodes && nodes.length ? nodes[0] : null;
    }

    return null;
  }

}

// eslint-disable-next-line no-use-before-define
var aria = aria || {};
aria.Utils = aria.Utils || {};
/**
 * @desc Set focus on descendant nodes until the first focusable element is
 *       found.
 * @param element
 *          DOM node for which to find the first focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */

aria.Utils.focusFirstDescendant = function (element) {
  for (var i = 0; i < element.childNodes.length; i++) {
    var child = element.childNodes[i];

    if (aria.Utils.attemptFocus(child) || aria.Utils.focusFirstDescendant(child)) {
      return true;
    }
  }

  return false;
};
/**
 * @desc Find the last descendant node that is focusable.
 * @param element
 *          DOM node for which to find the last focusable descendant.
 * @returns
 *  true if a focusable element is found and focus is set.
 */


aria.Utils.focusLastDescendant = function (element) {
  for (var i = element.childNodes.length - 1; i >= 0; i--) {
    var child = element.childNodes[i];

    if (aria.Utils.attemptFocus(child) || aria.Utils.focusLastDescendant(child)) {
      return true;
    }
  }

  return false;
};
/**
 * @desc Set Attempt to set focus on the current node.
 * @param element
 *          The node to attempt to focus on.
 * @returns
 *  true if element is focused.
 */


aria.Utils.attemptFocus = function (element) {
  if (!aria.Utils.isFocusable(element)) {
    return false;
  }

  aria.Utils.IgnoreUtilFocusChanges = true;

  if (element && element.focus) {
    element.focus();
  }

  aria.Utils.IgnoreUtilFocusChanges = false;
  return document.activeElement === element;
};

aria.Utils.isFocusable = function (element) {
  if (element.tabIndex > 0 || element.tabIndex === 0 && element.getAttribute('tabIndex') !== null) {
    return true;
  }

  if (element.disabled) {
    return false;
  }

  switch (element.nodeName) {
    case 'A':
      return !!element.href && element.rel !== 'ignore';

    case 'INPUT':
      return element.type !== 'hidden' && element.type !== 'file';

    case 'BUTTON':
    case 'SELECT':
    case 'TEXTAREA':
      return true;

    default:
      return false;
  }
};
/**
 * 触发一个事件
 * mouseenter, mouseleave, mouseover, keyup, change, click 等
 * @param  {Element} elm
 * @param  {String} name
 * @param  {*} opts
 */


aria.Utils.triggerEvent = function (elm, name, ...opts) {
  let eventName;

  if (/^mouse|click/.test(name)) {
    eventName = 'MouseEvents';
  } else if (/^key/.test(name)) {
    eventName = 'KeyboardEvent';
  } else {
    eventName = 'HTMLEvents';
  }

  const evt = document.createEvent(eventName);
  evt.initEvent(name, ...opts);
  elm.dispatchEvent ? elm.dispatchEvent(evt) : elm.fireEvent('on' + name, evt);
  return elm;
};

aria.Utils.keys = {
  tab: 9,
  enter: 13,
  space: 32,
  left: 37,
  up: 38,
  right: 39,
  down: 40,
  esc: 27
};
var Utils = aria.Utils;

const {
  keys: KeyCode
} = Utils;
const DefaultProps = {
  expandTrigger: 'click',
  // or hover
  multiple: false,
  checkStrictly: false,
  // whether all nodes can be selected
  emitPath: true,
  // wether to emit an array of all levels value in which node is located
  lazy: false,
  lazyLoad: noop,
  value: 'value',
  label: 'label',
  children: 'children',
  leaf: 'leaf',
  disabled: 'disabled',
  hoverThreshold: 500
};

const isLeaf = el => !el.getAttribute('aria-owns');

const getSibling = (el, distance) => {
  const {
    parentNode
  } = el;

  if (parentNode) {
    const siblings = parentNode.querySelectorAll('.el-cascader-node[tabindex="-1"]');
    const index = Array.prototype.indexOf.call(siblings, el);
    return siblings[index + distance] || null;
  }

  return null;
};

const getMenuIndex = el => {
  if (!el) return;
  const pieces = el.id.split('-');
  return Number(pieces[pieces.length - 2]);
};

const focusNode = el => {
  if (!el) return;
  el.focus();
  !isLeaf(el) && el.click();
};

const checkNode = el => {
  if (!el) return;
  const input = el.querySelector('input');

  if (input) {
    input.click();
  } else if (isLeaf(el)) {
    el.click();
  }
};

var script$p = {
  name: 'ElCascaderPanel',
  components: {
    CascaderMenu: script$o
  },
  emits: ['update:modelValue', 'change', 'close', 'active-item-change', 'expand-change'],
  props: {
    modelValue: {
      type: Object,
      default: () => {}
    },
    options: Array,
    props: Object,
    border: {
      type: Boolean,
      default: true
    },
    renderLabel: Function,
    computePresentText: Function
  },

  provide() {
    return {
      panel: this
    };
  },

  setup(props, {
    slots,
    emit
  }) {
    const menuRef = ref([]);
    const activePath = ref([]);
    const checkedNodePaths = ref([]);
    const loadCount = ref(0);
    const checkedValue = ref(null);
    const {
      props: realProps,
      options,
      renderLabel,
      modelValue
    } = toRefs(props);
    const renderLabelFn = computed(() => (renderLabel === null || renderLabel === void 0 ? void 0 : renderLabel.value) || (slots === null || slots === void 0 ? void 0 : slots.default));
    const {
      config,
      multiple,
      checkStrictly,
      leafOnly,
      isHoverMenu
    } = useConfig(realProps);
    let state = reactive({
      store: null,
      menus: null
    });

    const lazyLoad = (node, onFulfilled) => {
      if (!node) {
        node = {
          root: true,
          level: 0
        };
        state.store = new Store([], config.value);
        state.menus = [state.store.getNodes()];
      }

      node.loading = true;

      const resolve = dataList => {
        const parent = node.root ? null : node;
        dataList && dataList.length && state.store.appendNodes(dataList, parent);
        node.loading = false;
        node.loaded = true; // dispose default value on lazy load mode

        if (Array.isArray(checkedValue.value)) {
          const nodeValue = checkedValue.value[loadCount.value++];
          const valueKey = config.value.value;
          const leafKey = config.value.leaf;

          if (Array.isArray(dataList) && dataList.filter(item => item[valueKey] === nodeValue).length > 0) {
            const checkedNode = state.store.getNodeByValue(nodeValue);

            if (!checkedNode.data[leafKey]) {
              lazyLoad(checkedNode, () => {
                handleExpand(checkedNode);
              });
            }

            if (loadCount.value === checkedValue.value.length) {
              props.computePresentText();
            }
          }
        }

        onFulfilled && onFulfilled(dataList);
      };

      config.value.lazyLoad(node, resolve);
    };

    const getFlattedNodes = leafOnly => {
      const cached = !config.value.lazy;
      return state.store.getFlattedNodes(leafOnly, cached);
    };

    const {
      handleExpand,
      expandNodes,
      handleKeyDown
    } = useExpendMethods({
      menuRef,
      activePath,
      state,
      emit
    });

    const syncActivePath = () => {
      if (!isEmpty(activePath.value)) {
        const nodes = activePath.value.map(node => state.store.getNodeByValue(node.getValue()));
        expandNodes(nodes);
      } else if (!isEmpty(checkedValue.value)) {
        const value = multiple.value ? checkedValue.value[0] : checkedValue.value;
        const checkedNode = state.store.getNodeByValue(value) || {};
        const nodes = (checkedNode.pathNodes || []).slice(0, -1);
        expandNodes(nodes);
      } else {
        activePath.value = [];
        state.menus = [state.store.getNodes()];
      }
    };

    const changedScrollIntoView = () => {
      const menus = menuRef.value || [];
      menus.forEach(menu => {
        const menuElement = menu.$el;

        if (menuElement) {
          const container = menuElement.querySelector('.el-scrollbar__wrap');
          const activeNode = menuElement.querySelector('.el-cascader-node.is-active') || menuElement.querySelector('.el-cascader-node.in-active-path');
          scrollIntoView(container, activeNode);
        }
      });
    };

    const {
      syncMenuState,
      clearCheckedNodes,
      syncCheckedValue,
      getCheckedNodes,
      calculateCheckedNodePaths,
      calculateMultiCheckedValue
    } = useCheckedMethods({
      state,
      config,
      leafOnly,
      modelValue,
      multiple,
      checkedValue,
      checkedNodePaths,
      syncActivePath,
      scrollIntoView: changedScrollIntoView,
      getFlattedNodes
    });

    const handleCheckChange = value => {
      checkedValue.value = value;
    };

    onMounted(() => {
      if (!isEmpty(modelValue === null || modelValue === void 0 ? void 0 : modelValue.value)) {
        syncCheckedValue();
      }
    });
    onBeforeUpdate(() => {
      menuRef.value = [];
    });
    watch(options, () => {
      if (config.value.lazy && isEmpty(options.value)) {
        lazyLoad();
      } else {
        state.store = new Store(options.value, config.value);
        state.menus = [state.store.getNodes()];
        syncMenuState();
      }
    }, {
      immediate: true,
      deep: true
    });
    watch(modelValue, () => {
      syncCheckedValue();
      checkStrictly.value && calculateCheckedNodePaths();
    });
    watch(checkedValue, val => {
      if (!isEqual(val, modelValue === null || modelValue === void 0 ? void 0 : modelValue.value)) {
        checkStrictly.value && calculateCheckedNodePaths();
        emit('update:modelValue', val);
        emit('change', val);
      }
    });
    return {
      // state
      // ref
      menuRef,
      // data
      checkedValue,
      activePath,
      checkedNodePaths,
      menus: toRefs(state).menus,
      // computed
      config,
      multiple,
      checkStrictly,
      leafOnly,
      isHoverMenu,

      // methods
      getNodeByValue(val) {
        return state.store.getNodeByValue(val);
      },

      lazyLoad,
      getCheckedNodes,
      getFlattedNodes,
      handleCheckChange,
      handleExpand,
      renderLabelFn,
      handleKeyDown,
      clearCheckedNodes,
      calculateMultiCheckedValue,
      scrollIntoView: changedScrollIntoView
    };
  }

};

const useConfig = props => {
  const config = computed(() => merge({ ...DefaultProps
  }, props === null || props === void 0 ? void 0 : props.value));
  const multiple = computed(() => config.value.multiple);
  const checkStrictly = computed(() => config.value.checkStrictly);
  const leafOnly = computed(() => !checkStrictly.value);
  const isHoverMenu = computed(() => config.value.expandTrigger === 'trigger');
  return {
    config,
    multiple,
    checkStrictly,
    leafOnly,
    isHoverMenu
  };
};

const useExpendMethods = ({
  menuRef,
  activePath,
  state,
  emit
}) => {
  const handleExpand = (node, silent) => {
    const activePathValue = activePath.value;
    const {
      level
    } = node;
    const path = activePathValue.slice(0, level - 1);
    const internalMenus = [...state.menus].slice(0, level);

    if (!node.isLeaf) {
      path.push(node);
      internalMenus.push(node.children);
    }

    activePath.value = path;
    state.menus = internalMenus;

    if (!silent) {
      const pathValues = path.map(node => node.getValue());
      const activePathValues = activePath.value.map(node => node.getValue());

      if (!valueEquals(pathValues, activePathValues)) {
        emit('active-item-change', pathValues);
        emit('expand-change', pathValues);
      }
    }
  };

  const expandNodes = nodes => {
    nodes.forEach(node => handleExpand(node, true));
  };

  const handleKeyDown = ({
    target,
    keyCode
  }) => {
    const prev = getSibling(target, -1);
    const next = getSibling(target, 1);
    const preMenu = menuRef.value[getMenuIndex(target) - 1];
    const nextMenu = menuRef.value[getMenuIndex(target) + 1];

    switch (keyCode) {
      case KeyCode.up:
        focusNode(prev);
        break;

      case KeyCode.down:
        focusNode(next);
        break;

      case KeyCode.left:
        if (preMenu) {
          const expandedNode = preMenu.$el.querySelector('.el-cascader-node[aria-expanded="true"]');
          focusNode(expandedNode);
        }

        break;

      case KeyCode.right:
        if (nextMenu) {
          const firstNode = nextMenu.$el.querySelector('.el-cascader-node[tabindex="-1"]');
          focusNode(firstNode);
        }

        break;

      case KeyCode.enter:
        checkNode(target);
        break;

      case KeyCode.esc:
      case KeyCode.tab:
        emit('close');
        break;

      default:
        return;
    }
  };

  return {
    handleExpand,
    expandNodes,
    handleKeyDown
  };
};

const useCheckedMethods = ({
  state,
  config,
  leafOnly,
  modelValue,
  checkedValue,
  checkedNodePaths,
  syncActivePath,
  scrollIntoView,
  getFlattedNodes
}) => {
  const syncMultiCheckState = () => {
    const nodes = getFlattedNodes(leafOnly.value);
    nodes.forEach(node => {
      node.syncCheckState(checkedValue.value);
    });
  };

  const syncMenuState = async () => {
    syncActivePath();
    config.value.multiple && syncMultiCheckState();
    config.value.checkStrictly && calculateCheckedNodePaths();
    await nextTick(scrollIntoView);
  };

  const syncCheckedValue = () => {
    if (!isEqual(modelValue.value, checkedValue.value)) {
      checkedValue.value = modelValue.value;
      syncMenuState();
    }
  };

  const calculateCheckedNodePaths = () => {
    const checkedValues = config.value.multiple ? coerceTruthyValueToArray(checkedValue.value) : [checkedValue.value];
    checkedNodePaths.value = checkedValues.map(v => {
      var _state$store$getNodeB;

      return ((_state$store$getNodeB = state.store.getNodeByValue(v)) === null || _state$store$getNodeB === void 0 ? void 0 : _state$store$getNodeB.pathNodes) || [];
    });
  };

  const getCheckedNodes = leafOnly => {
    if (config.value.multiple) {
      const nodes = getFlattedNodes(leafOnly);
      return nodes.filter(node => node.checked);
    } else {
      return isEmpty(checkedValue.value) ? [] : [state.store.getNodeByValue(checkedValue.value)];
    }
  };

  const calculateMultiCheckedValue = () => {
    checkedValue.value = getCheckedNodes(leafOnly.value).map(node => node.getValueByOption());
  };

  const clearCheckedNodes = () => {
    if (config.value.multiple) {
      getCheckedNodes(leafOnly.value).filter(node => !node.isDisabled).forEach(node => node.doCheck(false));
      calculateMultiCheckedValue();
    } else {
      checkedValue.value = config.value.emitPath ? [] : null;
    }
  };

  return {
    syncMenuState,
    getCheckedNodes,
    syncCheckedValue,
    clearCheckedNodes,
    calculateCheckedNodePaths,
    calculateMultiCheckedValue
  };
};

function render$n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_cascader_menu = resolveComponent("cascader-menu");

  return (openBlock(), createBlock("div", {
    class: ['el-cascader-panel', $props.border && 'is-bordered'],
    onKeydown: _cache[1] || (_cache[1] = (...args) => ($setup.handleKeyDown(...args)))
  }, [
    (openBlock(true), createBlock(Fragment, null, renderList($setup.menus, (menu, index) => {
      return (openBlock(), createBlock(_component_cascader_menu, {
        ref: 
        (el) => {
          if (el) $setup.menuRef[index] = el;
        }
      ,
        index: index,
        key: index,
        nodes: menu
      }, null, 8 /* PROPS */, ["index", "nodes"]))
    }), 128 /* KEYED_FRAGMENT */))
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$p.render = render$n;
script$p.__file = "packages/cascader-panel/CascaderPanel.vue";

/* istanbul ignore next */

script$p.install = function (app) {
  app.component(script$p.name, script$p);
};

const {
  keys: KeyCode$1
} = Utils;
const MigratingProps = {
  expandTrigger: {
    newProp: 'expandTrigger',
    type: String
  },
  changeOnSelect: {
    newProp: 'checkStrictly',
    type: Boolean
  },
  hoverThreshold: {
    newProp: 'hoverThreshold',
    type: Number
  }
};
const PopperMixin = {
  props: {
    placement: {
      type: String,
      default: 'bottom-start'
    },
    appendToBody: Popper$1.props.appendToBody,
    visibleArrow: {
      type: Boolean,
      default: true
    },
    arrowOffset: Popper$1.props.arrowOffset,
    offset: Popper$1.props.offset,
    boundariesPadding: Popper$1.props.boundariesPadding,
    popperOptions: Popper$1.props.popperOptions
  },
  methods: Popper$1.methods,
  data: Popper$1.data,
  beforeUnmount: Popper$1.beforeUnmount
};
const InputSizeMap = {
  medium: 36,
  small: 32,
  mini: 28
};
var script$q = {
  name: 'ElCascader',
  directives: {
    Clickoutside
  },
  components: {
    ElInput: script$g,
    ElTag: script$k,
    ElScrollbar,
    ElCascaderPanel: script$p
  },
  mixins: [PopperMixin],
  emits: ['update:modelValue', 'change', 'expand-change', 'active-item-change', 'visible-change', 'focus', 'blur', 'created', 'remove-tag'],
  props: {
    modelValue: {},
    options: {
      type: Array,
      default: () => []
    },
    props: Object,
    size: String,
    placeholder: {
      type: String,
      default: () => t('el.cascader.placeholder')
    },
    disabled: {
      type: Boolean,
      default: false
    },
    clearable: Boolean,
    filterable: Boolean,
    filterMethod: {
      type: Function,
      default: undefined
    },
    separator: {
      type: String,
      default: ' / '
    },
    showAllLevels: {
      type: Boolean,
      default: true
    },
    collapseTags: Boolean,
    debounce: {
      type: Number,
      default: 300
    },
    beforeFilter: {
      type: Function,
      default: () => () => {}
    },
    popperClass: String
  },

  setup(props, {
    emit,
    attrs
  }) {
    const instance = getCurrentInstance();
    const {
      dispatch
    } = useEmitter();
    const {
      props: realProps,
      modelValue,
      options,
      filterable,
      size,
      disabled,
      clearable,
      filterMethod,
      showAllLevels,
      separator,
      collapseTags,
      debounce: debounceProp,
      beforeFilter
    } = toRefs(props);
    const t = useLocale();
    migrating({
      'expand-trigger': 'expand-trigger is removed, use `props.expandTrigger` instead.',
      'change-on-select': 'change-on-select is removed, use `props.checkStrictly` instead.',
      'hover-threshold': 'hover-threshold is removed, use `props.hoverThreshold` instead',
      'active-item-change': 'active-item-change is renamed to expand-change'
    });
    const panel = ref(null);
    const input = ref(null);
    const popper = ref(null);
    const suggestionPanel = ref(null);
    const filterHandler = ref(null);
    const filtering = ref(false);
    const pressDeleteCount = ref(0);
    const inputState = reactive({
      hover: false,
      value: null,
      initialHeight: 0
    });
    const checkedState = reactive({
      value: (modelValue === null || modelValue === void 0 ? void 0 : modelValue.value) || null,
      nodes: []
    });
    const elForm = inject('elForm', {});
    const elFormItem = inject('elFormItem', {});
    const isDisabled = computed(() => disabled.value || (elForm === null || elForm === void 0 ? void 0 : elForm.disabled));
    const {
      dropDownVisible,
      toggleDropDownVisible
    } = useDropdownVisible({
      input,
      panel,
      isDisabled,
      emit
    });
    const {
      config,
      multiple,
      leafOnly,
      readonly,
      checkStrictly
    } = useConfig$1({
      props: realProps,
      attrs,
      filterable
    });
    const {
      presentState,
      computePresentText,
      computePresentContent
    } = usePresent({
      panel,
      checkedState,
      checkStrictly,
      isDisabled,
      leafOnly,
      showAllLevels,
      separator,
      collapseTags,
      multiple
    });
    const {
      suggestions,
      getSuggestions,
      handleSuggestionClick
    } = useSuggestion({
      panel,
      inputState,
      presentState,
      checkedState,
      filterMethod,
      filtering,
      multiple,
      leafOnly,
      showAllLevels,
      separator,
      toggleDropDownVisible
    });
    const {
      realSize,
      tagSize
    } = useSize$1({
      size,
      elFormItem
    });
    const internalValue = computed({
      get() {
        return (multiple === null || multiple === void 0 ? void 0 : multiple.value) ? presentState.text : inputState.value;
      },

      set(v) {
        (multiple === null || multiple === void 0 ? void 0 : multiple.value) ? presentState.text = v : inputState.value = v;
      }

    });
    const clearBtnVisible = computed(() => {
      if (!clearable.value || isDisabled.value || filtering.value || !inputState.hover) {
        return false;
      }

      return (multiple === null || multiple === void 0 ? void 0 : multiple.value) ? !!checkedState.nodes.filter(node => !node.isDisabled).length : !!presentState.text;
    });

    const handleFocus = e => {
      emit('focus', e);
    };

    const handleBlur = e => {
      emit('blur', e);
    };

    const focusFirstNode = () => {
      nextTick(() => {
        let firstNode = null;

        if (filtering.value && suggestionPanel.value) {
          firstNode = suggestionPanel.value.$el.querySelector('.el-cascader__suggestion-item');
        } else {
          const firstMenu = popper.value.querySelector('.el-cascader-menu');
          firstNode = firstMenu.querySelector('.el-cascader-node[tabindex="-1"]');
        }

        if (firstNode) {
          firstNode.focus();
          !filtering.value && firstNode.click();
        }
      });
    };

    const handleInput = (val, event) => {
      !dropDownVisible.value && toggleDropDownVisible(true);
      if (event && event.isComposing) return;

      if (val) {
        var _filterHandler$value;

        (_filterHandler$value = filterHandler.value) === null || _filterHandler$value === void 0 ? void 0 : _filterHandler$value.call(filterHandler);
      } else {
        filtering.value = false;
      }
    };

    const handleDropdownLeave = () => {
      filtering.value = false;
      inputState.value = presentState.text;
    };

    const handleClear = () => {
      presentState.text = '';
      panel.value.clearCheckedNodes();
    };

    const handleDelete = () => {
      const lastIndex = presentState.tags.length - 1;
      const lastTag = presentState.tags[lastIndex];
      pressDeleteCount.value = inputState.value ? 0 : pressDeleteCount.value++;
      if (!lastTag) return;

      if (pressDeleteCount.value) {
        if (lastTag.hitState) {
          deleteTag(lastIndex);
        } else {
          lastTag.hitState = true;
        }
      }
    };

    const handleExpandChange = value => {
      nextTick(instance.ctx.updatePopper.bind(instance.ctx));
      emit('expand-change', value);
      emit('active-item-change', value);
    };

    const handleKeyDown = event => {
      switch (event.keyCode) {
        case KeyCode$1.enter:
          toggleDropDownVisible();
          break;

        case KeyCode$1.down:
          toggleDropDownVisible(true);
          focusFirstNode();
          event.preventDefault();
          break;

        case KeyCode$1.esc:
        case KeyCode$1.tab:
          toggleDropDownVisible(false);
          break;
      }
    };

    const handleSuggestionKeyDown = event => {
      const {
        keyCode,
        target
      } = event;
      const prev = target.previousElementSibling;
      const next = target.nextElementSibling;

      switch (keyCode) {
        case KeyCode$1.enter:
          target.click();
          break;

        case KeyCode$1.up:
          prev && prev.focus();
          break;

        case KeyCode$1.down:
          next && next.focus();
          break;

        case KeyCode$1.esc:
        case KeyCode$1.tab:
          toggleDropDownVisible(false);
          break;
      }
    };

    const updateStyle = () => {
      const {
        $el
      } = instance.ctx;
      if (!$el) return;
      const inputInner = $el.querySelector('.el-input__inner');
      if (!inputInner) return;
      const tags = $el.querySelector('.el-cascader__tags');
      let suggestionPanelEl = null;

      if (suggestionPanel.value && (suggestionPanelEl = suggestionPanel.value.$el)) {
        const suggestionList = suggestionPanelEl.querySelector('.el-cascader__suggestion-list');
        suggestionList.style.minWidth = inputInner.offsetWidth + 'px';
      }

      if (tags) {
        nextTick(() => {
          const {
            offsetHeight
          } = tags;
          inputInner.style.height = Math.max(offsetHeight + 6, inputState.initialHeight) + 'px';
          instance.ctx.updatePopper();
        });
      }
    };

    const deleteTag = index => {
      const val = checkedState.value[index];
      checkedState.value = checkedState.value.filter((item, i) => i !== index);
      emit('remove-tag', val);
    };

    onMounted(() => {
      var _input$value;

      if (input === null || input === void 0 ? void 0 : (_input$value = input.value) === null || _input$value === void 0 ? void 0 : _input$value.$el) {
        inputState.initialHeight = input.value.$el.offsetHeight || InputSizeMap[realSize.value] || 40;
      }

      if (!isEmpty(modelValue === null || modelValue === void 0 ? void 0 : modelValue.value)) {
        computePresentContent();
      }

      filterHandler.value = debounce(debounceProp, () => {
        if (!inputState.value) {
          filtering.value = false;
          return;
        }

        const before = beforeFilter.value(inputState.value);

        if (before === null || before === void 0 ? void 0 : before.then) {
          before.then(getSuggestions);
        } else if (before !== false) {
          getSuggestions();
        } else {
          filtering.value = false;
        }
      });
      addResizeListener(instance.ctx.$el, updateStyle);
    });
    onUnmounted(() => {
      removeResizeListener(instance.ctx.$el, updateStyle);
    });
    watch(disabled, () => {
      computePresentContent();
    });

    if (modelValue) {
      watch(modelValue, val => {
        if (!isEqual(val, checkedState.value)) {
          checkedState.value = val;
          computePresentContent();
        }
      });
    }

    watch(() => checkedState.value, val => {
      if (!isEqual(val, modelValue === null || modelValue === void 0 ? void 0 : modelValue.value) || (modelValue === null || modelValue === void 0 ? void 0 : modelValue.value) === void 0) {
        computePresentContent(); // hide dropdown when single mode

        if (!(multiple === null || multiple === void 0 ? void 0 : multiple.value) && !checkStrictly.value && dropDownVisible.value) {
          toggleDropDownVisible(false);
        }

        emit('update:modelValue', val);
        emit('change', val);
        dispatch('ElFormItem', 'el.form.change', [val]);
      }
    });
    watch(options, () => {
      nextTick(computePresentContent);
    }, {
      deep: true
    });
    watch(presentState, value => {
      inputState.value = value.text;

      if ((multiple === null || multiple === void 0 ? void 0 : multiple.value) && (value.tags.length || presentState.tags.length)) {
        nextTick(updateStyle);
      }
    });
    watch(filtering, () => {
      nextTick(instance.ctx.updatePopper);
    });
    return {
      // state
      // ref
      panel,
      input,
      popper,
      suggestionPanel,
      // data
      inputState,
      checkedState,
      presentState,
      suggestions,
      filtering,
      dropDownVisible,
      // computed
      internalValue,
      clearBtnVisible,
      config,
      multiple,
      readonly,
      isDisabled,
      realSize,
      tagSize,
      // methods
      t,
      deleteTag,
      handleFocus,
      handleBlur,
      handleInput,
      handleDropdownLeave,
      handleClear,
      handleDelete,
      handleExpandChange,
      handleKeyDown,
      handleSuggestionKeyDown,
      handleSuggestionClick,
      computePresentText,
      toggleDropDownVisible,

      getCheckedNodes(leafOnly) {
        var _panel$value;

        return panel === null || panel === void 0 ? void 0 : (_panel$value = panel.value) === null || _panel$value === void 0 ? void 0 : _panel$value.getCheckedNodes(leafOnly);
      }

    };
  }

};

const useSize$1 = ({
  size,
  elFormItem
}) => {
  const {
    ctx
  } = getCurrentInstance();
  const realSize = computed(() => {
    var _ctx$$ELEMENT;

    const _elFormItemSize = elFormItem === null || elFormItem === void 0 ? void 0 : elFormItem.elFormItemSize;

    return (size === null || size === void 0 ? void 0 : size.value) || _elFormItemSize || ((_ctx$$ELEMENT = ctx.$ELEMENT) === null || _ctx$$ELEMENT === void 0 ? void 0 : _ctx$$ELEMENT.size);
  });
  const tagSize = computed(() => {
    return ['small', 'mini'].indexOf(realSize.value) > -1 ? 'mini' : 'small';
  });
  return {
    realSize,
    tagSize
  };
};

const useConfig$1 = ({
  props,
  attrs,
  filterable
}) => {
  const config = computed(() => {
    const config = (props === null || props === void 0 ? void 0 : props.value) || {};
    Object.keys(MigratingProps).forEach(oldProp => {
      const {
        newProp,
        type
      } = MigratingProps[oldProp];
      let oldValue = attrs[oldProp] || attrs[kebabCase(oldProp)];

      if (isDef(oldProp) && !isDef(config[newProp])) {
        if (type === Boolean && oldValue === '') {
          oldValue = true;
        }

        config[newProp] = oldValue;
      }
    });
    return config;
  });
  const multiple = computed(() => config.value.multiple);
  const checkStrictly = computed(() => config.value.checkStrictly);
  const leafOnly = computed(() => !checkStrictly.value);
  const readonly = computed(() => !filterable.value || (multiple === null || multiple === void 0 ? void 0 : multiple.value));
  return {
    config,
    checkStrictly,
    multiple,
    leafOnly,
    readonly
  };
};

const useDropdownVisible = ({
  input,
  panel,
  isDisabled,
  emit
}) => {
  const instance = getCurrentInstance();
  const dropDownVisible = ref(false);

  const toggleDropDownVisible = visible => {
    if (isDisabled.value) return;
    visible = isDef(visible) ? visible : !dropDownVisible.value;

    if (visible !== dropDownVisible.value) {
      dropDownVisible.value = visible;

      if (visible) {
        nextTick(() => {
          instance.ctx.updatePopper();
          panel.value.scrollIntoView();
        });
      }

      input === null || input === void 0 ? void 0 : input.value.$refs.input.setAttribute('aria-expanded', visible);
      emit('visible-change', visible);
    }
  };

  return {
    dropDownVisible,
    toggleDropDownVisible
  };
};

const useSuggestion = ({
  panel,
  inputState,
  presentState,
  checkedState,
  filterMethod,
  filtering,
  multiple,
  leafOnly,
  showAllLevels,
  separator,
  toggleDropDownVisible
}) => {
  const instance = getCurrentInstance();
  const suggestions = ref([]);

  const getSuggestions = () => {
    let internalFilterMethod = filterMethod.value;

    if (!(internalFilterMethod instanceof Function)) {
      internalFilterMethod = (node, keyword) => node.text.includes(keyword);
    }

    const internalSuggestions = panel.value.getFlattedNodes(leafOnly.value).filter(node => {
      if (node.isDisabled) return false;
      node.text = node.getText(showAllLevels.value, separator.value) || '';
      return internalFilterMethod(node, inputState.value);
    });

    if (multiple) {
      presentState.tags.forEach(tag => {
        tag.hitState = false;
      });
    } else {
      internalSuggestions.forEach(node => {
        node.checked = isEqual(checkedState.value, node.getValueByOption());
      });
    }

    filtering.value = true;
    suggestions.value = internalSuggestions;
    nextTick(instance.ctx.updatePopper);
  };

  const handleSuggestionClick = index => {
    const targetNode = suggestions.value[index];

    if (multiple === null || multiple === void 0 ? void 0 : multiple.value) {
      const {
        checked
      } = targetNode;
      targetNode.doCheck(!checked);
      panel.value.calculateMultiCheckedValue();
    } else {
      checkedState.value = targetNode.getValueByOption();
      toggleDropDownVisible(false);
    }
  };

  return {
    suggestions,
    getSuggestions,
    handleSuggestionClick
  };
};

const usePresent = ({
  panel,
  checkedState,
  checkStrictly,
  isDisabled,
  leafOnly,
  showAllLevels,
  separator,
  collapseTags,
  multiple
}) => {
  const presentState = reactive({
    text: null,
    tags: []
  });

  const computePresentTags = () => {
    const checkedNodes = panel.value.getCheckedNodes(leafOnly.value);
    const tags = [];

    const genTag = node => ({
      node,
      key: node.uid,
      text: node.getText(showAllLevels.value, separator.value),
      hitState: false,
      closable: !isDisabled.value && !node.isDisabled
    });

    if (checkedNodes.length) {
      const [first, ...rest] = checkedNodes;
      const restCount = rest.length;
      tags.push(genTag(first));

      if (restCount) {
        if (collapseTags.value) {
          tags.push({
            key: -1,
            text: `+ ${restCount}`,
            closable: false
          });
        } else {
          rest.forEach(node => tags.push(genTag(node)));
        }
      }
    }

    checkedState.nodes = checkedNodes;
    presentState.tags = tags;
  };

  const computePresentText = () => {
    if (!isEmpty(checkedState.value)) {
      const node = panel.value.getNodeByValue(checkedState.value);

      if (node && (checkStrictly.value || node.isLeaf)) {
        presentState.text = node.getText(showAllLevels.value, separator.value);
        return;
      }
    }

    presentState.text = null;
  };

  const computePresentContent = () => {
    // nextTick is required, because checked nodes may not change right now
    nextTick(() => {
      if (multiple === null || multiple === void 0 ? void 0 : multiple.value) {
        computePresentTags();
        presentState.text = presentState.tags.length ? ' ' : null;
      } else {
        computePresentText();
      }
    });
  };

  return {
    presentState,
    computePresentContent,
    computePresentText,
    computePresentTags
  };
};

const _hoisted_1$c = {
  key: 0,
  class: "el-cascader__tags"
};
const _hoisted_2$7 = {
  key: 0,
  class: "el-icon-check"
};
const _hoisted_3$4 = { class: "el-cascader__empty-text" };

function render$o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_tag = resolveComponent("el-tag");
  const _component_el_cascader_panel = resolveComponent("el-cascader-panel");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _directive_clickoutside = resolveDirective("clickoutside");

  return withDirectives((openBlock(), createBlock("div", {
    ref: "reference",
    class: [
      'el-cascader',
      $setup.realSize && `el-cascader--${$setup.realSize}`,
      { 'is-disabled': $setup.isDisabled }
    ],
    onMouseenter: _cache[10] || (_cache[10] = $event => ($setup.inputState.hover = true)),
    onMouseleave: _cache[11] || (_cache[11] = $event => ($setup.inputState.hover = false)),
    onClick: _cache[12] || (_cache[12] = () => $setup.toggleDropDownVisible($setup.readonly ? undefined : true)),
    onKeydown: _cache[13] || (_cache[13] = (...args) => ($setup.handleKeyDown(...args)))
  }, [
    createVNode(_component_el_input, {
      ref: "input",
      modelValue: $setup.internalValue,
      "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ($setup.internalValue = $event)),
      size: $setup.realSize,
      placeholder: $props.placeholder,
      readonly: $setup.readonly,
      disabled: $setup.isDisabled,
      "validate-event": false,
      class: { 'is-focus': $setup.dropDownVisible },
      onFocus: $setup.handleFocus,
      onBlur: $setup.handleBlur,
      onInput: $setup.handleInput
    }, {
      suffix: withCtx(() => [
        ($setup.clearBtnVisible)
          ? (openBlock(), createBlock("i", {
              key: 0,
              class: "el-input__icon el-icon-circle-close",
              onClick: _cache[1] || (_cache[1] = withModifiers((...args) => ($setup.handleClear(...args)), ["stop"]))
            }))
          : (openBlock(), createBlock("i", {
              key: 1,
              class: [
            'el-input__icon',
            'el-icon-arrow-down',
            $setup.dropDownVisible && 'is-reverse'
          ],
              onClick: _cache[2] || (_cache[2] = withModifiers($event => ($setup.toggleDropDownVisible(undefined)), ["stop"]))
            }, null, 2 /* CLASS */))
      ]),
      _: 1
    }, 8 /* PROPS */, ["modelValue", "size", "placeholder", "readonly", "disabled", "class", "onFocus", "onBlur", "onInput"]),
    ($setup.multiple)
      ? (openBlock(), createBlock("div", _hoisted_1$c, [
          (openBlock(true), createBlock(Fragment, null, renderList($setup.presentState.tags, (tag, index) => {
            return (openBlock(), createBlock(_component_el_tag, {
              key: tag.key,
              type: "info",
              size: $setup.tagSize,
              hit: tag.hitState,
              closable: tag.closable,
              "disable-transitions": "",
              onClose: $event => ($setup.deleteTag(index))
            }, {
              default: withCtx(() => [
                createVNode("span", null, toDisplayString(tag.text), 1 /* TEXT */)
              ]),
              _: 2
            }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["size", "hit", "closable", "onClose"]))
          }), 128 /* KEYED_FRAGMENT */)),
          ($props.filterable && !$setup.isDisabled)
            ? withDirectives((openBlock(), createBlock("input", {
                key: 0,
                "onUpdate:modelValue": _cache[4] || (_cache[4] = $event => ($setup.inputState.value = $event)),
                type: "text",
                class: "el-cascader__search-input",
                placeholder: $setup.presentState.tags.length ? '' : $props.placeholder,
                onInput: _cache[5] || (_cache[5] = (e) => $setup.handleInput($setup.inputState.value, e)),
                onClick: _cache[6] || (_cache[6] = withModifiers($event => ($setup.toggleDropDownVisible(true)), ["stop"])),
                onKeydown: _cache[7] || (_cache[7] = withKeys((...args) => ($setup.handleDelete(...args)), ["delete"]))
              }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["placeholder"])), [
                [
                  vModelText,
                  $setup.inputState.value,
                  void 0,
                  { trim: true }
                ]
              ])
            : createCommentVNode("v-if", true)
        ]))
      : createCommentVNode("v-if", true),
    createVNode(Transition, {
      name: "el-zoom-in-top",
      onAfterLeave: $setup.handleDropdownLeave
    }, {
      default: withCtx(() => [
        withDirectives(createVNode("div", {
          ref: "popper",
          class: ['el-popper', 'el-cascader__dropdown', $props.popperClass]
        }, [
          withDirectives(createVNode(_component_el_cascader_panel, {
            ref: "panel",
            modelValue: $setup.checkedState.value,
            "onUpdate:modelValue": _cache[8] || (_cache[8] = $event => ($setup.checkedState.value = $event)),
            options: $props.options,
            props: $setup.config,
            border: false,
            "render-label": _ctx.$slots.default,
            onExpandChange: $setup.handleExpandChange,
            onClose: _cache[9] || (_cache[9] = $event => ($setup.toggleDropDownVisible(false))),
            computePresentText: $setup.computePresentText
          }, null, 8 /* PROPS */, ["modelValue", "options", "props", "render-label", "onExpandChange", "computePresentText"]), [
            [vShow, !$setup.filtering]
          ]),
          ($props.filterable)
            ? withDirectives((openBlock(), createBlock(_component_el_scrollbar, {
                key: 0,
                ref: "suggestionPanel",
                tag: "ul",
                class: "el-cascader__suggestion-panel",
                "view-class": "el-cascader__suggestion-list",
                onKeydown: $setup.handleSuggestionKeyDown
              }, {
                default: withCtx(() => [
                  ($setup.suggestions.length)
                    ? (openBlock(true), createBlock(Fragment, { key: 0 }, renderList($setup.suggestions, (item, index) => {
                        return (openBlock(), createBlock("li", {
                          key: item.uid,
                          class: [
                'el-cascader__suggestion-item',
                item.checked && 'is-checked'
              ],
                          tabindex: -1,
                          onClick: $event => ($setup.handleSuggestionClick(index))
                        }, [
                          createVNode("span", null, toDisplayString(item.text), 1 /* TEXT */),
                          (item.checked)
                            ? (openBlock(), createBlock("i", _hoisted_2$7))
                            : createCommentVNode("v-if", true)
                        ], 10 /* CLASS, PROPS */, ["onClick"]))
                      }), 128 /* KEYED_FRAGMENT */))
                    : renderSlot(_ctx.$slots, "empty", { key: 1 }, () => [
                        createVNode("li", _hoisted_3$4, toDisplayString($setup.t('el.cascader.noMatch')), 1 /* TEXT */)
                      ])
                ]),
                _: 1
              }, 8 /* PROPS */, ["onKeydown"])), [
                [vShow, $setup.filtering]
              ])
            : createCommentVNode("v-if", true)
        ], 2 /* CLASS */), [
          [vShow, $setup.dropDownVisible]
        ])
      ]),
      _: 1
    }, 8 /* PROPS */, ["onAfterLeave"])
  ], 34 /* CLASS, HYDRATE_EVENTS */)), [
    [_directive_clickoutside, () => $setup.toggleDropDownVisible(false)]
  ])
}

script$q.render = render$o;
script$q.__file = "packages/cascader/Cascader.vue";

/* istanbul ignore next */

script$q.install = function (app) {
  app.component(script$q.name, script$q);
};

var script$r = {
  props: {
    type: {
      type: String
    },
    active: {
      type: Boolean,
      default: false
    },
    text: {
      type: String,
      default: ''
    },
    iconClass: {
      type: String,
      default: ''
    }
  }
};

const _hoisted_1$d = { key: 0 };

function render$p(_ctx, _cache, $props, $setup, $data, $options) {
  return ($props.iconClass || $props.text)
    ? (openBlock(), createBlock("span", {
        key: 0,
        class: {
      'el-switch__label': true,
      'is-active': $props.active,
      [`el-switch__label--${$props.type}`]: true
    }
      }, [
        createVNode("i", {
          class: [$props.iconClass]
        }, null, 2 /* CLASS */),
        (!$props.iconClass)
          ? (openBlock(), createBlock("span", _hoisted_1$d, toDisplayString($props.text), 1 /* TEXT */))
          : createCommentVNode("v-if", true)
      ], 2 /* CLASS */))
    : createCommentVNode("v-if", true)
}

script$r.render = render$p;
script$r.__file = "packages/switch/SwitchLabel.vue";

var script$s = {
  name: 'ElSwitch',
  components: {
    SwitchLabel: script$r
  },
  props: {
    modelValue: {
      type: [Boolean, String, Number],
      default: false
    },
    activeValue: {
      type: [Boolean, String, Number],
      default: true
    },
    inactiveValue: {
      type: [Boolean, String, Number],
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 40
    },
    activeText: String,
    inactiveText: String,
    activeIconClass: {
      type: String,
      default: ''
    },
    inactiveIconClass: {
      type: String,
      default: ''
    },
    activeColor: {
      type: String,
      default: ''
    },
    inactiveColor: {
      type: String,
      default: ''
    }
  },
  emits: ['update:modelValue', 'change'],

  setup(props, {
    emit
  }) {
    const {
      activeValue,
      inactiveValue,
      modelValue,
      disabled,
      activeColor,
      inactiveColor
    } = toRefs(props);
    useNormalizeModelValue({
      modelValue,
      activeValue,
      inactiveValue,
      emit
    });
    const isChecked = computed(() => {
      return modelValue.value === activeValue.value;
    });
    const backgroundColor = computed(() => {
      return isChecked.value ? activeColor.value : inactiveColor.value;
    });
    const {
      handleClick
    } = useClick({
      isChecked,
      inactiveValue,
      activeValue,
      disabled,
      emit
    });
    return {
      isChecked,
      backgroundColor,
      handleClick
    };
  }

};

const useNormalizeModelValue = ({
  modelValue,
  activeValue,
  inactiveValue,
  emit
}) => {
  onMounted(() => {
    if (modelValue.value !== activeValue.value && modelValue.value !== inactiveValue.value) {
      emit('update:modelValue', inactiveValue.value);
    }
  });
};

const useClick = ({
  isChecked,
  inactiveValue,
  activeValue,
  disabled,
  emit
}) => {
  const getNewValue = () => {
    return isChecked.value ? inactiveValue.value : activeValue.value;
  };

  const handleClick = () => {
    if (disabled.value) return;
    const newValue = getNewValue();
    emit('update:modelValue', newValue);
    emit('change', newValue);
  };

  return {
    handleClick
  };
};

function render$q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_SwitchLabel = resolveComponent("SwitchLabel");

  return (openBlock(), createBlock("div", {
    class: ["el-switch", { 'is-checked': $setup.isChecked, 'is-disabled': $props.disabled }],
    onClick: _cache[1] || (_cache[1] = withModifiers((...args) => ($setup.handleClick(...args)), ["prevent"]))
  }, [
    createVNode(_component_SwitchLabel, {
      active: !$setup.isChecked,
      type: "left",
      text: $props.inactiveText,
      iconClass: $props.inactiveIconClass
    }, null, 8 /* PROPS */, ["active", "text", "iconClass"]),
    createVNode("span", {
      class: "el-switch__core",
      ref: "core",
      style: {
        width: $props.width + 'px',
        background: $setup.backgroundColor,
        'border-color': $setup.backgroundColor
      }
    }, null, 4 /* STYLE */),
    createVNode(_component_SwitchLabel, {
      active: $setup.isChecked,
      type: "right",
      text: $props.activeText,
      iconClass: $props.activeIconClass
    }, null, 8 /* PROPS */, ["active", "text", "iconClass"])
  ], 2 /* CLASS */))
}

script$s.render = render$q;
script$s.__file = "packages/switch/Switch.vue";

/* istanbul ignore next */

script$s.install = function (app) {
  app.component(script$s.name, script$s);
};

const stop$2 = e => e.stopPropagation();
/**
 * @param {HTMLElement} [reference=$refs.reference] - The reference element used to position the popper.
 * @param {HTMLElement} [popper=$refs.popper] - The HTML element used as popper, or a configuration used to generate the popper.
 * @param {String} [placement=button] - Placement of the popper accepted values: top(-start, -end), right(-start, -end), bottom(-start, -end), left(-start, -end)
 * @param {Number} [offset=0] - Amount of pixels the popper will be shifted (can be negative).
 * @param {Boolean} [visible=false] Visibility of the popup element.
 * @param {Boolean} [visible-arrow=false] Visibility of the arrow, no style.
 */


const vuePopperProps = {
  transformOrigin: {
    type: [Boolean, String],
    default: true
  },
  placement: {
    type: String,
    default: 'bottom'
  },
  boundariesPadding: {
    type: Number,
    default: 5
  },
  reference: {},
  popper: {},
  offset: {
    default: 0
  },
  modelValue: Boolean,
  visibleArrow: Boolean,
  arrowOffset: {
    type: Number,
    default: 35
  },
  appendToBody: {
    type: Boolean,
    default: true
  },
  popperOptions: {
    type: Object,

    default() {
      return {
        gpuAcceleration: false
      };
    }

  }
};

function useVuePopper(props, {
  emit,
  slots,
  referenceEl
}) {
  const {
    transformOrigin,
    placement,
    reference,
    popper,
    offset,
    modelValue,
    visibleArrow,
    arrowOffset,
    appendToBody,
    popperOptions,
    disabled
  } = toRefs(props);
  const showPopper = ref(false);
  const currentPlacement = ref('');
  const popperElm = ref(null);
  const popperJS = ref(null);
  const instance = getCurrentInstance();

  function createPopper() {
    if (instance.proxy.$isServer) return;
    currentPlacement.value = currentPlacement.value || placement.value;

    if (!/^(top|bottom|left|right)(-start|-end)?$/g.test(currentPlacement.value)) {
      return;
    }

    const options = popperOptions.value;
    const popperRef = popperElm.value = popperElm.value || popper && popper.value || instance.proxy.$refs.popper;
    let referenceRef = referenceEl.value = referenceEl.value || reference && reference.value || instance.proxy.$refs.reference;

    if (!referenceRef && slots.reference && slots.reference() && slots.reference()[0]) {
      referenceRef = referenceEl.value = slots.reference()[0].el;
    }

    if (!popperRef || !referenceRef) return;
    if (visibleArrow.value) appendArrow(popperRef);
    if (appendToBody.value) document.body.appendChild(popperElm.value);

    if (popperJS.value && popperJS.value.destroy) {
      popperJS.value.destroy();
    }

    options.placement = currentPlacement.value;
    options.offset = offset.value;
    options.arrowOffset = arrowOffset.value;
    popperJS.value = new Popper(referenceRef, popperRef, options);
    popperJS.value.onCreate(() => {
      emit('created', instance.proxy);
      resetTransformOrigin();
      nextTick(() => updatePopper());
    });

    if (typeof options.onUpdate === 'function') {
      popperJS.value.onUpdate(options.onUpdate);
    }

    popperJS.value._popper.style.zIndex = PopupManager.nextZIndex();
    popperElm.value.addEventListener('click', stop$2);
  }

  function updatePopper() {
    const popperJSRef = popperJS.value;

    if (popperJSRef) {
      popperJSRef.update();

      if (popperJSRef._popper) {
        popperJSRef._popper.style.zIndex = PopupManager.nextZIndex();
      }
    } else {
      createPopper();
    }
  }

  function doDestroy(forceDestroy) {
    /* istanbul ignore if */
    if (!popperJS.value || showPopper.value && !forceDestroy) return;
    popperJS.value.destroy();
    popperJS.value = null;
  }

  function destroyPopper() {
    if (popperJS.value) {
      resetTransformOrigin();
    }
  }

  function resetTransformOrigin() {
    if (!transformOrigin.value) return;
    const placementMap = {
      top: 'bottom',
      bottom: 'top',
      left: 'right',
      right: 'left'
    };

    const placement = popperJS.value._popper.getAttribute('x-placement').split('-')[0];

    const origin = placementMap[placement];
    popperJS.value._popper.style.transformOrigin = typeof transformOrigin.value === 'string' ? transformOrigin.value : ['top', 'bottom'].indexOf(placement) > -1 ? `center ${origin}` : `${origin} center`;
  }

  const appended = ref(false);

  function appendArrow(element) {
    let hash;

    if (appended.value) {
      return;
    }

    appended.value = true;

    for (const item in element.attributes) {
      if (/^_v-/.test(element.attributes[item].name)) {
        hash = element.attributes[item].name;
        break;
      }
    }

    const arrow = document.createElement('div');

    if (hash) {
      arrow.setAttribute(hash, '');
    }

    arrow.setAttribute('x-arrow', '');
    arrow.className = 'popper__arrow';
    element.appendChild(arrow);
  }

  watch(modelValue, val => {
    showPopper.value = val;
    emit('update:modelValue', val);
  }, {
    immediate: true
  });
  watch(showPopper, val => {
    if (disabled.value) return;
    val ? updatePopper() : destroyPopper();
    emit('update:modelValue', val);
  });
  onBeforeUnmount(() => {
    doDestroy(true);

    if (popperElm.value && popperElm.value.parentNode === document.body) {
      popperElm.value.removeEventListener('click', stop$2);
      document.body.removeChild(popperElm.value);
    }
  });
  return {
    showPopper,
    currentPlacement,
    popperElm,
    popperJS,
    createPopper,
    updatePopper,
    doDestroy,
    destroyPopper,
    resetTransformOrigin,
    appendArrow
  };
}

var ElTooltip = {
  name: 'ElTooltip',
  emits: ['input', 'update:modelValue', 'created'],
  props: { ...vuePopperProps,
    openDelay: {
      type: Number,
      default: 0
    },
    disabled: Boolean,
    manual: Boolean,
    effect: {
      type: String,
      default: 'dark'
    },
    arrowOffset: {
      type: Number,
      default: 0
    },
    popperClass: String,
    content: String,
    visibleArrow: {
      default: true
    },
    transition: {
      type: String,
      default: 'el-fade-in-linear'
    },
    popperOptions: {
      default() {
        return {
          boundariesPadding: 10,
          gpuAcceleration: false
        };
      }

    },
    enterable: {
      type: Boolean,
      default: true
    },
    hideAfter: {
      type: Number,
      default: 0
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },

  beforeCreate() {
    if (this.$isServer) return;
    this.popperVM = createApp({
      data() {
        return {
          node: ''
        };
      },

      render() {
        return this.node;
      }

    }).mount(document.createElement('div'));
  },

  setup(props, context) {
    const timeoutPending = ref(null);
    const timeout = ref(null);
    const focusing = ref(false);
    const expectedState = ref(false);
    const referenceElm = ref(null);
    const {
      emit,
      slots
    } = context;
    const {
      modelValue,
      openDelay,
      disabled,
      manual,
      effect,
      popperClass,
      content,
      transition,
      enterable,
      hideAfter,
      tabindex
    } = props;
    const {
      showPopper,
      updatePopper,
      doDestroy
    } = useVuePopper(props, {
      emit,
      slots,
      referenceEl: referenceElm
    });
    const instance = getCurrentInstance();
    const tooltipId = `el-tooltip-${generateId()}`;
    const debounceClose = debounce(200, () => handleClosePopper());

    const show = () => {
      setExpectedState(true);
      handleShowPopper();
    };

    const hide = () => {
      setExpectedState(false);
      debounceClose();
    };

    const handleFocus = () => {
      focusing.value = true;
      show();
    };

    const handleBlur = () => {
      focusing.value = false;
      hide();
    };

    const removeFocusing = () => {
      focusing.value = false;
    };

    const addTooltipClass = prev => {
      if (!prev) {
        return 'el-tooltip';
      } else {
        return 'el-tooltip ' + prev.replace('el-tooltip', '');
      }
    };

    const handleShowPopper = () => {
      if (!expectedState.value || manual) return;
      clearTimeout(timeout.value);
      timeout.value = setTimeout(() => {
        showPopper.value = true;
      }, openDelay);

      if (hideAfter > 0) {
        timeoutPending.value = setTimeout(() => {
          showPopper.value = false;
        }, hideAfter);
      }
    };

    const handleClosePopper = () => {
      if (enterable && expectedState.value || manual) return;
      clearTimeout(timeout.value);

      if (timeoutPending.value) {
        clearTimeout(timeoutPending.value);
      }

      showPopper.value = false;

      if (disabled) {
        doDestroy();
      }
    };

    const setExpectedState = state => {
      if (state === false) {
        clearTimeout(timeoutPending.value);
      }

      expectedState.value = state;
    };

    const getFirstElement = () => {
      const slotsDefault = slots.default();
      if (!Array.isArray(slotsDefault)) return null;
      let element = null;

      for (let index = 0; index < slotsDefault.length; index++) {
        if (slotsDefault[index] && slotsDefault[index].type) {
          element = slotsDefault[index];
        }
      }

      return element;
    };

    watch(focusing, val => {
      if (val) {
        addClass(referenceElm.value, 'focusing');
      } else {
        removeClass(referenceElm.value, 'focusing');
      }
    });
    onMounted(() => {
      referenceElm.value = instance.ctx.$el;

      if (referenceElm.value.nodeType === 1) {
        referenceElm.value.setAttribute('aria-describedby', tooltipId);
        referenceElm.value.setAttribute('tabindex', tabindex);
        on(referenceElm.value, 'mouseenter', show);
        on(referenceElm.value, 'mouseleave', hide);
        on(referenceElm.value, 'focus', () => {
          if (!slots.default || !slots.default().length) {
            handleFocus();
            return;
          }

          const slotsProps = slots.default()[0].props;

          if (slotsProps && slotsProps.onFocus) {
            slotsProps.onFocus();
          } else {
            handleFocus();
          }
        });
        on(referenceElm.value, 'blur', handleBlur);
        on(referenceElm.value, 'click', removeFocusing);
      } // fix issue https://github.com/ElemeFE/element/issues/14424


      if (modelValue && instance.ctx.popperVM) {
        instance.ctx.popperVM.$nextTick(() => {
          if (modelValue) {
            updatePopper();
          }
        });
      }
    });
    onBeforeMount(() => {
      instance.ctx.updatePopper = updatePopper;
    });
    onUnmounted(() => {
      const reference = referenceElm.value;

      if (reference.nodeType === 1) {
        off(reference, 'mouseenter', show);
        off(reference, 'mouseleave', hide);
        off(reference, 'focus', handleFocus);
        off(reference, 'blur', handleBlur);
        off(reference, 'click', removeFocusing);
      }
    });
    return () => {
      if (instance.ctx.popperVM) {
        instance.ctx.popperVM.node = createVNode(Transition, {
          "name": transition,
          "onAfterLeave": doDestroy
        }, {
          default: () => [withDirectives(createVNode("div", {
            "onMouseleave": () => {
              setExpectedState(false);
              debounceClose();
            },
            "onMouseenter": () => {
              setExpectedState(true);
            },
            "ref": "popper",
            "role": "tooltip",
            "id": tooltipId,
            "aria-hidden": disabled || !showPopper.value ? 'true' : 'false',
            "class": ['el-tooltip__popper', 'is-' + effect, popperClass]
          }, [slots.content ? slots.content() : content]), [[vShow, !disabled && showPopper.value]])]
        });
      }

      const firstElement = getFirstElement();
      if (!firstElement) return null;
      const firstElementProps = firstElement.props = firstElement.props || {};
      firstElementProps.class = addTooltipClass(firstElementProps.class);
      return firstElement;
    };
  }

};

/* istanbul ignore next */

ElTooltip.install = function (app) {
  app.component(ElTooltip.name, ElTooltip);
};

var script$t = {
  name: 'ElSliderButton',
  components: {
    ElTooltip
  },
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    vertical: {
      type: Boolean,
      default: false
    },
    tooltipClass: String
  },
  emits: ['update:modelValue'],

  setup(props, {
    emit
  }) {
    const tooltip = ref(null);
    const {
      parent,
      ctx
    } = getCurrentInstance();
    const {
      modelValue,
      vertical
    } = toRefs(props);
    const {
      displayTooltip,
      hideTooltip
    } = useToolTip(ctx);
    const {
      hovering,
      handleMouseEnter,
      handleMouseLeave
    } = useMouseHover(displayTooltip, hideTooltip); // computed

    const {
      disabled,
      max,
      min,
      step,
      showTooltip,
      precision,
      currentPosition,
      enableFormat,
      formatValue,
      wrapperStyle
    } = useComputed(modelValue, vertical);
    const {
      // data
      dragging,
      isClick,
      startX,
      currentX,
      startY,
      currentY,
      startPosition,
      newPosition,
      oldValue,
      // methods
      onButtonDown,
      onDragStart,
      onDragging,
      onDragEnd,
      onLeftKeyDown,
      onRightKeyDown,
      setPosition
    } = useDragAndKeyDown(parent, ctx, emit, modelValue, vertical, disabled, step, max, min, precision, currentPosition, displayTooltip, hideTooltip);
    return {
      // data
      hovering,
      dragging,
      isClick,
      startX,
      currentX,
      startY,
      currentY,
      startPosition,
      newPosition,
      oldValue,
      // computed
      disabled,
      max,
      min,
      step,
      showTooltip,
      precision,
      currentPosition,
      enableFormat,
      formatValue,
      wrapperStyle,
      // methods
      setPosition,
      handleMouseEnter,
      handleMouseLeave,
      onButtonDown,
      onDragStart,
      onDragging,
      onDragEnd,
      onLeftKeyDown,
      onRightKeyDown,
      // ref
      tooltip
    };
  }

};

function useToolTip(ctx) {
  function displayTooltip() {
    ctx.tooltip && (ctx.tooltip.showPopper = true);
  }

  function hideTooltip() {
    ctx.tooltip && (ctx.tooltip.showPopper = false);
  }

  return {
    displayTooltip,
    hideTooltip
  };
}

function useMouseHover(displayTooltip, hideTooltip) {
  const hovering = ref(false);

  function handleMouseEnter() {
    hovering.value = true;
    displayTooltip();
  }

  function handleMouseLeave() {
    hovering.value = false;
    hideTooltip();
  }

  return {
    hovering,
    handleMouseEnter,
    handleMouseLeave
  };
}

function useDragAndKeyDown(parent, ctx, emit, modelValue, vertical, disabled, step, max, min, precision, currentPosition, displayTooltip, hideTooltip) {
  const {
    resetSize,
    emitChange
  } = parent.ctx;
  const dragging = ref(false);
  const isClick = ref(false);
  const startX = ref(0);
  const currentX = ref(0);
  const startY = ref(0);
  const currentY = ref(0);
  const startPosition = ref(0);
  const newPosition = ref(null);
  const oldValue = ref(unref(modelValue)); // watch

  watch(dragging, val => parent.ctx.dragging = val); // eslint-disable-next-line
  //#region drag methods: onButtonDown, onDragStart, onDragging, onDragEnd

  function onButtonDown(event) {
    if (unref(disabled)) return;
    event.preventDefault();
    onDragStart(event);
    window.addEventListener('mousemove', onDragging);
    window.addEventListener('touchmove', onDragging);
    window.addEventListener('mouseup', onDragEnd);
    window.addEventListener('touchend', onDragEnd);
    window.addEventListener('contextmenu', onDragEnd);
  }

  function onDragStart(event) {
    dragging.value = true;
    isClick.value = true;

    if (event.type === 'touchstart') {
      event.clientY = event.touches[0].clientY;
      event.clientX = event.touches[0].clientX;
    }

    if (unref(vertical)) {
      startY.value = event.clientY;
    } else {
      startX.value = event.clientX;
    }

    startPosition.value = parseFloat(unref(currentPosition));
    newPosition.value = unref(startPosition);
  }

  function onDragging(event) {
    if (unref(dragging)) {
      isClick.value = false;
      displayTooltip();
      resetSize();
      let diff = 0;

      if (event.type === 'touchmove') {
        event.clientY = event.touches[0].clientY;
        event.clientX = event.touches[0].clientX;
      }

      if (unref(vertical)) {
        currentY.value = event.clientY;
        diff = (startY.value - currentY.value) / parent.ctx.sliderSize * 100;
      } else {
        currentX.value = event.clientX;
        diff = (currentX.value - startX.value) / parent.ctx.sliderSize * 100;
      }

      newPosition.value = unref(startPosition) + diff;
      setPosition(unref(newPosition));
    }
  }

  function onDragEnd() {
    if (unref(dragging)) {
      /*
       * 防止在 mouseup 后立即触发 click，导致滑块有几率产生一小段位移
       * 不使用 preventDefault 是因为 mouseup 和 click 没有注册在同一个 DOM 上
       */
      setTimeout(() => {
        dragging.value = false;
        hideTooltip();

        if (!isClick.value) {
          setPosition(unref(newPosition));
          emitChange();
        }
      }, 0);
      window.removeEventListener('mousemove', onDragging);
      window.removeEventListener('touchmove', onDragging);
      window.removeEventListener('mouseup', onDragEnd);
      window.removeEventListener('touchend', onDragEnd);
      window.removeEventListener('contextmenu', onDragEnd);
    }
  } // eslint-disable-next-line
  //#endregion
  // eslint-disable-next-line
  //#region KeyDown methods: onLeftKeyDown, onRightKeyDown


  function onLeftKeyDown() {
    if (unref(disabled)) return;
    newPosition.value = parseFloat(unref(currentPosition)) - unref(step) / (unref(max) - unref(min)) * 100;
    setPosition(unref(newPosition));
    emitChange();
  }

  function onRightKeyDown() {
    if (unref(disabled)) return;
    newPosition.value = parseFloat(unref(currentPosition)) + unref(step) / (unref(max) - unref(min)) * 100;
    setPosition(unref(newPosition));
    emitChange();
  } // eslint-disable-next-line
  //#endregion


  function setPosition(newPosition) {
    if (newPosition === null || isNaN(newPosition)) return;

    if (newPosition < 0) {
      newPosition = 0;
    } else if (newPosition > 100) {
      newPosition = 100;
    }

    const lengthPerStep = 100 / ((max.value - min.value) / step.value);
    const steps = Math.round(newPosition / lengthPerStep);
    let value = steps * lengthPerStep * (max.value - min.value) * 0.01 + min.value;
    value = parseFloat(value.toFixed(precision.value));
    emit('update:modelValue', value);
    nextTick(() => {
      //console.log(ctx.tooltip);
      ctx.tooltip && ctx.tooltip.updatePopper();
    });

    if (!unref(dragging) && unref(modelValue) !== unref(oldValue)) {
      oldValue.value = value;
    }
  }

  return {
    dragging,
    isClick,
    startX,
    currentX,
    startY,
    currentY,
    startPosition,
    newPosition,
    oldValue,
    // methods
    setPosition,
    onButtonDown,
    onDragStart,
    onDragging,
    onDragEnd,
    onLeftKeyDown,
    onRightKeyDown
  };
}

function useComputed(modelValue, vertical) {
  const {
    parent
  } = getCurrentInstance();
  const disabled = computed(() => parent.ctx.sliderDisabled);
  const max = computed(() => parent.ctx.max);
  const min = computed(() => parent.ctx.min);
  const step = computed(() => parent.ctx.step);
  const showTooltip = computed(() => parent.ctx.showTooltip);
  const precision = computed(() => parent.ctx.precision);
  const currentPosition = computed(() => `${(unref(modelValue) - unref(min)) / (unref(max) - unref(min)) * 100}%`);
  const enableFormat = computed(() => parent.ctx.formatTooltip instanceof Function);
  const formatValue = computed(() => unref(enableFormat) && parent.ctx.formatTooltip(unref(modelValue)) || unref(modelValue));
  const wrapperStyle = computed(() => unref(vertical) ? {
    bottom: unref(currentPosition)
  } : {
    left: unref(currentPosition)
  });
  return {
    disabled,
    max,
    min,
    step,
    showTooltip,
    precision,
    currentPosition,
    enableFormat,
    formatValue,
    wrapperStyle
  };
}

function render$r(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");

  return (openBlock(), createBlock("div", {
    class: ["el-slider__button-wrapper", { hover: $setup.hovering, dragging: $setup.dragging }],
    onMouseenter: _cache[1] || (_cache[1] = (...args) => ($setup.handleMouseEnter(...args))),
    onMouseleave: _cache[2] || (_cache[2] = (...args) => ($setup.handleMouseLeave(...args))),
    onMousedown: _cache[3] || (_cache[3] = (...args) => ($setup.onButtonDown(...args))),
    onTouchstartPassive: _cache[4] || (_cache[4] = (...args) => ($setup.onButtonDown(...args))),
    style: $setup.wrapperStyle,
    ref: "button",
    tabindex: "0",
    onFocus: _cache[5] || (_cache[5] = (...args) => ($setup.handleMouseEnter(...args))),
    onBlur: _cache[6] || (_cache[6] = (...args) => ($setup.handleMouseLeave(...args))),
    onKeydown: [
      _cache[7] || (_cache[7] = withKeys((...args) => ($setup.onLeftKeyDown(...args)), ["left"])),
      _cache[8] || (_cache[8] = withKeys((...args) => ($setup.onRightKeyDown(...args)), ["right"])),
      _cache[9] || (_cache[9] = withKeys(withModifiers((...args) => ($setup.onLeftKeyDown(...args)), ["prevent"]), ["down"])),
      _cache[10] || (_cache[10] = withKeys(withModifiers((...args) => ($setup.onRightKeyDown(...args)), ["prevent"]), ["up"]))
    ]
  }, [
    createVNode(_component_el_tooltip, {
      placement: "top",
      ref: "tooltip",
      "popper-class": $props.tooltipClass,
      disabled: !$setup.showTooltip
    }, {
      content: withCtx(() => [
        createVNode("span", null, toDisplayString($setup.formatValue), 1 /* TEXT */)
      ]),
      default: withCtx(() => [
        createVNode("div", {
          class: ["el-slider__button", { hover: $setup.hovering, dragging: $setup.dragging }]
        }, null, 2 /* CLASS */)
      ]),
      _: 1
    }, 8 /* PROPS */, ["popper-class", "disabled"])
  ], 38 /* CLASS, STYLE, HYDRATE_EVENTS */))
}

script$t.render = render$r;
script$t.__file = "packages/slider/src/button.vue";

var SliderMarker = {
  name: 'ElMarker',
  props: {
    mark: {
      type: [String, Object]
    }
  },

  render() {
    const label = typeof this.mark === 'string' ? this.mark : this.mark.label;
    return createVNode("div", {
      "class": "el-slider__marks-text",
      "style": this.mark.style || {}
    }, [label]);
  }

};

var script$u = {
  name: 'ElSlider',
  props: {
    min: {
      type: Number,
      default: 0
    },
    max: {
      type: Number,
      default: 100
    },
    step: {
      type: Number,
      default: 1
    },
    modelValue: {
      type: [Number, Array],
      default: 0
    },
    showInput: {
      type: Boolean,
      default: false
    },
    showInputControls: {
      type: Boolean,
      default: true
    },
    inputSize: {
      type: String,
      default: 'small'
    },
    showStops: {
      type: Boolean,
      default: false
    },
    showTooltip: {
      type: Boolean,
      default: true
    },
    formatTooltip: Function,
    disabled: {
      type: Boolean,
      default: false
    },
    range: {
      type: Boolean,
      default: false
    },
    vertical: {
      type: Boolean,
      default: false
    },
    height: {
      type: String
    },
    debounce: {
      type: Number,
      default: 300
    },
    label: {
      type: String
    },
    tooltipClass: String,
    marks: Object
  },
  components: {
    ElInputNumber: script$h,
    SliderButton: script$t,
    SliderMarker
  },
  emits: ['update:modelValue', 'change'],

  setup(props, {
    emit
  }) {
    const {
      ctx
    } = getCurrentInstance(); // data

    const state = reactive({
      firstValue: null,
      secondValue: null,
      oldValue: null,
      dragging: false,
      sliderSize: 1
    });
    const {
      resetSize
    } = useCommon(props, state, ctx);
    useLifeCycle(props, state, ctx, resetSize);
    const {
      minValue,
      maxValue,
      valueChanged,
      setValues
    } = useModel$3(props, state, emit);
    const {
      stops,
      markList,
      barSize,
      barStart,
      precision,
      runwayStyle,
      barStyle,
      sliderDisabled,
      getStopStyle
    } = useStyle$3(props, state, minValue, maxValue);
    const {
      onSliderClick,
      emitChange,
      setPosition
    } = useEvent(props, state, ctx, emit, minValue, maxValue, sliderDisabled, resetSize);
    return { // data
      ...toRefs(state),
      // // computed
      minValue,
      maxValue,
      stops,
      markList,
      barSize,
      barStart,
      precision,
      runwayStyle,
      barStyle,
      sliderDisabled,
      // method
      valueChanged,
      setValues,
      setPosition,
      onSliderClick,
      resetSize,
      emitChange,
      getStopStyle
    };
  }

};

function useCommon(props, state, ctx) {
  const {
    vertical
  } = toRefs(props);

  function resetSize() {
    const slider = ctx.$refs.slider;

    if (slider) {
      state.sliderSize = slider[`client${unref(vertical) ? 'Height' : 'Width'}`];
    }
  }

  return {
    resetSize
  };
}

function useLifeCycle(props, state, ctx, resetSize) {
  const {
    max,
    min,
    modelValue,
    range,
    label
  } = props;
  let valuetext;

  if (range) {
    if (Array.isArray(modelValue)) {
      state.firstValue = Math.max(min, modelValue[0]);
      state.secondValue = Math.min(max, modelValue[1]);
    } else {
      state.firstValue = min;
      state.secondValue = max;
    }

    state.oldValue = [state.firstValue, state.secondValue];
    valuetext = `${state.firstValue}-${state.secondValue}`;
  } else {
    if (typeof modelValue !== 'number' || isNaN(modelValue)) {
      state.firstValue = min;
    } else {
      state.firstValue = Math.min(max, Math.max(min, modelValue));
    }

    state.oldValue = state.firstValue;
    valuetext = state.firstValue;
  }

  onMounted(() => {
    ctx.$el.setAttribute('aria-valuetext', valuetext); // label screen reader

    ctx.$el.setAttribute('aria-label', // eslint-disable-next-line
    label ? label : `slider between ${min} and ${max}`);
    resetSize();
    window.addEventListener('resize', resetSize);
  });
  onBeforeUnmount(() => window.removeEventListener('resize', resetSize));
}

function useModel$3(props, state, emit) {
  const {
    dispatch
  } = useEmitter();
  const {
    max,
    min,
    modelValue,
    range
  } = toRefs(props);
  const minValue = computed(() => Math.min(state.firstValue, state.secondValue));
  const maxValue = computed(() => Math.max(state.firstValue, state.secondValue)); // watch

  watch(modelValue, (val, oldVal) => {
    if (state.dragging || Array.isArray(val) && Array.isArray(oldVal) && val.every((item, index) => item === oldVal[index])) {
      return;
    }

    setValues();
  });
  watch(() => state.dragging, val => !val && setValues());
  watch(() => state.firstValue, val => unref(range) ? emit('update:modelValue', [unref(minValue), unref(maxValue)]) : emit('update:modelValue', val));
  watch(() => state.secondValue, () => unref(range) && emit('update:modelValue', [unref(minValue), unref(maxValue)]));
  watch(min, () => setValues());
  watch(max, () => setValues());

  function valueChanged() {
    if (unref(range)) {
      return ![minValue, maxValue].every((item, index) => unref(item) === state.oldValue[index]);
    } else {
      return unref(modelValue) !== state.oldValue;
    }
  }

  function setValues() {
    const _max = unref(max);

    const _min = unref(min);

    if (_min > _max) {
      console.error('[Element Error][Slider]min should not be greater than max.');
      return;
    }

    const val = unref(modelValue);

    if (unref(range) && Array.isArray(val)) {
      if (val[1] < _min) {
        emit('update:modelValue', [_min, _min]);
      } else if (val[0] > _max) {
        emit('update:modelValue', [_max, _max]);
      } else if (val[0] < _min) {
        emit('update:modelValue', [_min, val[1]]);
      } else if (val[1] > _max) {
        emit('update:modelValue', [val[0], _max]);
      } else {
        state.firstValue = val[0];
        state.secondValue = val[1];

        if (valueChanged()) {
          dispatch('ElFormItem', 'el.form.change', [unref(minValue), unref(maxValue)]);
          state.oldValue = val.slice();
        }
      }
    } else if (!unref(range) && typeof val === 'number' && !isNaN(val)) {
      if (val < _min) {
        emit('update:modelValue', _min);
      } else if (val > _max) {
        emit('update:modelValue', _max);
      } else {
        state.firstValue = val;

        if (valueChanged()) {
          dispatch('ElFormItem', 'el.form.change', val);
          state.oldValue = val;
        }
      }
    }
  }

  return {
    minValue,
    maxValue,
    valueChanged,
    setValues
  };
}

function useEvent(props, state, ctx, emit, minValue, maxValue, sliderDisabled, resetSize) {
  // const { emit, ctx, props } = getCurrentInstance()
  const {
    modelValue,
    range,
    vertical,
    min,
    max
  } = toRefs(props);

  function onSliderClick(event) {
    if (unref(sliderDisabled) || state.dragging) return;
    resetSize();
    const slider = ctx.$refs.slider;

    if (unref(vertical)) {
      const sliderOffsetBottom = slider.getBoundingClientRect().bottom;
      setPosition((sliderOffsetBottom - event.clientY) / state.sliderSize * 100);
    } else {
      const sliderOffsetLeft = slider.getBoundingClientRect().left;
      setPosition((event.clientX - sliderOffsetLeft) / state.sliderSize * 100);
    }

    emitChange();
  }

  function emitChange() {
    nextTick(() => emit('change', unref(range) ? [unref(minValue), unref(maxValue)] : unref(modelValue)));
  }

  function setPosition(percent) {
    const targetValue = unref(min) + percent * (unref(max) - unref(min)) / 100;

    if (!unref(range)) {
      ctx.$refs.button1.setPosition(percent);
      return;
    }

    let button;

    if (Math.abs(unref(minValue) - targetValue) < Math.abs(unref(maxValue) - targetValue)) {
      button = state.firstValue < state.secondValue ? 'button1' : 'button2';
    } else {
      button = state.firstValue > state.secondValue ? 'button1' : 'button2';
    }

    ctx.$refs[button].setPosition(percent);
  }

  return {
    onSliderClick,
    emitChange,
    setPosition
  };
}

function useStyle$3(props, state, minValue, maxValue) {
  const elForm = inject('elFrom', {
    default: ''
  });
  const {
    disabled,
    height,
    showStops,
    min,
    max,
    step,
    range,
    marks,
    vertical
  } = toRefs(props);
  const stops = computed(() => {
    if (!unref(showStops) || unref(min) > unref(max)) return [];

    if (unref(step) === 0) {
      process.env.NODE_ENV !== 'production' && console.warn('[Element Warn][Slider]step should not be 0.');
      return [];
    }

    const stopCount = (unref(max) - unref(min)) / unref(step);
    const stepWidth = 100 * unref(step) / (unref(max) - unref(min));
    const result = [];

    for (let i = 1; i < stopCount; i++) {
      result.push(i * stepWidth);
    }

    if (unref(range)) {
      return result.filter(step => {
        return step < 100 * (unref(minValue) - unref(min)) / (unref(max) - unref(min)) || step > 100 * (unref(maxValue) - unref(min)) / (unref(max) - unref(min));
      });
    } else {
      return result.filter(step => step > 100 * (state.firstValue - unref(min)) / (unref(max) - unref(min)));
    }
  });
  const markList = computed(() => {
    if (!unref(marks)) {
      return [];
    }

    const marksKeys = Object.keys(unref(marks));
    return marksKeys.map(parseFloat).sort((a, b) => a - b).filter(point => point <= unref(max) && point >= unref(min)).map(point => ({
      point,
      position: (point - unref(min)) * 100 / (unref(max) - unref(min)),
      mark: marks.value[point]
    }));
  });
  const barSize = computed(() => {
    return unref(range) ? `${100 * (unref(maxValue) - unref(minValue)) / (unref(max) - unref(min))}%` : `${100 * (state.firstValue - unref(min)) / (unref(max) - unref(min))}%`;
  });
  const barStart = computed(() => {
    return unref(range) ? `${100 * (unref(minValue) - unref(min)) / (unref(max) - unref(min))}%` : '0%';
  });
  const precision = computed(() => {
    const precisions = [min, max, step].map(item => {
      const decimal = ('' + unref(item)).split('.')[1];
      return decimal ? decimal.length : 0;
    });
    return Math.max.apply(null, precisions);
  });
  const runwayStyle = computed(() => {
    if (unref(vertical) && isUndefined(height)) {
      process.env.NODE_ENV !== 'production' && console.warn('[Element Warn][Slider]height must has a value when vertical is true');
      return {};
    }

    return unref(vertical) ? {
      height: unref(height)
    } : {};
  });
  const barStyle = computed(() => {
    return unref(vertical) ? {
      height: unref(barSize),
      bottom: unref(barStart)
    } : {
      width: unref(barSize),
      left: unref(barStart)
    };
  });
  const sliderDisabled = computed(() => {
    return unref(disabled) || (elForm.props || {}).disabled;
  });

  function getStopStyle(position) {
    return unref(vertical) ? {
      bottom: position + '%'
    } : {
      left: position + '%'
    };
  }

  return {
    stops,
    markList,
    barSize,
    barStart,
    precision,
    runwayStyle,
    barStyle,
    sliderDisabled,
    getStopStyle
  };
}

const _hoisted_1$e = { class: "el-slider__marks" };

function render$s(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input_number = resolveComponent("el-input-number");
  const _component_slider_button = resolveComponent("slider-button");
  const _component_slider_marker = resolveComponent("slider-marker");

  return (openBlock(), createBlock("div", {
    class: ["el-slider", { 'is-vertical': $props.vertical, 'el-slider--with-input': $props.showInput }],
    role: "slider",
    "aria-valuemin": $props.min,
    "aria-valuemax": $props.max,
    "aria-orientation": $props.vertical ? 'vertical' : 'horizontal',
    "aria-disabled": $setup.sliderDisabled
  }, [
    ($props.showInput && !$props.range)
      ? (openBlock(), createBlock(_component_el_input_number, {
          key: 0,
          modelValue: _ctx.firstValue,
          "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (_ctx.firstValue = $event)),
          class: "el-slider__input",
          ref: "input",
          onChange: $setup.emitChange,
          step: $props.step,
          disabled: $setup.sliderDisabled,
          controls: $props.showInputControls,
          min: $props.min,
          max: $props.max,
          debounce: $props.debounce,
          size: $props.inputSize
        }, null, 8 /* PROPS */, ["modelValue", "onChange", "step", "disabled", "controls", "min", "max", "debounce", "size"]))
      : createCommentVNode("v-if", true),
    createVNode("div", {
      class: ["el-slider__runway", { 'show-input': $props.showInput, disabled: $setup.sliderDisabled }],
      style: $setup.runwayStyle,
      onClick: _cache[4] || (_cache[4] = (...args) => ($setup.onSliderClick(...args))),
      ref: "slider"
    }, [
      createVNode("div", {
        class: "el-slider__bar",
        style: $setup.barStyle
      }, null, 4 /* STYLE */),
      createVNode(_component_slider_button, {
        modelValue: _ctx.firstValue,
        "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => (_ctx.firstValue = $event)),
        vertical: $props.vertical,
        "tooltip-class": $props.tooltipClass,
        ref: "button1"
      }, null, 8 /* PROPS */, ["modelValue", "vertical", "tooltip-class"]),
      ($props.range)
        ? (openBlock(), createBlock(_component_slider_button, {
            key: 0,
            vertical: $props.vertical,
            modelValue: _ctx.secondValue,
            "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => (_ctx.secondValue = $event)),
            "tooltip-class": $props.tooltipClass,
            ref: "button2"
          }, null, 8 /* PROPS */, ["vertical", "modelValue", "tooltip-class"]))
        : createCommentVNode("v-if", true),
      ($props.showStops)
        ? (openBlock(true), createBlock(Fragment, { key: 1 }, renderList($setup.stops, (item, key) => {
            return (openBlock(), createBlock("div", {
              class: "el-slider__stop",
              key: key,
              style: $setup.getStopStyle(item)
            }, null, 4 /* STYLE */))
          }), 128 /* KEYED_FRAGMENT */))
        : createCommentVNode("v-if", true),
      ($setup.markList.length > 0)
        ? (openBlock(), createBlock(Fragment, { key: 2 }, [
            createVNode("div", null, [
              (openBlock(true), createBlock(Fragment, null, renderList($setup.markList, (item, key) => {
                return (openBlock(), createBlock("div", {
                  style: $setup.getStopStyle(item.position),
                  class: "el-slider__stop el-slider__marks-stop",
                  key: key
                }, null, 4 /* STYLE */))
              }), 128 /* KEYED_FRAGMENT */))
            ]),
            createVNode("div", _hoisted_1$e, [
              (openBlock(true), createBlock(Fragment, null, renderList($setup.markList, (item, key) => {
                return (openBlock(), createBlock(_component_slider_marker, {
                  mark: item.mark,
                  key: key,
                  style: $setup.getStopStyle(item.position)
                }, null, 8 /* PROPS */, ["mark", "style"]))
              }), 128 /* KEYED_FRAGMENT */))
            ])
          ], 64 /* STABLE_FRAGMENT */))
        : createCommentVNode("v-if", true)
    ], 6 /* CLASS, STYLE */)
  ], 10 /* CLASS, PROPS */, ["aria-valuemin", "aria-valuemax", "aria-orientation", "aria-disabled"]))
}

script$u.render = render$s;
script$u.__file = "packages/slider/Slider.vue";

/* istanbul ignore next */

script$u.install = function (app) {
  app.component(script$u.name, script$u);
};

var script$v = {
  name: 'ElProgress',
  props: {
    type: {
      type: String,
      default: 'line',
      validator: val => ['line', 'circle', 'dashboard'].indexOf(val) > -1
    },
    percentage: {
      type: Number,
      default: 0,
      required: true,
      validator: val => val >= 0 && val <= 100
    },
    status: {
      type: String,
      validator: val => ['success', 'exception', 'warning'].indexOf(val) > -1
    },
    strokeWidth: {
      type: Number,
      default: 6
    },
    strokeLinecap: {
      type: String,
      default: 'round',
      validator: val => ['butt', 'round', 'square'].indexOf(val) > -1
    },
    textInside: {
      type: Boolean,
      default: false
    },
    width: {
      type: Number,
      default: 126
    },
    showText: {
      type: Boolean,
      default: true
    },
    color: {
      type: [String, Array, Function],
      default: ''
    },
    format: Function
  },

  setup(props) {
    const {
      percentage,
      color,
      strokeWidth,
      width,
      type,
      status,
      format
    } = toRefs(props);

    const getCurrentColor = percentage => {
      if (typeof color.value === 'function') {
        return color.value(percentage);
      } else if (typeof color.value === 'string') {
        return color.value;
      } else {
        return getLevelColor(percentage);
      }
    };

    const getLevelColor = percentage => {
      const colorArray = getColorArray().sort((a, b) => a.percentage - b.percentage);

      for (let i = 0; i < colorArray.length; i++) {
        if (colorArray[i].percentage > percentage) {
          return colorArray[i].color;
        }
      }

      return colorArray[colorArray.length - 1].color;
    };

    const getColorArray = () => {
      const span = 100 / color.value.length;
      return color.value.map((seriesColor, index) => {
        if (typeof seriesColor === 'string') {
          return {
            color: seriesColor,
            progress: (index + 1) * span
          };
        }

        return seriesColor;
      });
    };

    const barStyle = useBarStyle(percentage, getCurrentColor);
    const relativeStrokeWidth = useRelativeStrokeWidth(strokeWidth, width);
    const radius = useRadius(type, relativeStrokeWidth);
    const trackPath = useTrackPath(radius, type);
    const perimeter = usePerimeter(radius);
    const rate = useRate(type);
    const strokeDashoffset = useStrokeDashoffset(perimeter, rate);
    const trailPathStyle = useTrailPathStyle(perimeter, rate, strokeDashoffset);
    const circlePathStyle = useCirclePathStyle(perimeter, rate, percentage, strokeDashoffset);
    const stroke = useStroke(color, getCurrentColor, percentage, status);
    const iconClass = useIconClass(status, type);
    const progressTextSize = useProgressTextSize(type, strokeWidth, width);
    const content = useContent(format, percentage);
    return {
      barStyle,
      relativeStrokeWidth,
      trackPath,
      trailPathStyle,
      circlePathStyle,
      stroke,
      iconClass,
      progressTextSize,
      content
    };
  }

};

const useBarStyle = (percentage, getCurrentColor) => {
  const barStyle = computed(() => {
    const style = {};
    style.width = percentage.value + '%';
    style.backgroundColor = getCurrentColor(percentage.value);
    return style;
  });
  return barStyle;
};

const useRelativeStrokeWidth = (strokeWidth, width) => {
  const relativeStrokeWidth = computed(() => {
    return (strokeWidth.value / width.value * 100).toFixed(1);
  });
  return relativeStrokeWidth;
};

const useRadius = (type, relativeStrokeWidth) => {
  const radius = computed(() => {
    if (type.value === 'circle' || type.value === 'dashboard') {
      return parseInt(50 - parseFloat(relativeStrokeWidth.value) / 2, 10);
    } else {
      return 0;
    }
  });
  return radius;
};

const useTrackPath = (radius, type) => {
  const trackPath = computed(() => {
    const isDashboard = type.value === 'dashboard';
    return `
          M 50 50
          m 0 ${isDashboard ? '' : '-'}${radius.value}
          a ${radius.value} ${radius.value} 0 1 1 0 ${isDashboard ? '-' : ''}${radius.value * 2}
          a ${radius.value} ${radius.value} 0 1 1 0 ${isDashboard ? '' : '-'}${radius.value * 2}
          `;
  });
  return trackPath;
};

const usePerimeter = radius => {
  const perimeter = computed(() => {
    return 2 * Math.PI * radius.value;
  });
  return perimeter;
};

const useRate = type => {
  const rate = computed(() => {
    return type.value === 'dashboard' ? 0.75 : 1;
  });
  return rate;
};

const useStrokeDashoffset = (perimeter, rate) => {
  const strokeDashoffset = computed(() => {
    const offset = -1 * perimeter.value * (1 - rate.value) / 2;
    return `${offset}px`;
  });
  return strokeDashoffset;
};

const useTrailPathStyle = (perimeter, rate, strokeDashoffset) => {
  const trailPathStyle = computed(() => {
    return {
      strokeDasharray: `${perimeter.value * rate.value}px, ${perimeter.value}px`,
      strokeDashoffset: strokeDashoffset.value
    };
  });
  return trailPathStyle;
};

const useCirclePathStyle = (perimeter, rate, percentage, strokeDashoffset) => {
  const circlePathStyle = computed(() => {
    return {
      strokeDasharray: `${perimeter.value * rate.value * (percentage.value / 100)}px, ${perimeter.value}px`,
      strokeDashoffset: strokeDashoffset.value,
      transition: 'stroke-dasharray 0.6s ease 0s, stroke 0.6s ease'
    };
  });
  return circlePathStyle;
};

const useStroke = (color, getCurrentColor, percentage, status) => {
  const stroke = computed(() => {
    const statusValue = status && status.value;
    let ret;

    if (color.value) {
      ret = getCurrentColor(percentage.value);
    } else {
      switch (statusValue) {
        case 'success':
          ret = '#13ce66';
          break;

        case 'exception':
          ret = '#ff4949';
          break;

        case 'warning':
          ret = '#e6a23c';
          break;

        default:
          ret = '#20a0ff';
      }
    }

    return ret;
  });
  return stroke;
};

const useIconClass = (status, type) => {
  const iconClass = computed(() => {
    if (status.value === 'warning') {
      return 'el-icon-warning';
    }

    if (type.value === 'line') {
      return status.value === 'success' ? 'el-icon-circle-check' : 'el-icon-circle-close';
    } else {
      return status.value === 'success' ? 'el-icon-check' : 'el-icon-close';
    }
  });
  return iconClass;
};

const useProgressTextSize = (type, strokeWidth, width) => {
  const progressTextSize = computed(() => {
    return type.value === 'line' ? 12 + strokeWidth.value * 0.4 : width.value * 0.111111 + 2;
  });
  return progressTextSize;
};

const useContent = (format, percentage) => {
  const content = computed(() => {
    if (format && typeof format.value === 'function') {
      return format.value(percentage.value) || '';
    } else {
      return `${percentage.value}%`;
    }
  });
  return content;
};

const _hoisted_1$f = {
  key: 0,
  class: "el-progress-bar"
};
const _hoisted_2$8 = {
  key: 0,
  class: "el-progress-bar__innerText"
};
const _hoisted_3$5 = { viewBox: "0 0 100 100" };

function render$t(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-progress", [
      'el-progress--' + $props.type,
      $props.status ? 'is-' + $props.status : '',
      {
        'el-progress--without-text': !$props.showText,
        'el-progress--text-inside': $props.textInside
      }
    ]],
    role: "progressbar",
    "aria-valuenow": $props.percentage,
    "aria-valuemin": "0",
    "aria-valuemax": "100"
  }, [
    ($props.type === 'line')
      ? (openBlock(), createBlock("div", _hoisted_1$f, [
          createVNode("div", {
            class: "el-progress-bar__outer",
            style: { height: $props.strokeWidth + 'px' }
          }, [
            createVNode("div", {
              class: "el-progress-bar__inner",
              style: $setup.barStyle
            }, [
              ($props.showText && $props.textInside)
                ? (openBlock(), createBlock("div", _hoisted_2$8, toDisplayString($setup.content), 1 /* TEXT */))
                : createCommentVNode("v-if", true)
            ], 4 /* STYLE */)
          ], 4 /* STYLE */)
        ]))
      : (openBlock(), createBlock("div", {
          key: 1,
          class: "el-progress-circle",
          style: { height: $props.width + 'px', width: $props.width + 'px' }
        }, [
          (openBlock(), createBlock("svg", _hoisted_3$5, [
            createVNode("path", {
              class: "el-progress-circle__track",
              d: $setup.trackPath,
              stroke: "#e5e9f2",
              "stroke-width": $setup.relativeStrokeWidth,
              fill: "none",
              style: $setup.trailPathStyle
            }, null, 12 /* STYLE, PROPS */, ["d", "stroke-width"]),
            createVNode("path", {
              class: "el-progress-circle__path",
              d: $setup.trackPath,
              stroke: $setup.stroke,
              fill: "none",
              "stroke-linecap": $props.strokeLinecap,
              "stroke-width": $props.percentage ? $setup.relativeStrokeWidth : 0,
              style: $setup.circlePathStyle
            }, null, 12 /* STYLE, PROPS */, ["d", "stroke", "stroke-linecap", "stroke-width"])
          ]))
        ], 4 /* STYLE */)),
    ($props.showText && !$props.textInside)
      ? (openBlock(), createBlock("div", {
          key: 2,
          class: "el-progress__text",
          style: { fontSize: $setup.progressTextSize + 'px' }
        }, [
          (!$props.status)
            ? (openBlock(), createBlock(Fragment, { key: 0 }, [
                createTextVNode(toDisplayString($setup.content), 1 /* TEXT */)
              ], 64 /* STABLE_FRAGMENT */))
            : (openBlock(), createBlock("i", {
                key: 1,
                class: $setup.iconClass
              }, null, 2 /* CLASS */))
        ], 4 /* STYLE */))
      : createCommentVNode("v-if", true)
  ], 10 /* CLASS, PROPS */, ["aria-valuenow"]))
}

script$v.render = render$t;
script$v.__file = "packages/progress/Progress.vue";

script$v.install = function (app) {
  app.component(script$v.name, script$v);
};

var script$w = {
  name: 'ElUploadList',
  mixins: [Locale],
  components: {
    ElProgress: script$v
  },
  emits: ['remove'],
  props: {
    files: {
      type: Array,

      default() {
        return [];
      }

    },
    disabled: {
      type: Boolean,
      default: false
    },
    handlePreview: Function,
    listType: String
  },

  setup(props, {
    emit
  }) {
    const focusing = ref(false);

    const parsePercentage = val => {
      return parseInt(val, 10);
    };

    const handleClick = file => {
      props.handlePreview && props.handlePreview(file);
    };

    return {
      focusing,
      parsePercentage,
      handleClick,
      emit
    };
  }

};

const _hoisted_1$g = /*#__PURE__*/createVNode("i", { class: "el-icon-document" }, null, -1 /* HOISTED */);
const _hoisted_2$9 = { class: "el-upload-list__item-status-label" };
const _hoisted_3$6 = {
  key: 2,
  class: "el-icon-close-tip"
};
const _hoisted_4$3 = {
  key: 4,
  class: "el-upload-list__item-actions"
};
const _hoisted_5$3 = /*#__PURE__*/createVNode("i", { class: "el-icon-zoom-in" }, null, -1 /* HOISTED */);
const _hoisted_6$1 = /*#__PURE__*/createVNode("i", { class: "el-icon-delete" }, null, -1 /* HOISTED */);

function render$u(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_progress = resolveComponent("el-progress");

  return (openBlock(), createBlock(TransitionGroup, {
    tag: "ul",
    class: [
      'el-upload-list',
      'el-upload-list--' + $props.listType,
      { 'is-disabled': $props.disabled }
    ],
    name: "el-list"
  }, {
    default: withCtx(() => [
      (openBlock(true), createBlock(Fragment, null, renderList($props.files, (file) => {
        return (openBlock(), createBlock("li", {
          class: [
        'el-upload-list__item',
        'is-' + file.status,
        $setup.focusing ? 'focusing' : ''
      ],
          key: file.uid,
          tabindex: "0",
          onKeydown: withKeys($event => (!$props.disabled && _ctx.$emit('remove', file)), ["delete"]),
          onFocus: _cache[1] || (_cache[1] = $event => ($setup.focusing = true)),
          onBlur: _cache[2] || (_cache[2] = $event => ($setup.focusing = false)),
          onClick: _cache[3] || (_cache[3] = $event => ($setup.focusing = false))
        }, [
          renderSlot(_ctx.$slots, "default", { file: file }, () => [
            (
            file.status !== 'uploading' &&
            ['picture-card', 'picture'].indexOf($props.listType) > -1
          )
              ? (openBlock(), createBlock("img", {
                  key: 0,
                  class: "el-upload-list__item-thumbnail",
                  src: file.url,
                  alt: ""
                }, null, 8 /* PROPS */, ["src"]))
              : createCommentVNode("v-if", true),
            createVNode("a", {
              class: "el-upload-list__item-name",
              onClick: $event => ($setup.handleClick(file))
            }, [
              _hoisted_1$g,
              createTextVNode(toDisplayString(file.name), 1 /* TEXT */)
            ], 8 /* PROPS */, ["onClick"]),
            createVNode("label", _hoisted_2$9, [
              createVNode("i", {
                class: {
              'el-icon-upload-success': true,
              'el-icon-circle-check': $props.listType === 'text',
              'el-icon-check':
                ['picture-card', 'picture'].indexOf($props.listType) > -1
            }
              }, null, 2 /* CLASS */)
            ]),
            (!$props.disabled)
              ? (openBlock(), createBlock("i", {
                  key: 1,
                  class: "el-icon-close",
                  onClick: $event => (_ctx.$emit('remove', file))
                }, null, 8 /* PROPS */, ["onClick"]))
              : createCommentVNode("v-if", true),
            (!$props.disabled)
              ? (openBlock(), createBlock("i", _hoisted_3$6, toDisplayString(_ctx.t('el.upload.deleteTip')), 1 /* TEXT */))
              : createCommentVNode("v-if", true),
            createCommentVNode("因为close按钮只在li:focus的时候 display, li blur后就不存在了，所以键盘导航时永远无法 focus到 close按钮上"),
            (file.status === 'uploading')
              ? (openBlock(), createBlock(_component_el_progress, {
                  key: 3,
                  type: $props.listType === 'picture-card' ? 'circle' : 'line',
                  "stroke-width": $props.listType === 'picture-card' ? 6 : 2,
                  percentage: $setup.parsePercentage(file.percentage)
                }, null, 8 /* PROPS */, ["type", "stroke-width", "percentage"]))
              : createCommentVNode("v-if", true),
            ($props.listType === 'picture-card')
              ? (openBlock(), createBlock("span", _hoisted_4$3, [
                  ($props.handlePreview && $props.listType === 'picture-card')
                    ? (openBlock(), createBlock("span", {
                        key: 0,
                        class: "el-upload-list__item-preview",
                        onClick: $event => ($props.handlePreview(file))
                      }, [
                        _hoisted_5$3
                      ], 8 /* PROPS */, ["onClick"]))
                    : createCommentVNode("v-if", true),
                  (!$props.disabled)
                    ? (openBlock(), createBlock("span", {
                        key: 1,
                        class: "el-upload-list__item-delete",
                        onClick: $event => (_ctx.$emit('remove', file))
                      }, [
                        _hoisted_6$1
                      ], 8 /* PROPS */, ["onClick"]))
                    : createCommentVNode("v-if", true)
                ]))
              : createCommentVNode("v-if", true)
          ])
        ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["onKeydown"]))
      }), 128 /* KEYED_FRAGMENT */))
    ]),
    _: 1
  }, 8 /* PROPS */, ["class"]))
}

script$w.render = render$u;
script$w.__file = "packages/upload/src/upload-list.vue";

function getError(action, option, xhr) {
  let msg;

  if (xhr.response) {
    msg = `${xhr.response.error || xhr.response}`;
  } else if (xhr.responseText) {
    msg = `${xhr.responseText}`;
  } else {
    msg = `fail to post ${action} ${xhr.status}`;
  }

  const err = new Error(msg);
  err.status = xhr.status;
  err.method = 'post';
  err.url = action;
  return err;
}

function getBody(xhr) {
  const text = xhr.responseText || xhr.response;

  if (!text) {
    return text;
  }

  try {
    return JSON.parse(text);
  } catch (e) {
    return text;
  }
}

function upload(option) {
  if (typeof XMLHttpRequest === 'undefined') {
    return;
  }

  const xhr = new XMLHttpRequest();
  const action = option.action;

  if (xhr.upload) {
    xhr.upload.onprogress = function progress(e) {
      if (e.total > 0) {
        e.percent = e.loaded / e.total * 100;
      }

      option.onProgress(e);
    };
  }

  const formData = new FormData();

  if (option.data) {
    Object.keys(option.data).forEach(key => {
      formData.append(key, option.data[key]);
    });
  }

  formData.append(option.filename, option.file, option.file.name);

  xhr.onerror = function error(e) {
    option.onError(e);
  };

  xhr.onload = function onload() {
    if (xhr.status < 200 || xhr.status >= 300) {
      return option.onError(getError(action, option, xhr));
    }

    option.onSuccess(getBody(xhr));
  };

  xhr.open('post', action, true);

  if (option.withCredentials && 'withCredentials' in xhr) {
    xhr.withCredentials = true;
  }

  const headers = option.headers || {};

  for (const item in headers) {
    if (Object.hasOwnProperty.call(headers, item) && headers[item] !== null) {
      xhr.setRequestHeader(item, headers[item]);
    }
  }

  xhr.send(formData);
  return xhr;
}

var script$x = {
  name: 'ElUploadDrag',
  props: {
    disabled: Boolean
  },
  emits: ['file'],
  inject: ['uploader'],

  setup(props, {
    emit
  }) {
    const uploader = inject('uploader', {});
    const {
      disabled
    } = toRefs(props);
    const dragover = ref(false);

    const onDragover = () => {
      if (!disabled.value) {
        dragover.value = true;
      }
    };

    const onDrop = e => {
      if (disabled.value || !uploader) return;
      const accept = uploader.accept;
      dragover.value = false;

      if (!accept) {
        emit('file', e.dataTransfer.files);
        return;
      }

      emit('file', [].slice.call(e.dataTransfer.files).filter(file => {
        const {
          type,
          name
        } = file;
        const extension = name.indexOf('.') > -1 ? `.${name.split('.').pop()}` : '';
        const baseType = type.replace(/\/.*$/, '');
        return accept.split(',').map(type => type.trim()).filter(type => type).some(acceptedType => {
          if (/\..+$/.test(acceptedType)) {
            return extension === acceptedType;
          }

          if (/\/\*$/.test(acceptedType)) {
            return baseType === acceptedType.replace(/\/\*$/, '');
          } // eslint-disable-next-line no-useless-escape


          if (/^[^\/]+\/[^\/]+$/.test(acceptedType)) {
            return type === acceptedType;
          }

          return false;
        });
      }));
    };

    return {
      onDragover,
      onDrop,
      dragover
    };
  }

};

function render$v(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-upload-dragger", {
      'is-dragover': $setup.dragover
    }],
    onDrop: _cache[1] || (_cache[1] = withModifiers((...args) => ($setup.onDrop(...args)), ["prevent"])),
    onDragover: _cache[2] || (_cache[2] = withModifiers((...args) => ($setup.onDragover(...args)), ["prevent"])),
    onDragleave: _cache[3] || (_cache[3] = withModifiers($event => ($setup.dragover = false), ["prevent"]))
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$x.render = render$v;
script$x.__file = "packages/upload/src/upload-dragger.vue";

var script$y = {
  inject: ['uploader'],
  components: {
    UploadDragger: script$x
  },
  props: {
    type: String,
    action: {
      type: String,
      required: true
    },
    name: {
      type: String,
      default: 'file'
    },
    data: Object,
    headers: Object,
    withCredentials: Boolean,
    multiple: Boolean,
    accept: String,
    onStart: Function,
    onProgress: Function,
    onSuccess: Function,
    onError: Function,
    beforeUpload: Function,
    drag: Boolean,
    onPreview: {
      type: Function,
      default: function () {}
    },
    onRemove: {
      type: Function,
      default: function () {}
    },
    fileList: Array,
    autoUpload: Boolean,
    listType: String,
    httpRequest: {
      type: Function,
      default: upload
    },
    disabled: Boolean,
    limit: Number,
    onExceed: Function
  },

  setup(props) {
    const {
      limit,
      fileList,
      onExceed,
      multiple,
      autoUpload
    } = toRefs(props); // eslint-disable-next-line vue/no-setup-props-destructure

    const {
      onStart,
      beforeUpload,
      httpRequest,
      onProgress,
      onSuccess,
      onError,
      disabled,
      onRemove
    } = props;
    const mouseover = ref(false);
    const reqs = reactive({});
    const input = ref(null);

    const isImage = str => {
      return str.indexOf('image') !== -1;
    };

    const handleChange = ev => {
      const files = ev.target.files;
      if (!files) return;
      uploadFiles(files);
    };

    const uploadFiles = files => {
      if (limit.value && fileList.length + files.length > limit.value) {
        onExceed && onExceed(files, fileList);
        return;
      }

      let postFiles = Array.prototype.slice.call(files);

      if (!multiple.value) {
        postFiles = postFiles.slice(0, 1);
      }

      if (postFiles.length === 0) {
        return;
      }

      postFiles.forEach(rawFile => {
        onStart(rawFile);
        if (autoUpload.value) upload(rawFile);
      });
    };

    const upload = rawFile => {
      input.value.value = null;

      if (!beforeUpload) {
        return post(rawFile);
      }

      const before = beforeUpload(rawFile);

      if (before && before.then) {
        before.then(processedFile => {
          const fileType = Object.prototype.toString.call(processedFile);

          if (fileType === '[object File]' || fileType === '[object Blob]') {
            if (fileType === '[object Blob]') {
              processedFile = new File([processedFile], rawFile.name, {
                type: rawFile.type
              });
            }

            for (const p in rawFile) {
              if (Object.hasOwnProperty.call(rawFile, p)) {
                processedFile[p] = rawFile[p];
              }
            }

            post(processedFile);
          } else {
            post(rawFile);
          }
        }, () => {
          onRemove(null, rawFile);
        });
      } else if (before !== false) {
        post(rawFile);
      } else {
        onRemove(null, rawFile);
      }
    };

    const abort = file => {
      if (file) {
        let uid = file;
        if (file.uid) uid = file.uid;

        if (reqs[uid]) {
          reqs[uid].abort();
        }
      } else {
        Object.keys(reqs).forEach(uid => {
          if (reqs[uid]) reqs[uid].abort();
          delete reqs[uid];
        });
      }
    };

    const post = rawFile => {
      const {
        uid
      } = rawFile;
      const options = {
        headers: props.headers,
        withCredentials: props.withCredentials,
        file: rawFile,
        data: props.data,
        filename: props.name,
        action: props.action,
        onProgress: e => {
          onProgress(e, rawFile);
        },
        onSuccess: res => {
          onSuccess(res, rawFile);
          delete reqs[uid];
        },
        onError: err => {
          onError(err, rawFile);
          delete reqs[uid];
        }
      };
      const req = httpRequest(options);
      reqs[uid] = req;

      if (req && req.then) {
        req.then(options.onSuccess, options.onError);
      }
    };

    const handleClick = () => {
      if (!unref(disabled)) {
        input.value.value = null;
        input.value.click();
      }
    };

    const handleKeydown = e => {
      if (e.target !== e.currentTarget) return;

      if (e.keyCode === 13 || e.keyCode === 32) {
        handleClick();
      }
    };

    return {
      mouseover,
      isImage,
      handleChange,
      uploadFiles,
      handleClick,
      handleKeydown,
      post,
      upload,
      input,
      reqs,
      abort
    };
  }

};

function render$w(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_upload_dragger = resolveComponent("upload-dragger");

  return (openBlock(), createBlock("div", {
    class: ["el-upload", { [`el-upload--${$props.listType}`]: true }],
    onClick: _cache[2] || (_cache[2] = (...args) => ($setup.handleClick(...args))),
    onKeydown: _cache[3] || (_cache[3] = (...args) => ($setup.handleKeydown(...args))),
    tabindex: "0"
  }, [
    ($props.drag)
      ? (openBlock(), createBlock(_component_upload_dragger, {
          key: 0,
          disabled: $props.disabled,
          onFile: $setup.uploadFiles
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8 /* PROPS */, ["disabled", "onFile"]))
      : renderSlot(_ctx.$slots, "default", { key: 1 }),
    createVNode("input", {
      class: "el-upload__input",
      type: "file",
      ref: "input",
      name: $props.name,
      onChange: _cache[1] || (_cache[1] = (...args) => ($setup.handleChange(...args))),
      multiple: $props.multiple,
      accept: $props.accept
    }, null, 40 /* PROPS, HYDRATE_EVENTS */, ["name", "multiple", "accept"])
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$y.render = render$w;
script$y.__file = "packages/upload/src/upload.vue";

/**
 * Show migrating guide in browser console.
 *
 * Usage:
 * import Migrating from 'element-ui/src/mixins/migrating';
 *
 * mixins: [Migrating]
 *
 * add getMigratingConfig method for your component.
 *  getMigratingConfig() {
 *    return {
 *      props: {
 *        'allow-no-selection': 'allow-no-selection is removed.',
 *        'selection-mode': 'selection-mode is removed.'
 *      },
 *      events: {
 *        selectionchange: 'selectionchange is renamed to selection-change.'
 *      }
 *    };
 *  },
 */

var Migrating = {
  mounted() {
    if (process.env.NODE_ENV === 'production') return;
    if (!this.$vnode) return;
    const {
      props = {},
      events = {}
    } = this.getMigratingConfig();
    const {
      data,
      componentOptions
    } = this.$vnode;
    const definedProps = data.attrs || {};
    const definedEvents = componentOptions.listeners || {};

    for (let propName in definedProps) {
      propName = kebabCase(propName); // compatible with camel case

      if (props[propName]) {
        console.warn(`[Element Migrating][${this.$options.name}][Attribute]: ${props[propName]}`);
      }
    }

    for (let eventName in definedEvents) {
      eventName = kebabCase(eventName); // compatible with camel case

      if (events[eventName]) {
        console.warn(`[Element Migrating][${this.$options.name}][Event]: ${events[eventName]}`);
      }
    }
  },

  methods: {
    getMigratingConfig() {
      return {
        props: {},
        events: {}
      };
    }

  }
};

function noop$1() {}

var script$z = {
  name: 'ElUpload',
  mixins: [Migrating],
  components: {
    UploadList: script$w,
    Upload: script$y
  },

  provide() {
    return {
      uploader: this
    };
  },

  inject: {
    elForm: {
      default: ''
    }
  },
  props: {
    action: {
      type: String,
      required: true
    },
    headers: {
      type: Object,

      default() {
        return {};
      }

    },
    data: Object,
    multiple: Boolean,
    name: {
      type: String,
      default: 'file'
    },
    drag: Boolean,
    dragger: Boolean,
    withCredentials: Boolean,
    showFileList: {
      type: Boolean,
      default: true
    },
    accept: String,
    type: {
      type: String,
      default: 'select'
    },
    beforeUpload: Function,
    beforeRemove: Function,
    onRemove: {
      type: Function,
      default: noop$1
    },
    onChange: {
      type: Function,
      default: noop$1
    },
    onPreview: {
      type: Function
    },
    onSuccess: {
      type: Function,
      default: noop$1
    },
    onProgress: {
      type: Function,
      default: noop$1
    },
    onError: {
      type: Function,
      default: noop$1
    },
    fileList: {
      type: Array,

      default() {
        return [];
      }

    },
    autoUpload: {
      type: Boolean,
      default: true
    },
    listType: {
      type: String,
      default: 'text' // text,picture,picture-card

    },
    httpRequest: Function,
    disabled: Boolean,
    limit: Number,
    onExceed: {
      type: Function,
      default: noop$1
    }
  },

  setup(props) {
    const {
      disabled,
      listType,
      fileList
    } = toRefs(props); // eslint-disable-next-line vue/no-setup-props-destructure

    const {
      onRemove,
      beforeRemove,
      onProgress,
      onSuccess,
      onError,
      onChange
    } = props;
    let tempIndex = 1;
    let uploadFiles = reactive(fileList.value.map(item => {
      item.uid = item.uid || Date.now() + tempIndex++;
      item.status = item.status || 'success';
      return item;
    }));
    const dragOver = ref(false);
    const draging = ref(false);
    const uploadInner = ref(null);
    const uploadDisabled = computed(() => {
      const elForm = inject('elForm', {});
      return disabled.value || unref((elForm || {}).disabled);
    });
    watch(listType, type => {
      if (type === 'picture-card' || type === 'picture') {
        uploadFiles.forEach(file => {
          if (!file.url && file.raw) {
            try {
              file.url = URL.createObjectURL(file.raw);
            } catch (err) {
              console.error('[Element Error][Upload]', err);
            }
          }
        });
      }
    });
    onUnmounted(() => {
      uploadFiles.forEach(file => {
        if (file.url && file.url.indexOf('blob:') === 0) {
          URL.revokeObjectURL(file.url);
        }
      });
    });

    const abort = file => {
      uploadInner.value.abort(file);
    };

    const getFile = rawFile => {
      const fileList = uploadFiles;
      let target;
      fileList.every(item => {
        target = rawFile.uid === item.uid ? item : null;
        return !target;
      });
      return target;
    };

    const handleRemove = (file, raw) => {
      if (raw) {
        file = getFile(raw);
      }

      const doRemove = () => {
        abort(file);
        const fileList = uploadFiles;
        fileList.splice(fileList.indexOf(file), 1);
        onRemove(file, fileList);
      };

      if (!beforeRemove) {
        doRemove();
      } else if (typeof beforeRemove === 'function') {
        const before = beforeRemove(file, uploadFiles);

        if (before && before.then) {
          before.then(() => {
            doRemove();
          }, noop$1);
        } else if (before !== false) {
          doRemove();
        }
      }
    };

    const handleProgress = (ev, rawFile) => {
      const file = getFile(rawFile);
      onProgress(ev, file, uploadFiles);
      file.status = 'uploading';
      file.percentage = ev.percent || 0;
    };

    const handleSuccess = (res, rawFile) => {
      const file = getFile(rawFile);

      if (file) {
        file.status = 'success';
        file.response = res;
        onSuccess(res, file, uploadFiles);
        onChange(file, uploadFiles);
      }
    };

    const handleError = (err, rawFile) => {
      const file = getFile(rawFile);
      const fileList = uploadFiles;
      file.status = 'fail';
      fileList.splice(fileList.indexOf(file), 1);
      onError(err, file, uploadFiles);
      onChange(file, uploadFiles);
    };

    const handleStart = rawFile => {
      rawFile.uid = Date.now() + tempIndex++;
      const file = {
        status: 'ready',
        name: rawFile.name,
        size: rawFile.size,
        percentage: 0,
        uid: rawFile.uid,
        raw: rawFile
      };

      if (unref(listType) === 'picture-card' || unref(listType) === 'picture') {
        try {
          file.url = URL.createObjectURL(rawFile);
        } catch (err) {
          console.error('[Element Error][Upload]', err);
          return;
        }
      }

      uploadFiles.push(file);
      onChange(file, uploadFiles);
    };

    const clearFiles = () => {
      uploadFiles = [];
    };

    const submit = () => {
      uploadFiles.filter(file => file.status === 'ready').forEach(file => {
        uploadInner.value.upload(file.raw);
      });
    };

    const getMigratingConfig = () => {
      return {
        props: {
          'default-file-list': 'default-file-list is renamed to file-list.',
          'show-upload-list': 'show-upload-list is renamed to show-file-list.',
          'thumbnail-mode': 'thumbnail-mode has been deprecated, you can implement the same effect according to this case: http://element.eleme.io/#/zh-CN/component/upload#yong-hu-tou-xiang-shang-chuan'
        }
      };
    };

    return {
      uploadFiles,
      uploadInner,
      dragOver,
      draging,
      uploadDisabled,
      handleRemove,
      abort,
      handleStart,
      handleProgress,
      handleSuccess,
      handleError,
      clearFiles,
      submit,
      getMigratingConfig
    };
  }

};

const _hoisted_1$h = { key: 1 };

function render$x(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_UploadList = resolveComponent("UploadList");
  const _component_upload = resolveComponent("upload");

  return (openBlock(), createBlock("div", null, [
    ($props.listType === 'picture-card' && $props.showFileList)
      ? (openBlock(), createBlock(_component_UploadList, {
          key: 0,
          disabled: $setup.uploadDisabled,
          listType: $props.listType,
          files: $setup.uploadFiles,
          onRemove: $setup.handleRemove,
          handlePreview: $props.onPreview
        }, createSlots({ _: 2 }, [
          (_ctx.$slots.file)
            ? {
                name: "default",
                fn: withCtx((props) => [
                  renderSlot(_ctx.$slots, "file", {
                    file: props.file
                  })
                ])
              }
            : undefined
        ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["disabled", "listType", "files", "onRemove", "handlePreview"]))
      : createCommentVNode("v-if", true),
    (_ctx.$slots.trigger)
      ? (openBlock(), createBlock("div", _hoisted_1$h, [
          createVNode(_component_upload, {
            type: $props.type,
            drag: $props.drag,
            action: $props.action,
            multiple: $props.multiple,
            "before-upload": $props.beforeUpload,
            "with-credentials": $props.withCredentials,
            headers: $props.headers,
            name: $props.name,
            data: $props.data,
            accept: $props.accept,
            fileList: $setup.uploadFiles,
            autoUpload: $props.autoUpload,
            listType: $props.listType,
            disabled: $setup.uploadDisabled,
            limit: $props.limit,
            onExceed: $props.onExceed,
            onStart: $setup.handleStart,
            onProgress: $setup.handleProgress,
            onSuccess: $setup.handleSuccess,
            onError: $setup.handleError,
            onPreview: $props.onPreview,
            onRemove: $setup.handleRemove,
            "http-request": $props.httpRequest,
            ref: "uploadInner"
          }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "trigger")
            ]),
            _: 3
          }, 8 /* PROPS */, ["type", "drag", "action", "multiple", "before-upload", "with-credentials", "headers", "name", "data", "accept", "fileList", "autoUpload", "listType", "disabled", "limit", "onExceed", "onStart", "onProgress", "onSuccess", "onError", "onPreview", "onRemove", "http-request"]),
          renderSlot(_ctx.$slots, "default")
        ]))
      : (openBlock(), createBlock(_component_upload, {
          key: 2,
          type: $props.type,
          drag: $props.drag,
          action: $props.action,
          multiple: $props.multiple,
          "before-upload": $props.beforeUpload,
          "with-credentials": $props.withCredentials,
          headers: $props.headers,
          name: $props.name,
          data: $props.data,
          accept: $props.accept,
          fileList: $setup.uploadFiles,
          autoUpload: $props.autoUpload,
          listType: $props.listType,
          disabled: $setup.uploadDisabled,
          limit: $props.limit,
          onExceed: $props.onExceed,
          onStart: $setup.handleStart,
          onProgress: $setup.handleProgress,
          onSuccess: $setup.handleSuccess,
          onError: $setup.handleError,
          onPreview: $props.onPreview,
          onRemove: $setup.handleRemove,
          "http-request": $props.httpRequest,
          ref: "uploadInner"
        }, {
          default: withCtx(() => [
            renderSlot(_ctx.$slots, "trigger"),
            renderSlot(_ctx.$slots, "default")
          ]),
          _: 3
        }, 8 /* PROPS */, ["type", "drag", "action", "multiple", "before-upload", "with-credentials", "headers", "name", "data", "accept", "fileList", "autoUpload", "listType", "disabled", "limit", "onExceed", "onStart", "onProgress", "onSuccess", "onError", "onPreview", "onRemove", "http-request"])),
    renderSlot(_ctx.$slots, "tip"),
    ($props.listType !== 'picture-card' && $props.showFileList)
      ? (openBlock(), createBlock(_component_UploadList, {
          key: 3,
          disabled: $setup.uploadDisabled,
          listType: $props.listType,
          files: $setup.uploadFiles,
          onRemove: $setup.handleRemove,
          handlePreview: $props.onPreview
        }, createSlots({ _: 2 }, [
          (_ctx.$slots.file)
            ? {
                name: "default",
                fn: withCtx((props) => [
                  renderSlot(_ctx.$slots, "file", {
                    file: props.file
                  })
                ])
              }
            : undefined
        ]), 1032 /* PROPS, DYNAMIC_SLOTS */, ["disabled", "listType", "files", "onRemove", "handlePreview"]))
      : createCommentVNode("v-if", true)
  ]))
}

script$z.render = render$x;
script$z.__file = "packages/upload/src/index.vue";

/* istanbul ignore next */

script$z.install = function (app) {
  app.component(script$z.name, script$z);
};

var script$A = {
  name: 'ElRate',
  props: {
    modelValue: {
      type: Number,
      default: 0
    },
    lowThreshold: {
      type: Number,
      default: 2
    },
    highThreshold: {
      type: Number,
      default: 4
    },
    max: {
      type: Number,
      default: 5
    },
    colors: {
      type: [Array, Object],

      default() {
        return ['#F7BA2A', '#F7BA2A', '#F7BA2A'];
      }

    },
    voidColor: {
      type: String,
      default: '#C6D1DE'
    },
    disabledVoidColor: {
      type: String,
      default: '#EFF2F7'
    },
    iconClasses: {
      type: [Array, Object],

      default() {
        return ['el-icon-star-on', 'el-icon-star-on', 'el-icon-star-on'];
      }

    },
    voidIconClass: {
      type: String,
      default: 'el-icon-star-off'
    },
    disabledVoidIconClass: {
      type: String,
      default: 'el-icon-star-on'
    },
    disabled: {
      type: Boolean,
      default: false
    },
    allowHalf: {
      type: Boolean,
      default: false
    },
    showText: {
      type: Boolean,
      default: false
    },
    showScore: {
      type: Boolean,
      default: false
    },
    textColor: {
      type: String,
      default: '#1f2d3d'
    },
    texts: {
      type: Array,

      default() {
        return ['极差', '失望', '一般', '满意', '惊喜'];
      }

    },
    scoreTemplate: {
      type: String,
      default: '{value}'
    }
  },
  emits: ['update:modelValue', 'change'],

  setup(props, {
    emit
  }) {
    const {
      modelValue,
      disabled,
      allowHalf,
      disabledVoidIconClass,
      voidIconClass,
      iconClasses,
      max,
      lowThreshold,
      highThreshold,
      texts,
      colors,
      voidColor,
      disabledVoidColor,
      showScore,
      scoreTemplate,
      showText
    } = toRefs(props);
    migrating({
      'text-template': 'text-template is renamed to score-template.'
    });
    modelValue || emit('update:modelValue', 0);
    const elForm = inject('elForm', {});
    const rateDisabled = useDisabled$1(disabled, elForm);
    const {
      currentValue,
      hoverIndex,
      pointerAtLeftHalf,
      setCurrentValue,
      resetCurrentValue,
      selectValue,
      handleKey
    } = useCurrentValue({
      modelValue,
      allowHalf,
      rateDisabled,
      max
    });
    const {
      classMap,
      colorMap
    } = useMaps({
      colors,
      iconClasses,
      lowThreshold,
      highThreshold,
      max
    });
    const {
      classes,
      decimalIconClass
    } = useClasses$1({
      currentValue,
      modelValue,
      classMap,
      allowHalf,
      max,
      rateDisabled,
      disabledVoidIconClass,
      voidIconClass
    });
    const {
      activeColor,
      getIconStyle
    } = useColor({
      currentValue,
      colorMap,
      rateDisabled,
      disabledVoidColor,
      voidColorProp: voidColor
    });
    const {
      decimalStyle,
      showDecimalIcon
    } = useDecimal({
      currentValue,
      modelValue,
      allowHalf,
      rateDisabled,
      pointerAtLeftHalf,
      activeColor
    });
    const text = computed(() => {
      let result = '';

      if (showScore.value) {
        result = scoreTemplate.value.replace(/\{\s*value\s*\}/, unref(rateDisabled) ? modelValue.value : currentValue.value);
      } else if (showText.value) {
        result = texts.value[Math.ceil(currentValue.value) - 1];
      }

      return result;
    });
    return {
      // state
      rateDisabled,
      classMap,
      classes,
      text,
      hoverIndex,
      decimalStyle,
      decimalIconClass,
      // methods
      getIconStyle,
      setCurrentValue,
      resetCurrentValue,
      selectValue,
      handleKey,
      showDecimalIcon
    };
  }

};

const getValueFromMap = (value, map) => {
  map = unref(map);
  const matchedKeys = Object.keys(map).filter(key => {
    const val = map[key];
    const excluded = val instanceof Object ? val.excluded : false;
    return excluded ? value < key : value <= key;
  }).sort((a, b) => a - b);
  const matchedValue = map[matchedKeys[0]];
  return matchedValue instanceof Object ? matchedValue.value : matchedValue || '';
};

const useDisabled$1 = (disabled, elForm) => {
  return computed(() => disabled.value || elForm.disabled);
};

const useMaps = ({
  colors,
  iconClasses,
  lowThreshold,
  highThreshold,
  max
}) => {
  const useMap = (mapData, {
    lowThreshold,
    highThreshold,
    max
  }) => {
    return computed(() => Array.isArray(mapData) ? {
      [lowThreshold.value]: mapData[0],
      [highThreshold.value]: {
        value: mapData[1],
        excluded: true
      },
      [max.value]: mapData[2]
    } : mapData);
  };

  return {
    classMap: useMap(unref(iconClasses), {
      lowThreshold,
      highThreshold,
      max
    }),
    colorMap: useMap(unref(colors), {
      lowThreshold,
      highThreshold,
      max
    })
  };
};

const useClasses$1 = ({
  currentValue,
  modelValue,
  classMap,
  allowHalf,
  max,
  rateDisabled,
  disabledVoidIconClass,
  voidIconClass
}) => {
  const activeClass = computed(() => getValueFromMap(currentValue.value, unref(classMap)));
  const voidClass = computed(() => unref(rateDisabled) ? disabledVoidIconClass.value : voidIconClass.value);
  const decimalIconClass = computed(() => getValueFromMap(modelValue.value, unref(classMap)));
  const classes = computed(() => {
    const result = [];
    let i = 0;
    let threshold = currentValue.value;

    if (allowHalf.value && currentValue.value !== Math.floor(currentValue.value)) {
      threshold--;
    }

    for (; i < threshold; i++) {
      result.push(activeClass.value);
    }

    for (; i < max.value; i++) {
      result.push(voidClass.value);
    }

    return result;
  });
  return {
    classes,
    decimalIconClass
  };
};

const useColor = ({
  currentValue,
  colorMap,
  rateDisabled,
  disabledVoidColor,
  voidColorProp
}) => {
  const activeColor = computed(() => getValueFromMap(currentValue.value, colorMap));

  const getIconStyle = item => {
    const voidColor = rateDisabled.value ? disabledVoidColor.value : voidColorProp.value;
    return {
      color: unref(item <= currentValue.value ? activeColor.value : voidColor)
    };
  };

  return {
    activeColor,
    getIconStyle
  };
};

const useDecimal = ({
  currentValue,
  modelValue,
  allowHalf,
  rateDisabled,
  pointerAtLeftHalf,
  activeColor
}) => {
  const valueDecimal = computed(() => modelValue.value * 100 - Math.floor(modelValue.value) * 100);
  const decimalStyle = computed(() => {
    let width = '';

    if (unref(rateDisabled)) {
      width = `${valueDecimal.value}%`;
    } else if (allowHalf.value) {
      width = '50%';
    }

    return {
      color: activeColor.value,
      width
    };
  });

  const showDecimalIcon = item => {
    const showWhenDisabled = unref(rateDisabled) && valueDecimal.value > 0 && item - 1 < modelValue.value && item > modelValue.value;
    /* istanbul ignore next */

    const showWhenAllowHalf = allowHalf.value && pointerAtLeftHalf && item - 0.5 <= currentValue.value && item > currentValue.value;
    return showWhenDisabled || showWhenAllowHalf;
  };

  return {
    decimalStyle,
    showDecimalIcon
  };
};

const useCurrentValue = ({
  modelValue,
  allowHalf,
  rateDisabled,
  max
}) => {
  const {
    emit
  } = getCurrentInstance();
  const currentValue = ref(modelValue.value);
  const pointerAtLeftHalf = ref(false);
  const hoverIndex = ref(-1);
  watch(modelValue, v => {
    currentValue.value = v;
  });

  const setCurrentValue = (value, event) => {
    if (rateDisabled.value) {
      return;
    }
    /* istanbul ignore if */


    if (allowHalf.value) {
      let target = event.target;

      if (hasClass(target, 'el-rate__item')) {
        target = target.querySelector('.el-rate__icon');
      }

      if (hasClass(target, 'el-rate__decimal')) {
        target = target.parentNode;
      }

      pointerAtLeftHalf.value = event.offsetX * 2 <= target.clientWidth;
      currentValue.value = pointerAtLeftHalf.value ? value - 0.5 : value;
    } else {
      currentValue.value = value;
    }

    hoverIndex.value = value;
  };

  const resetCurrentValue = () => {
    if (rateDisabled.value) {
      return;
    }

    if (allowHalf.value) {
      pointerAtLeftHalf.value = modelValue.value !== Math.floor(modelValue.value);
    }

    currentValue.value = modelValue.value;
    hoverIndex.value = -1;
  };

  const selectValue = value => {
    if (rateDisabled.value) {
      return;
    }

    if (allowHalf.value && pointerAtLeftHalf.value) {
      emit('update:modelValue', currentValue.value);
      emit('change', currentValue.value);
    } else {
      emit('update:modelValue', value);
      emit('change', value);
    }
  };

  const handleKey = e => {
    if (rateDisabled.value) {
      return;
    }

    let value = currentValue.value;
    const keyCode = e.keyCode;

    if (keyCode === 38 || keyCode === 39) {
      // left / down
      if (allowHalf.value) {
        value += 0.5;
      } else {
        value += 1;
      }

      e.stopPropagation();
      e.preventDefault();
    } else if (keyCode === 37 || keyCode === 40) {
      if (allowHalf.value) {
        value -= 0.5;
      } else {
        value -= 1;
      }

      e.stopPropagation();
      e.preventDefault();
    }

    value = value < 0 ? 0 : value;
    value = value > max.value ? max.value : value;
    emit('update:modelValue', value);
    emit('change', value);
  };

  return {
    currentValue,
    hoverIndex,
    pointerAtLeftHalf,
    setCurrentValue,
    resetCurrentValue,
    selectValue,
    handleKey
  };
};

function render$y(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: "el-rate",
    onKeydown: _cache[2] || (_cache[2] = (...args) => ($setup.handleKey(...args))),
    role: "slider",
    "aria-valuenow": $props.modelValue,
    "aria-valuetext": $setup.text,
    "aria-valuemin": "0",
    "aria-valuemax": $props.max,
    tabindex: "0"
  }, [
    (openBlock(true), createBlock(Fragment, null, renderList($props.max, (item, key) => {
      return (openBlock(), createBlock("span", {
        class: "el-rate__item",
        onMousemove: $event => ($setup.setCurrentValue(item, $event)),
        onMouseleave: _cache[1] || (_cache[1] = (...args) => ($setup.resetCurrentValue(...args))),
        onClick: $event => ($setup.selectValue(item)),
        style: { cursor: $setup.rateDisabled ? 'auto' : 'pointer' },
        key: key
      }, [
        createVNode("i", {
          class: ["el-rate__icon", [$setup.classes[item - 1], { hover: $setup.hoverIndex === item }]],
          style: $setup.getIconStyle(item)
        }, [
          ($setup.showDecimalIcon(item))
            ? (openBlock(), createBlock("i", {
                key: 0,
                class: ["el-rate__decimal", $setup.decimalIconClass],
                style: $setup.decimalStyle
              }, null, 6 /* CLASS, STYLE */))
            : createCommentVNode("v-if", true)
        ], 6 /* CLASS, STYLE */)
      ], 44 /* STYLE, PROPS, HYDRATE_EVENTS */, ["onMousemove", "onClick"]))
    }), 128 /* KEYED_FRAGMENT */)),
    ($props.showText || $props.showScore)
      ? (openBlock(), createBlock("span", {
          key: 0,
          class: "el-rate__text",
          style: { color: $props.textColor }
        }, toDisplayString($setup.text), 5 /* TEXT, STYLE */))
      : createCommentVNode("v-if", true)
  ], 40 /* PROPS, HYDRATE_EVENTS */, ["aria-valuenow", "aria-valuetext", "aria-valuemax"]))
}

script$A.render = render$y;
script$A.__file = "packages/rate/Rate.vue";

/* istanbul ignore next */

script$A.install = function (app) {
  app.component(script$A.name, script$A);
};

/* eslint-disable no-case-declarations */

/* eslint-disable prefer-const */
const hsv2hsl = function (hue, sat, val) {
  return [hue, sat * val / ((hue = (2 - sat) * val) < 1 ? hue : 2 - hue) || 0, hue / 2];
}; // Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1
// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>


const isOnePointZero = function (n) {
  return typeof n === 'string' && n.indexOf('.') !== -1 && parseFloat(n) === 1;
};

const isPercentage = function (n) {
  return typeof n === 'string' && n.indexOf('%') !== -1;
}; // Take input from [0, n] and return it as [0, 1]


const bound01 = function (value, max) {
  if (isOnePointZero(value)) value = '100%';
  const processPercent = isPercentage(value);
  value = Math.min(max, Math.max(0, parseFloat(value))); // Automatically convert percentage into number

  if (processPercent) {
    value = parseInt(value * max, 10) / 100;
  } // Handle floating point rounding errors


  if (Math.abs(value - max) < 0.000001) {
    return 1;
  } // Convert into [0, 1] range if it isn't already


  return value % max / parseFloat(max);
};

const INT_HEX_MAP = {
  10: 'A',
  11: 'B',
  12: 'C',
  13: 'D',
  14: 'E',
  15: 'F'
};

const toHex = function ({
  r,
  g,
  b
}) {
  const hexOne = function (value) {
    value = Math.min(Math.round(value), 255);
    const high = Math.floor(value / 16);
    const low = value % 16;
    return '' + (INT_HEX_MAP[high] || high) + (INT_HEX_MAP[low] || low);
  };

  if (isNaN(r) || isNaN(g) || isNaN(b)) return '';
  return '#' + hexOne(r) + hexOne(g) + hexOne(b);
};

const HEX_INT_MAP = {
  A: 10,
  B: 11,
  C: 12,
  D: 13,
  E: 14,
  F: 15
};

const parseHexChannel = function (hex) {
  if (hex.length === 2) {
    return (HEX_INT_MAP[hex[0].toUpperCase()] || +hex[0]) * 16 + (HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1]);
  }

  return HEX_INT_MAP[hex[1].toUpperCase()] || +hex[1];
};

const hsl2hsv = function (hue, sat, light) {
  sat = sat / 100;
  light = light / 100;
  let smin = sat;
  const lmin = Math.max(light, 0.01);
  let sv;
  let v;
  light *= 2;
  sat *= light <= 1 ? light : 2 - light;
  smin *= lmin <= 1 ? lmin : 2 - lmin;
  v = (light + sat) / 2;
  sv = light === 0 ? 2 * smin / (lmin + smin) : 2 * sat / (light + sat);
  return {
    h: hue,
    s: sv * 100,
    v: v * 100
  };
}; // `rgbToHsv`
// Converts an RGB color value to HSV
// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]
// *Returns:* { h, s, v } in [0,1]


const rgb2hsv = function (r, g, b) {
  r = bound01(r, 255);
  g = bound01(g, 255);
  b = bound01(b, 255);
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  let h, s;
  const v = max;
  const d = max - min;
  s = max === 0 ? 0 : d / max;

  if (max === min) {
    h = 0; // achromatic
  } else {
    switch (max) {
      case r:
        h = (g - b) / d + (g < b ? 6 : 0);
        break;

      case g:
        h = (b - r) / d + 2;
        break;

      case b:
        h = (r - g) / d + 4;
        break;
    }

    h /= 6;
  }

  return {
    h: h * 360,
    s: s * 100,
    v: v * 100
  };
}; // `hsvToRgb`
// Converts an HSV color value to RGB.
// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]
// *Returns:* { r, g, b } in the set [0, 255]


const hsv2rgb = function (h, s, v) {
  h = bound01(h, 360) * 6;
  s = bound01(s, 100);
  v = bound01(v, 100);
  const i = Math.floor(h);
  const f = h - i;
  const p = v * (1 - s);
  const q = v * (1 - f * s);
  const t = v * (1 - (1 - f) * s);
  const mod = i % 6;
  const r = [v, q, p, p, t, v][mod];
  const g = [t, v, v, q, p, p][mod];
  const b = [p, p, t, v, v, q][mod];
  return {
    r: Math.round(r * 255),
    g: Math.round(g * 255),
    b: Math.round(b * 255)
  };
};

class Color {
  constructor(options) {
    this._hue = 0;
    this._saturation = 100;
    this._value = 100;
    this._alpha = 100;
    this.enableAlpha = false;
    this.format = 'hex';
    this.value = '';
    options = options || {};

    for (const option in options) {
      if (Object.hasOwnProperty.call(options, option)) {
        this[option] = options[option];
      }
    }

    this.doOnChange();
  }

  set(prop, value) {
    if (arguments.length === 1 && typeof prop === 'object') {
      for (const p in prop) {
        if (Object.hasOwnProperty.call(prop, p)) {
          this.set(p, prop[p]);
        }
      }

      return;
    }

    this['_' + prop] = value;
    this.doOnChange();
  }

  get(prop) {
    return this['_' + prop];
  }

  toRgb() {
    return hsv2rgb(this._hue, this._saturation, this._value);
  }

  fromString(value) {
    if (!value) {
      this._hue = 0;
      this._saturation = 100;
      this._value = 100;
      this.doOnChange();
      return;
    }

    const fromHSV = (h, s, v) => {
      this._hue = Math.max(0, Math.min(360, h));
      this._saturation = Math.max(0, Math.min(100, s));
      this._value = Math.max(0, Math.min(100, v));
      this.doOnChange();
    };

    if (value.indexOf('hsl') !== -1) {
      const parts = value.replace(/hsla|hsl|\(|\)/gm, '').split(/\s|,/g).filter(val => val !== '').map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));

      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }

      if (parts.length >= 3) {
        const {
          h,
          s,
          v
        } = hsl2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h, s, v);
      }
    } else if (value.indexOf('hsv') !== -1) {
      const parts = value.replace(/hsva|hsv|\(|\)/gm, '').split(/\s|,/g).filter(val => val !== '').map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));

      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }

      if (parts.length >= 3) {
        fromHSV(parts[0], parts[1], parts[2]);
      }
    } else if (value.indexOf('rgb') !== -1) {
      const parts = value.replace(/rgba|rgb|\(|\)/gm, '').split(/\s|,/g).filter(val => val !== '').map((val, index) => index > 2 ? parseFloat(val) : parseInt(val, 10));

      if (parts.length === 4) {
        this._alpha = Math.floor(parseFloat(parts[3]) * 100);
      } else if (parts.length === 3) {
        this._alpha = 100;
      }

      if (parts.length >= 3) {
        const {
          h,
          s,
          v
        } = rgb2hsv(parts[0], parts[1], parts[2]);
        fromHSV(h, s, v);
      }
    } else if (value.indexOf('#') !== -1) {
      const hex = value.replace('#', '').trim();
      if (!/^(?:[0-9a-fA-F]{3}){1,2}$/.test(hex)) return;
      let r, g, b;

      if (hex.length === 3) {
        r = parseHexChannel(hex[0] + hex[0]);
        g = parseHexChannel(hex[1] + hex[1]);
        b = parseHexChannel(hex[2] + hex[2]);
      } else if (hex.length === 6 || hex.length === 8) {
        r = parseHexChannel(hex.substring(0, 2));
        g = parseHexChannel(hex.substring(2, 4));
        b = parseHexChannel(hex.substring(4, 6));
      }

      if (hex.length === 8) {
        this._alpha = Math.floor(parseHexChannel(hex.substring(6)) / 255 * 100);
      } else if (hex.length === 3 || hex.length === 6) {
        this._alpha = 100;
      }

      const {
        h,
        s,
        v
      } = rgb2hsv(r, g, b);
      fromHSV(h, s, v);
    }
  }

  compare(color) {
    return Math.abs(color._hue - this._hue) < 2 && Math.abs(color._saturation - this._saturation) < 1 && Math.abs(color._value - this._value) < 1 && Math.abs(color._alpha - this._alpha) < 1;
  }

  doOnChange() {
    const {
      _hue,
      _saturation,
      _value,
      _alpha,
      format
    } = this;

    if (this.enableAlpha) {
      switch (format) {
        case 'hsl':
          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = `hsla(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%, ${_alpha / 100})`;
          break;

        case 'hsv':
          this.value = `hsva(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%, ${_alpha / 100})`;
          break;

        default:
          const {
            r,
            g,
            b
          } = hsv2rgb(_hue, _saturation, _value);
          this.value = `rgba(${r}, ${g}, ${b}, ${_alpha / 100})`;
      }
    } else {
      switch (format) {
        case 'hsl':
          const hsl = hsv2hsl(_hue, _saturation / 100, _value / 100);
          this.value = `hsl(${_hue}, ${Math.round(hsl[1] * 100)}%, ${Math.round(hsl[2] * 100)}%)`;
          break;

        case 'hsv':
          this.value = `hsv(${_hue}, ${Math.round(_saturation)}%, ${Math.round(_value)}%)`;
          break;

        case 'rgb':
          const {
            r,
            g,
            b
          } = hsv2rgb(_hue, _saturation, _value);
          this.value = `rgb(${r}, ${g}, ${b})`;
          break;

        default:
          this.value = toHex(hsv2rgb(_hue, _saturation, _value));
      }
    }
  }

}

let isDragging = false;
function draggable (element, options) {
  // if (Vue.prototype.$isServer) return
  const moveFn = function (event) {
    if (options.drag) {
      options.drag(event);
    }
  };

  const upFn = function (event) {
    document.removeEventListener('mousemove', moveFn);
    document.removeEventListener('mouseup', upFn);
    document.onselectstart = null;
    document.ondragstart = null;
    isDragging = false;

    if (options.end) {
      options.end(event);
    }
  };

  element.addEventListener('mousedown', function (event) {
    if (isDragging) return;

    document.onselectstart = function () {
      return false;
    };

    document.ondragstart = function () {
      return false;
    };

    document.addEventListener('mousemove', moveFn);
    document.addEventListener('mouseup', upFn);
    isDragging = true;

    if (options.start) {
      options.start(event);
    }
  });
}

var script$B = {
  name: 'el-sl-panel',
  props: {
    color: {
      required: true
    }
  },

  setup(props) {
    const state = reactive({
      cursorTop: 0,
      cursorLeft: 0,
      background: 'hsl(0, 100%, 50%)'
    });
    const instance = getCurrentInstance();
    const colorValue = computed(() => {
      const hue = props.color.get('hue');
      const value = props.color.get('value');
      return {
        hue,
        value
      };
    });
    watch(colorValue, update);
    onMounted(() => {
      draggable(instance.refs.panel, {
        drag: handleDrag,
        end: handleDrag
      });
      update();
    });

    function update() {
      const saturation = props.color.get('saturation');
      const value = props.color.get('value');
      const el = instance.refs.panel;
      const {
        clientWidth: width,
        clientHeight: height
      } = el;
      state.cursorLeft = saturation * width / 100;
      state.cursorTop = (100 - value) * height / 100;
      state.background = 'hsl(' + props.color.get('hue') + ', 100%, 50%)';
    }

    function handleDrag(event) {
      const el = instance.refs.panel;
      const rect = el.getBoundingClientRect();
      let left = event.clientX - rect.left;
      let top = event.clientY - rect.top;
      left = Math.max(0, left);
      left = Math.min(left, rect.width);
      top = Math.max(0, top);
      top = Math.min(top, rect.height);
      state.cursorLeft = left;
      state.cursorTop = top;
      props.color.set({
        saturation: left / rect.width * 100,
        value: 100 - top / rect.height * 100
      });
    }

    return { ...toRefs(state),
      handleDrag,
      update
    };
  }

};

const _hoisted_1$i = /*#__PURE__*/createVNode("div", { class: "el-color-svpanel__white" }, null, -1 /* HOISTED */);
const _hoisted_2$a = /*#__PURE__*/createVNode("div", { class: "el-color-svpanel__black" }, null, -1 /* HOISTED */);
const _hoisted_3$7 = /*#__PURE__*/createVNode("div", null, null, -1 /* HOISTED */);

function render$z(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: "el-color-svpanel",
    ref: "panel",
    style: {
      backgroundColor: _ctx.background
    }
  }, [
    _hoisted_1$i,
    _hoisted_2$a,
    createVNode("div", {
      class: "el-color-svpanel__cursor",
      style: {
        top: _ctx.cursorTop + 'px',
        left: _ctx.cursorLeft + 'px'
      }
    }, [
      _hoisted_3$7
    ], 4 /* STYLE */)
  ], 4 /* STYLE */))
}

script$B.render = render$z;
script$B.__file = "packages/color-picker/src/components/sv-panel.vue";

var script$C = {
  name: 'el-color-hue-slider',
  props: {
    color: {
      required: true
    },
    vertical: Boolean
  },

  setup(props) {
    const instance = getCurrentInstance();
    const state = reactive({
      thumbLeft: 0,
      thumbTop: 0
    });
    const hueValue = computed(() => {
      return props.color.get('hue');
    });
    watch(hueValue, update);

    function handleClick(event) {
      const {
        thumb
      } = state;
      const target = event.target;

      if (target !== thumb) {
        handleDrag(event);
      }
    }

    function handleDrag(event) {
      const rect = instance.ctx.$el.getBoundingClientRect();
      const {
        thumb
      } = instance.refs;
      let hue;

      if (!props.vertical) {
        let left = event.clientX - rect.left;
        left = Math.min(left, rect.width - thumb.offsetWidth / 2);
        left = Math.max(thumb.offsetWidth / 2, left);
        hue = Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 360);
      } else {
        let top = event.clientY - rect.top;
        top = Math.min(top, rect.height - thumb.offsetHeight / 2);
        top = Math.max(thumb.offsetHeight / 2, top);
        hue = Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 360);
      }

      props.color.set('hue', hue);
    }

    function getThumbLeft() {
      if (props.vertical) return 0;
      const el = instance.ctx.$el;
      const hue = props.color.get('hue');
      if (!el) return 0;
      const thumb = instance.refs.thumb;
      return Math.round(hue * (el.offsetWidth - thumb.offsetWidth / 2) / 360);
    }

    function getThumbTop() {
      if (!props.vertical) return 0;
      const el = instance.ctx.$el;
      const hue = props.color.get('hue');
      if (!el) return 0;
      const thumb = instance.refs.thumb;
      return Math.round(hue * (el.offsetHeight - thumb.offsetHeight / 2) / 360);
    }

    function update() {
      state.thumbLeft = getThumbLeft();
      state.thumbTop = getThumbTop();
    }

    onMounted(() => {
      const {
        bar,
        thumb
      } = instance.refs;
      const dragConfig = {
        drag: event => handleDrag(event),
        end: event => handleDrag(event)
      };
      draggable(bar, dragConfig);
      draggable(thumb, dragConfig);
      update();
    });
    return { ...toRefs(state),
      handleClick,
      update
    };
  }

};

function render$A(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-color-hue-slider", { 'is-vertical': $props.vertical }]
  }, [
    createVNode("div", {
      class: "el-color-hue-slider__bar",
      onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleClick(...args))),
      ref: "bar"
    }, null, 512 /* NEED_PATCH */),
    createVNode("div", {
      class: "el-color-hue-slider__thumb",
      style: {
        left: _ctx.thumbLeft + 'px',
        top: _ctx.thumbTop + 'px'
      },
      ref: "thumb"
    }, null, 4 /* STYLE */)
  ], 2 /* CLASS */))
}

script$C.render = render$A;
script$C.__file = "packages/color-picker/src/components/hue-slider.vue";

var script$D = {
  name: 'el-color-alpha-slider',
  props: {
    color: {
      required: true
    },
    vertical: Boolean
  },

  setup(props) {
    const state = reactive({
      thumbLeft: 0,
      thumbTop: 0,
      background: null
    });
    const instance = getCurrentInstance();
    watch(props.color, update); // watch(() => props.color.value, update)

    onMounted(() => {
      const {
        bar,
        thumb
      } = instance.refs;
      const dragConfig = {
        drag: event => {
          handleDrag(event);
        },
        end: event => {
          handleDrag(event);
        }
      };
      draggable(bar, dragConfig);
      draggable(thumb, dragConfig);
      update();
    });

    function handleClick(event) {
      const thumb = instance.refs.thumb;
      const target = event.target;

      if (target !== thumb) {
        handleDrag(event);
      }
    }

    function handleDrag(event) {
      const rect = instance.ctx.$el.getBoundingClientRect();
      const {
        thumb
      } = instance.refs;

      if (!props.vertical) {
        let left = event.clientX - rect.left;
        left = Math.max(thumb.offsetWidth / 2, left);
        left = Math.min(left, rect.width - thumb.offsetWidth / 2);
        props.color.set('alpha', Math.round((left - thumb.offsetWidth / 2) / (rect.width - thumb.offsetWidth) * 100));
      } else {
        let top = event.clientY - rect.top;
        top = Math.max(thumb.offsetHeight / 2, top);
        top = Math.min(top, rect.height - thumb.offsetHeight / 2);
        props.color.set('alpha', Math.round((top - thumb.offsetHeight / 2) / (rect.height - thumb.offsetHeight) * 100));
      }
    }

    function getThumbLeft() {
      if (props.vertical) return 0;
      const el = instance.ctx.$el;
      const alpha = props.color._alpha;
      if (!el) return 0;
      const thumb = instance.refs.thumb;
      return Math.round(alpha * (el.offsetWidth - thumb.offsetWidth / 2) / 100);
    }

    function getThumbTop() {
      if (!props.vertical) return 0;
      const el = instance.ctx.$el;
      const alpha = props.color._alpha;
      if (!el) return 0;
      const thumb = instance.refs.thumb;
      return Math.round(alpha * (el.offsetHeight - thumb.offsetHeight / 2) / 100);
    }

    function getBackground() {
      if (props.color && props.color.value) {
        const {
          r,
          g,
          b
        } = props.color.toRgb();
        return `linear-gradient(to right, rgba(${r}, ${g}, ${b}, 0) 0%, rgba(${r}, ${g}, ${b}, 1) 100%)`;
      }

      return null;
    }

    function update() {
      state.thumbLeft = getThumbLeft();
      state.thumbTop = getThumbTop();
      state.background = getBackground();
    }

    return { ...toRefs(state),
      handleClick,
      update
    };
  }

};

function render$B(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-color-alpha-slider", { 'is-vertical': $props.vertical }]
  }, [
    createVNode("div", {
      class: "el-color-alpha-slider__bar",
      onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleClick(...args))),
      ref: "bar",
      style: {
        background: _ctx.background
      }
    }, null, 4 /* STYLE */),
    createVNode("div", {
      class: "el-color-alpha-slider__thumb",
      ref: "thumb",
      style: {
        left: _ctx.thumbLeft + 'px',
        top: _ctx.thumbTop + 'px'
      }
    }, null, 4 /* STYLE */)
  ], 2 /* CLASS */))
}

script$D.render = render$B;
script$D.__file = "packages/color-picker/src/components/alpha-slider.vue";

var script$E = {
  props: {
    colors: {
      type: Array,
      required: true
    },
    color: {
      required: true
    }
  },

  setup(props) {
    const state = reactive({
      rgbaColors: parseColors(props.colors, props.color)
    });
    const currentColor = inject('currentColor');
    watch(currentColor, val => {
      const color = new Color();
      color.fromString(val);
      state.rgbaColors.forEach(item => {
        item.selected = color.compare(item);
      });
    });
    watch(props.colors, newVal => {
      state.rgbaColors = parseColors(newVal, props.color);
    });
    watch(props.color, newVal => {
      state.rgbaColors = parseColors(props.colors, newVal);
    });

    function handleSelect(index) {
      props.color.fromString(props.colors[index]);
    }

    function parseColors(colors, color) {
      return colors.map(value => {
        const c = new Color();
        c.enableAlpha = true;
        c.format = 'rgba';
        c.fromString(value);
        c.selected = c.value === color.value;
        return c;
      });
    }

    return { ...toRefs(state),
      handleSelect
    };
  }

};

const _hoisted_1$j = { class: "el-color-predefine" };
const _hoisted_2$b = { class: "el-color-predefine__colors" };

function render$C(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$j, [
    createVNode("div", _hoisted_2$b, [
      (openBlock(true), createBlock(Fragment, null, renderList(_ctx.rgbaColors, (item, index) => {
        return (openBlock(), createBlock("div", {
          class: ["el-color-predefine__color-selector", { selected: item.selected, 'is-alpha': item._alpha < 100 }],
          key: $props.colors[index],
          onClick: $event => ($setup.handleSelect(index))
        }, [
          createVNode("div", {
            style: { 'background-color': item.value }
          }, null, 4 /* STYLE */)
        ], 10 /* CLASS, PROPS */, ["onClick"]))
      }), 128 /* KEYED_FRAGMENT */))
    ])
  ]))
}

script$E.render = render$C;
script$E.__file = "packages/color-picker/src/components/predefine.vue";

var script$F = {
  name: 'el-color-picker-dropdown',
  // mixins: [Popper, Locale],
  components: {
    SvPanel: script$B,
    HueSlider: script$C,
    AlphaSlider: script$D,
    ElInput: script$g,
    ElButton: script$7,
    Predefine: script$E
  },
  emits: ['pick', 'clear', 'update:modelValue', 'created'],
  props: { ...popperProps,
    disabled: {
      type: Boolean,
      default: false
    },
    color: {
      required: true
    },
    showAlpha: Boolean,
    predefine: Array,
    popperClass: String
  },

  setup(props, context) {
    const instance = getCurrentInstance();
    const state = reactive({
      customInput: '',
      popperElm: null,
      referenceElm: null,
      alpha: null
    });
    const referenceState = inject('referenceState');
    const popperState = usePopper(props, context, { ...toRefs(state)
    });
    const currentColor = computed(() => {
      const parent = instance.parent;
      return !parent || !parent.ctx.showPanelColor ? '' : parent.ctx.color.value;
    });
    provide('currentColor', currentColor);
    watch(popperState.showPopper, val => {
      if (val === true) {
        nextTick(() => {
          const {
            sl,
            hue,
            alpha
          } = instance.refs;
          sl && sl.update();
          hue && hue.update();
          alpha && alpha.update();
        });
      }
    });
    watch(currentColor, val => {
      state.customInput = val;
    }, {
      immediate: true
    });
    onMounted(() => {
      referenceState.popperElm = state.popperElm;
      state.referenceElm = referenceState.referenceElm;
    });

    function confirmValue() {
      context.emit('pick');
    }

    function handleConfirm() {
      props.color.fromString(state.customInput);
    }

    const t = useLocale();
    return { ...popperState,
      ...toRefs(state),
      confirmValue,
      handleConfirm,
      t
    };
  }

};

const _hoisted_1$k = { class: "el-color-dropdown__main-wrapper" };
const _hoisted_2$c = { class: "el-color-dropdown__btns" };
const _hoisted_3$8 = { class: "el-color-dropdown__value" };

function render$D(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_hue_slider = resolveComponent("hue-slider");
  const _component_sv_panel = resolveComponent("sv-panel");
  const _component_alpha_slider = resolveComponent("alpha-slider");
  const _component_predefine = resolveComponent("predefine");
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");

  return (openBlock(), createBlock(Teleport, { to: "body" }, [
    createVNode(Transition, {
      name: "el-zoom-in-top",
      onAfterLeaveFrom: _ctx.doDestroy
    }, {
      default: withCtx(() => [
        withDirectives(createVNode("div", {
          class: ["el-color-dropdown", ['el-color-picker__panel', $props.popperClass || '']],
          ref: "popperElm"
        }, [
          createVNode("div", _hoisted_1$k, [
            createVNode(_component_hue_slider, {
              ref: "hue",
              color: $props.color,
              vertical: "",
              style: {"float":"right"}
            }, null, 8 /* PROPS */, ["color"]),
            createVNode(_component_sv_panel, {
              ref: "sl",
              color: $props.color
            }, null, 8 /* PROPS */, ["color"])
          ]),
          ($props.showAlpha)
            ? (openBlock(), createBlock(_component_alpha_slider, {
                key: 0,
                ref: "alpha",
                color: $props.color
              }, null, 8 /* PROPS */, ["color"]))
            : createCommentVNode("v-if", true),
          ($props.predefine)
            ? (openBlock(), createBlock(_component_predefine, {
                key: 1,
                color: $props.color,
                colors: $props.predefine
              }, null, 8 /* PROPS */, ["color", "colors"]))
            : createCommentVNode("v-if", true),
          createVNode("div", _hoisted_2$c, [
            createVNode("span", _hoisted_3$8, [
              createVNode(_component_el_input, {
                modelValue: _ctx.customInput,
                "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (_ctx.customInput = $event)),
                onKeyup: withKeys($setup.handleConfirm, ["enter"]),
                onBlur: $setup.handleConfirm,
                "validate-event": false,
                size: "mini"
              }, null, 8 /* PROPS */, ["modelValue", "onKeyup", "onBlur"])
            ]),
            createVNode(_component_el_button, {
              size: "mini",
              type: "text",
              class: "el-color-dropdown__link-btn",
              onClick: _cache[2] || (_cache[2] = $event => (_ctx.$emit('clear')))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($setup.t('el.colorpicker.clear')), 1 /* TEXT */)
              ]),
              _: 1
            }),
            createVNode(_component_el_button, {
              plain: "",
              size: "mini",
              class: "el-color-dropdown__btn",
              onClick: $setup.confirmValue
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($setup.t('el.colorpicker.confirm')), 1 /* TEXT */)
              ]),
              _: 1
            }, 8 /* PROPS */, ["onClick"])
          ])
        ], 2 /* CLASS */), [
          [vShow, _ctx.showPopper]
        ])
      ]),
      _: 1
    }, 8 /* PROPS */, ["onAfterLeaveFrom"])
  ]))
}

script$F.render = render$D;
script$F.__file = "packages/color-picker/src/components/picker-dropdown.vue";

var script$G = {
  name: 'ElColorPicker',
  props: {
    modelValue: String,
    showAlpha: Boolean,
    colorFormat: String,
    disabled: Boolean,
    size: String,
    popperClass: String,
    predefine: Array
  },
  emits: ['active-change', 'input', 'change', 'update:modelValue'],

  setup(props, context) {
    const color = new Color({
      enableAlpha: props.showAlpha,
      format: props.colorFormat
    });
    const state = reactive({
      color,
      showPicker: false,
      showPanelColor: false,
      popperElm: null,
      referenceElm: null
    });
    provide('referenceState', state);
    inject('elForm', {});
    const {
      dispatch
    } = useEmitter();
    const elFormItem = inject('elFormItem', {});
    const elForm = inject('elForm', {});
    const displayedColor = computed(() => {
      if (!props.modelValue && !state.showPanelColor) {
        return 'transparent';
      }

      return displayedRgb(state.color, props.showAlpha);
    });

    const _elFormItemSize = computed(() => {
      return (elFormItem || {}).elFormItemSize;
    });

    const colorSize = computed(() => {
      return props.size || _elFormItemSize.value || (context.$ELEMENT || {}).size;
    });
    const colorDisabled = computed(() => {
      return props.disabled || (elForm || {}).disabled;
    });
    watch(() => props.modelValue, val => {
      if (!val) {
        state.showPanelColor = false;
      } else if (val && val !== state.color.value) {
        state.color.fromString(val);
      }
    });
    watch(state.color, () => state.showPanelColor = true, {
      deep: true
    });
    watch(displayedColor, val => {
      if (!state.showPicker) return;
      const currentValueColor = new Color({
        enableAlpha: props.showAlpha,
        format: props.colorFormat
      });

      if (val !== currentValueColor) {
        context.emit('active-change', val);
      }
    });
    onMounted(() => {
      const value = props.modelValue;

      if (value) {
        state.color.fromString(value);
      }
    });

    function displayedRgb(color, showAlpha) {
      if (!(color instanceof Color)) {
        throw Error('color should be instance of Color Class');
      }

      const {
        r,
        g,
        b
      } = color.toRgb();
      return showAlpha ? `rgba(${r}, ${g}, ${b}, ${color.get('alpha') / 100})` : `rgb(${r}, ${g}, ${b})`;
    }

    const handleTrigger = () => {
      if (colorDisabled.value) return;
      state.showPicker = !state.showPicker;
    };

    const confirmValue = () => {
      const value = state.color.value;
      context.emit('update:modelValue', value);
      context.emit('change', value);
      dispatch('ElFormItem', 'el.form.change', value);
      state.showPicker = false;
    };

    const clearValue = () => {
      context.emit('update:modelValue', null);
      context.emit('change', null);

      if (props.modelValue !== null) {
        dispatch('ElFormItem', 'el.form.change', null);
      }

      state.showPanelColor = false;
      state.showPicker = false;
      resetColor();
    };

    const hide = () => {
      state.showPicker = false;
      resetColor();
    };

    const resetColor = () => {
      nextTick(() => {
        if (props.modelValue) {
          state.color.fromString(props.modelValue);
        } else {
          state.showPanelColor = false;
        }
      });
    };

    return { ...toRefs(state),
      handleTrigger,
      confirmValue,
      clearValue,
      hide,
      displayedRgb,
      colorSize,
      colorDisabled,
      displayedColor
    };
  },

  directives: {
    Clickoutside
  },
  components: {
    PickerDropdown: script$F
  }
};

const _hoisted_1$l = {
  key: 0,
  class: "el-color-picker__mask"
};
const _hoisted_2$d = {
  key: 0,
  class: "el-color-picker__empty el-icon-close"
};
const _hoisted_3$9 = { class: "el-color-picker__icon el-icon-arrow-down" };

function render$E(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_picker_dropdown = resolveComponent("picker-dropdown");
  const _directive_clickoutside = resolveDirective("clickoutside");

  return withDirectives((openBlock(), createBlock("div", {
    class: [
      'el-color-picker',
      $setup.colorDisabled ? 'is-disabled' : '',
      $setup.colorSize ? `el-color-picker--${$setup.colorSize}` : ''
    ],
    ref: "referenceElm"
  }, [
    ($setup.colorDisabled)
      ? (openBlock(), createBlock("div", _hoisted_1$l))
      : createCommentVNode("v-if", true),
    createVNode("div", {
      class: "el-color-picker__trigger",
      onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleTrigger(...args)))
    }, [
      createVNode("span", {
        class: ["el-color-picker__color", { 'is-alpha': $props.showAlpha }]
      }, [
        createVNode("span", {
          class: "el-color-picker__color-inner",
          style: {
            backgroundColor: $setup.displayedColor
          }
        }, null, 4 /* STYLE */),
        (!$props.modelValue && !_ctx.showPanelColor)
          ? (openBlock(), createBlock("span", _hoisted_2$d))
          : createCommentVNode("v-if", true)
      ], 2 /* CLASS */),
      withDirectives(createVNode("span", _hoisted_3$9, null, 512 /* NEED_PATCH */), [
        [vShow, $props.modelValue || _ctx.showPanelColor]
      ])
    ]),
    createVNode(_component_picker_dropdown, {
      ref: "dropdown",
      popperClass: $props.popperClass,
      modelValue: _ctx.showPicker,
      "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => (_ctx.showPicker = $event)),
      onPick: $setup.confirmValue,
      onClear: $setup.clearValue,
      color: _ctx.color,
      "show-alpha": $props.showAlpha,
      predefine: $props.predefine
    }, null, 8 /* PROPS */, ["popperClass", "modelValue", "onPick", "onClear", "color", "show-alpha", "predefine"])
  ], 2 /* CLASS */)), [
    [_directive_clickoutside, $setup.hide]
  ])
}

script$G.render = render$E;
script$G.__file = "packages/color-picker/src/main.vue";

/* istanbul ignore next */

script$G.install = function (app) {
  app.component(script$G.name, script$G);
};

var script$H = {
  name: 'OptionContent',
  props: {
    option: Object,
    renderContent: Function,
    labelProp: String,
    keyProp: String
  },

  setup() {
    const defaultScopedSlots = inject('defaultScopedSlots');
    return {
      defaultScopedSlots
    };
  },

  render() {
    return this.renderContent ? this.renderContent(h, this.option) : this.defaultScopedSlots ? this.defaultScopedSlots({
      option: this.option
    }) : h('span', this.option[this.labelProp] || this.option[this.keyProp]);
  }

};

script$H.__file = "packages/transfer/src/OptionContent.vue";

var script$I = {
  name: 'ElTransferPanel',
  componentName: 'ElTransferPanel',
  emits: ['checked-change'],
  components: {
    ElCheckboxGroup: script$f,
    ElCheckbox: script$d,
    ElInput: script$g,
    OptionContent: script$H
  },
  props: {
    data: {
      type: Array,

      default() {
        return [];
      }

    },
    renderContent: Function,
    placeholder: String,
    title: String,
    filterable: Boolean,
    format: Object,
    filterMethod: Function,
    defaultChecked: Array,
    props: Object
  },

  setup(props, {
    emit,
    slots
  }) {
    const t = useLocale();
    const state = reactive({
      checked: [],
      allChecked: false,
      query: '',
      checkChangeByUser: true
    });
    const {
      filteredData,
      labelProp,
      keyProp,
      checkableData,
      checkedSummary,
      isIndeterminate,
      hasNoMatch,
      disabledProp,
      hasFooter
    } = useTransferPanelData(props, state, slots, emit);

    const handleAllCheckedChange = value => {
      state.checked = value ? checkableData.value.map(item => item[keyProp.value]) : [];
    };

    return {
      t,
      ...toRefs(state),
      filteredData,
      labelProp,
      keyProp,
      checkedSummary,
      isIndeterminate,
      hasNoMatch,
      disabledProp,
      hasFooter,
      handleAllCheckedChange
    };
  }

};

const useTransferPanelData = (props, state, slots, emit) => {
  const filteredData = computed(() => {
    const {
      data,
      filterMethod
    } = props;
    return data.filter(item => {
      if (typeof filterMethod === 'function') {
        return filterMethod(state.query, item);
      } else {
        const label = item[labelProp.value] || item[keyProp.value].toString();
        return label.toLowerCase().indexOf(state.query.toLowerCase()) > -1;
      }
    });
  });
  const labelProp = computed(() => {
    const {
      props: p
    } = props;
    return p.label || 'label';
  });
  const keyProp = computed(() => {
    const {
      props: p
    } = props;
    return p.key || 'key';
  });
  const checkableData = computed(() => filteredData.value.filter(item => !item[disabledProp.value]));
  const checkedSummary = computed(() => {
    const {
      data,
      format
    } = props;
    const checkedLength = state.checked.length;
    const dataLength = data.length;
    const {
      noChecked,
      hasChecked
    } = format;

    if (noChecked && hasChecked) {
      return checkedLength > 0 ? hasChecked.replace(/\${checked}/g, checkedLength).replace(/\${total}/g, dataLength) : noChecked.replace(/\${total}/g, dataLength);
    } else {
      return `${checkedLength}/${dataLength}`;
    }
  });
  const isIndeterminate = computed(() => {
    const checkedLength = state.checked.length;
    return checkedLength > 0 && checkedLength < checkableData.value.length;
  });
  const hasNoMatch = computed(() => state.query.length > 0 && filteredData.value.length === 0);
  const disabledProp = computed(() => props.props.disabled || 'disabled');
  const hasFooter = computed(() => !!slots.default()[0].children.length);

  const updateAllChecked = () => {
    const checkableDataKeys = checkableData.value.map(item => item[keyProp.value]);
    state.allChecked = checkableDataKeys.length > 0 && checkableDataKeys.every(item => state.checked.indexOf(item) > -1);
  };

  watch(() => checkableData.value, () => updateAllChecked());
  watch(() => props.data, () => {
    const checked = [];
    const filteredDataKeys = filteredData.value.map(item => item[keyProp.value]);
    state.checked.forEach(item => {
      if (filteredDataKeys.indexOf(item) > -1) {
        checked.push(item);
      }
    });
    state.checkChangeByUser = false;
    state.checked = checked;
  });
  watch(() => state.checked, (val, oldVal) => {
    updateAllChecked();

    if (state.checkChangeByUser) {
      const movedKeys = val.concat(oldVal).filter(v => val.indexOf(v) === -1 || oldVal.indexOf(v) === -1);
      emit('checked-change', val, movedKeys);
    } else {
      emit('checked-change', val);
      state.checkChangeByUser = true;
    }
  }, {
    deep: true
  });
  watch(() => props.defaultChecked, (val, oldVal) => {
    if (oldVal && val.length === oldVal.length && val.every(item => oldVal.indexOf(item) > -1)) return;
    const checked = [];
    const checkableDataKeys = checkableData.value.map(item => item[keyProp.value]);
    val.forEach(item => {
      if (checkableDataKeys.indexOf(item) > -1) {
        checked.push(item);
      }
    });
    state.checkChangeByUser = false;
    state.checked = checked;
  }, {
    immediate: true
  });
  return {
    filteredData,
    labelProp,
    keyProp,
    checkableData,
    checkedSummary,
    isIndeterminate,
    hasNoMatch,
    disabledProp,
    hasFooter,
    updateAllChecked
  };
};

const _hoisted_1$m = { class: "el-transfer-panel" };
const _hoisted_2$e = { class: "el-transfer-panel__header" };
const _hoisted_3$a = { class: "el-transfer-panel__filter" };
const _hoisted_4$4 = /*#__PURE__*/createVNode("i", { class: ['el-input__icon', 'el-icon-search'] }, null, -1 /* HOISTED */);
const _hoisted_5$4 = {
  key: 0,
  class: "el-transfer-panel__footer"
};

function render$F(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_input = resolveComponent("el-input");
  const _component_option_content = resolveComponent("option-content");
  const _component_el_checkbox_group = resolveComponent("el-checkbox-group");

  return (openBlock(), createBlock("div", _hoisted_1$m, [
    createVNode("p", _hoisted_2$e, [
      createVNode(_component_el_checkbox, {
        modelValue: _ctx.allChecked,
        "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (_ctx.allChecked = $event)),
        onChange: $setup.handleAllCheckedChange,
        indeterminate: $setup.isIndeterminate
      }, {
        default: withCtx(() => [
          createTextVNode(toDisplayString($props.title) + " ", 1 /* TEXT */),
          createVNode("span", null, toDisplayString($setup.checkedSummary), 1 /* TEXT */)
        ]),
        _: 1
      }, 8 /* PROPS */, ["modelValue", "onChange", "indeterminate"])
    ]),
    createVNode("div", {
      class: ['el-transfer-panel__body', $setup.hasFooter ? 'is-with-footer' : '']
    }, [
      createVNode("div", _hoisted_3$a, [
        ($props.filterable)
          ? (openBlock(), createBlock(_component_el_input, {
              key: 0,
              modelValue: _ctx.query,
              "onUpdate:modelValue": _cache[2] || (_cache[2] = $event => (_ctx.query = $event)),
              size: "small",
              clearable: "",
              placeholder: $props.placeholder
            }, {
              prefix: withCtx(() => [
                _hoisted_4$4
              ]),
              _: 1
            }, 8 /* PROPS */, ["modelValue", "placeholder"]))
          : createCommentVNode("v-if", true)
      ]),
      withDirectives(createVNode(_component_el_checkbox_group, {
        modelValue: _ctx.checked,
        "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => (_ctx.checked = $event)),
        class: [{ 'is-filterable': $props.filterable }, "el-transfer-panel__list"]
      }, {
        default: withCtx(() => [
          (openBlock(true), createBlock(Fragment, null, renderList($setup.filteredData, (item) => {
            return (openBlock(), createBlock(_component_el_checkbox, {
              class: "el-transfer-panel__item",
              label: item[$setup.keyProp],
              disabled: item[$setup.disabledProp],
              key: item[$setup.keyProp]
            }, {
              default: withCtx(() => [
                createVNode(_component_option_content, {
                  option: item,
                  "render-content": $props.renderContent,
                  "label-prop": $setup.labelProp,
                  "key-prop": $setup.keyProp
                }, null, 8 /* PROPS */, ["option", "render-content", "label-prop", "key-prop"])
              ]),
              _: 2
            }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["label", "disabled"]))
          }), 128 /* KEYED_FRAGMENT */))
        ]),
        _: 1
      }, 8 /* PROPS */, ["modelValue", "class"]), [
        [vShow, !$setup.hasNoMatch && $props.data.length > 0]
      ]),
      withDirectives(createVNode("p", { class: "el-transfer-panel__empty" }, toDisplayString($setup.t('el.transfer.noMatch')), 513 /* TEXT, NEED_PATCH */), [
        [vShow, $setup.hasNoMatch]
      ]),
      withDirectives(createVNode("p", { class: "el-transfer-panel__empty" }, toDisplayString($setup.t('el.transfer.noData')), 513 /* TEXT, NEED_PATCH */), [
        [vShow, $props.data.length === 0 && !$setup.hasNoMatch]
      ])
    ], 2 /* CLASS */),
    ($setup.hasFooter)
      ? (openBlock(), createBlock("p", _hoisted_5$4, [
          renderSlot(_ctx.$slots, "default")
        ]))
      : createCommentVNode("v-if", true)
  ]))
}

script$I.render = render$F;
script$I.__file = "packages/transfer/src/TransferPanel.vue";

var script$J = {
  name: 'ElTransfer',
  emits: ['update:modelValue', 'change', 'left-check-change', 'right-check-change'],
  components: {
    TransferPanel: script$I,
    ElButton: script$7
  },
  props: {
    data: {
      type: Array,

      default() {
        return [];
      }

    },
    titles: {
      type: Array,

      default() {
        return [];
      }

    },
    buttonTexts: {
      type: Array,

      default() {
        return [];
      }

    },
    filterPlaceholder: {
      type: String,
      default: ''
    },
    filterMethod: Function,
    leftDefaultChecked: {
      type: Array,

      default() {
        return [];
      }

    },
    rightDefaultChecked: {
      type: Array,

      default() {
        return [];
      }

    },
    renderContent: Function,
    modelValue: {
      type: Array,

      default() {
        return [];
      }

    },
    format: {
      type: Object,

      default() {
        return {};
      }

    },
    filterable: Boolean,
    props: {
      type: Object,

      default() {
        return {
          label: 'label',
          key: 'key',
          disabled: 'disabled'
        };
      }

    },
    targetOrder: {
      type: String,
      default: 'original'
    }
  },

  setup(props, {
    emit,
    slots
  }) {
    const t = useLocale();
    const leftChecked = ref([]);
    const rightChecked = ref([]); // $refs

    const leftPanel = ref(null);
    const rightPanel = ref(null);
    const hasButtonTexts = computed(() => props.buttonTexts.length === 2);

    const clearQuery = which => {
      if (which === 'left') {
        leftPanel.value.query = '';
      } else if (which === 'right') {
        rightPanel.value.query = '';
      }
    };

    watch(props.modelValue, val => emit('update:modelValue', val));
    provide('defaultScopedSlots', computed(() => slots.default));
    const {
      leftTransferPanelTitle,
      rightTransferPanelTitle,
      panelFilterPlaceholder,
      sourceData,
      targetData
    } = useTransferData(props, t);
    const {
      onSourceCheckedChange,
      onTargetCheckedChange,
      addToLeft,
      addToRight
    } = useTransferCheckedChange(props, emit, leftChecked, rightChecked);
    return {
      leftChecked,
      rightChecked,
      hasButtonTexts,
      sourceData,
      targetData,
      leftTransferPanelTitle,
      rightTransferPanelTitle,
      panelFilterPlaceholder,
      onSourceCheckedChange,
      onTargetCheckedChange,
      addToLeft,
      addToRight,
      clearQuery
    };
  }

};

const useTransferData = (props, t) => {
  const leftTransferPanelTitle = computed(() => props.titles[0] || t('el.transfer.titles.0'));
  const rightTransferPanelTitle = computed(() => props.titles[1] || t('el.transfer.titles.1'));
  const panelFilterPlaceholder = computed(() => props.filterPlaceholder || t('el.transfer.filterPlaceholder'));
  const dataObj = computed(() => {
    const {
      props: p,
      data
    } = props;
    const key = p.key;
    return data.reduce((o, cur) => (o[cur[key]] = cur) && o, {});
  });
  const sourceData = computed(() => {
    const {
      data,
      modelValue,
      props: p
    } = props;
    return data.filter(item => modelValue.indexOf(item[p.key]) === -1);
  });
  const targetData = computed(() => {
    const {
      data,
      modelValue,
      props: p,
      targetOrder
    } = props;

    if (targetOrder === 'original') {
      return data.filter(item => modelValue.indexOf(item[p.key]) > -1);
    } else {
      return modelValue.reduce((arr, cur) => {
        const val = dataObj.value[cur];

        if (val) {
          arr.push(val);
        }

        return arr;
      }, []);
    }
  });
  return {
    dataObj,
    sourceData,
    targetData,
    leftTransferPanelTitle,
    rightTransferPanelTitle,
    panelFilterPlaceholder
  };
};

const useTransferCheckedChange = (props, emit, leftChecked, rightChecked) => {
  const onSourceCheckedChange = (val, movedKeys) => {
    leftChecked.value = val;
    if (movedKeys === undefined) return;
    emit('left-check-change', val, movedKeys);
  };

  const onTargetCheckedChange = (val, movedKeys) => {
    rightChecked.value = val;
    if (movedKeys === undefined) return;
    emit('right-check-change', val, movedKeys);
  };

  const addToLeft = () => {
    const currentValue = props.modelValue.slice();
    rightChecked.value.forEach(item => {
      const index = currentValue.indexOf(item);

      if (index > -1) {
        currentValue.splice(index, 1);
      }
    });
    emit('update:modelValue', currentValue);
    emit('change', currentValue, 'left', rightChecked.value);
  };

  const addToRight = () => {
    const {
      modelValue,
      props: p,
      data,
      targetOrder
    } = props;
    let currentValue = modelValue.slice();
    const itemsToBeMoved = [];
    const key = p.key;
    data.forEach(item => {
      const itemKey = item[key];

      if (leftChecked.value.indexOf(itemKey) > -1 && modelValue.indexOf(itemKey) === -1) {
        itemsToBeMoved.push(itemKey);
      }
    });
    currentValue = targetOrder === 'unshift' ? itemsToBeMoved.concat(currentValue) : currentValue.concat(itemsToBeMoved);
    emit('update:modelValue', currentValue);
    emit('change', currentValue, 'right', leftChecked.value);
  };

  return {
    onSourceCheckedChange,
    onTargetCheckedChange,
    addToLeft,
    addToRight
  };
};

const _hoisted_1$n = { class: "el-transfer" };
const _hoisted_2$f = { class: "el-transfer__buttons" };
const _hoisted_3$b = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-left" }, null, -1 /* HOISTED */);
const _hoisted_4$5 = { key: 0 };
const _hoisted_5$5 = { key: 0 };
const _hoisted_6$2 = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-right" }, null, -1 /* HOISTED */);

function render$G(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_transfer_panel = resolveComponent("transfer-panel");
  const _component_el_button = resolveComponent("el-button");

  return (openBlock(), createBlock("div", _hoisted_1$n, [
    createVNode(_component_transfer_panel, mergeProps(_ctx.$props, {
      ref: "leftPanel",
      data: $setup.sourceData,
      title: $setup.leftTransferPanelTitle,
      "default-checked": $props.leftDefaultChecked,
      placeholder: $setup.panelFilterPlaceholder,
      onCheckedChange: $setup.onSourceCheckedChange
    }), {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "left-footer")
      ]),
      _: 1
    }, 16 /* FULL_PROPS */, ["data", "title", "default-checked", "placeholder", "onCheckedChange"]),
    createVNode("div", _hoisted_2$f, [
      createVNode(_component_el_button, {
        type: "primary",
        class: ['el-transfer__button', $setup.hasButtonTexts ? 'is-with-texts' : ''],
        onClick: $setup.addToLeft,
        disabled: $setup.rightChecked.length === 0
      }, {
        default: withCtx(() => [
          _hoisted_3$b,
          ($props.buttonTexts[0] !== undefined)
            ? (openBlock(), createBlock("span", _hoisted_4$5, toDisplayString($props.buttonTexts[0]), 1 /* TEXT */))
            : createCommentVNode("v-if", true)
        ]),
        _: 1
      }, 8 /* PROPS */, ["class", "onClick", "disabled"]),
      createVNode(_component_el_button, {
        type: "primary",
        class: ['el-transfer__button', $setup.hasButtonTexts ? 'is-with-texts' : ''],
        onClick: $setup.addToRight,
        disabled: $setup.leftChecked.length === 0
      }, {
        default: withCtx(() => [
          ($props.buttonTexts[1] !== undefined)
            ? (openBlock(), createBlock("span", _hoisted_5$5, toDisplayString($props.buttonTexts[1]), 1 /* TEXT */))
            : createCommentVNode("v-if", true),
          _hoisted_6$2
        ]),
        _: 1
      }, 8 /* PROPS */, ["class", "onClick", "disabled"])
    ]),
    createVNode(_component_transfer_panel, mergeProps(_ctx.$props, {
      ref: "rightPanel",
      data: $setup.targetData,
      title: $setup.rightTransferPanelTitle,
      "default-checked": $props.rightDefaultChecked,
      placeholder: $setup.panelFilterPlaceholder,
      onCheckedChange: $setup.onTargetCheckedChange
    }), {
      default: withCtx(() => [
        renderSlot(_ctx.$slots, "right-footer")
      ]),
      _: 1
    }, 16 /* FULL_PROPS */, ["data", "title", "default-checked", "placeholder", "onCheckedChange"])
  ]))
}

script$J.render = render$G;
script$J.__file = "packages/transfer/src/Transfer.vue";

/* istanbul ignore next */

script$J.install = function (app) {
  app.component(script$J.name, script$J);
};

var script$K = {
  name: 'ElForm',
  componentName: 'ElForm',
  props: {
    model: Object,
    rules: Object,
    labelPosition: String,
    labelWidth: String,
    labelSuffix: {
      type: String,
      default: ''
    },
    inline: Boolean,
    inlineMessage: Boolean,
    statusIcon: Boolean,
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String,
    disabled: Boolean,
    validateOnRuleChange: {
      type: Boolean,
      default: true
    },
    hideRequiredAsterisk: {
      type: Boolean,
      default: false
    }
  },
  emits: ['validate'],

  setup(props, {
    emit
  }) {
    const {
      model,
      rules,
      validateOnRuleChange,
      ...rest
    } = toRefs(props);
    const {
      autoLabelWidth,
      registerLabelWidth,
      deregisterLabelWidth
    } = useLabelWidth();
    const {
      fields,
      resetFields
    } = useFileds(model);
    const {
      validateField,
      validate,
      clearValidate
    } = useValidate$1(rules, model, fields, validateOnRuleChange);
    provide('elForm', reactive({
      name: 'ElForm',
      ...rest,
      model,
      rules,
      autoLabelWidth,
      registerLabelWidth,
      deregisterLabelWidth,
      resetFields,
      validateField,
      validate,
      clearValidate,
      emit
    }));
    return {
      validate,
      validateField,
      resetFields,
      clearValidate
    };
  }

};

const useLabelWidth = () => {
  const potentialLabelWidthArr = reactive([]);
  const autoLabelWidth = computed(() => {
    if (!potentialLabelWidthArr.length) return 0;
    const max = Math.max(...potentialLabelWidthArr);
    return max ? `${max}px` : '';
  });

  const getLabelWidthIndex = width => {
    const index = potentialLabelWidthArr.indexOf(width); // it's impossible

    if (index === -1) {
      throw new Error('[ElementForm]unpected width ', width);
    }

    return index;
  };

  const registerLabelWidth = (val, oldVal) => {
    if (val && oldVal) {
      const index = getLabelWidthIndex(oldVal);
      potentialLabelWidthArr.splice(index, 1, val);
    } else if (val) {
      potentialLabelWidthArr.push(val);
    }
  };

  const deregisterLabelWidth = val => {
    const index = getLabelWidthIndex(val);
    potentialLabelWidthArr.splice(index, 1);
  };

  return {
    autoLabelWidth,
    registerLabelWidth,
    deregisterLabelWidth
  };
};

const useFileds = model => {
  const fields = reactive([]);
  const {
    on
  } = useEmitter();
  on('el.form.addField', field => {
    if (field) {
      fields.push(field);
    }
  });
  on('el.form.removeField', field => {
    if (field.prop) {
      fields.splice(fields.indexOf(field), 1);
    }
  });

  const resetFields = () => {
    if (!unref(model)) {
      console.warn('[Element Warn][Form]model is required for resetFields to work.');
      return;
    }

    fields.forEach(field => {
      field.resetField();
    });
  };

  return {
    fields,
    resetFields
  };
};

const useValidate$1 = (rules, model, fields, validateOnRuleChange) => {
  const clearValidate = (props = []) => {
    const clearableFiles = props.length ? typeof props === 'string' ? fields.filter(field => props === field.prop) : fields.filter(field => props.includes(field.prop)) : fields;
    clearableFiles.forEach(field => {
      field.clearValidate();
    });
  };

  const validate = callback => {
    if (!model) {
      console.warn('[Element Warn][Form]model is required for validate to work!');
      return;
    }

    let promise; // if no callback, return promise

    if (typeof callback !== 'function') {
      promise = new window.Promise((resolve, reject) => {
        callback = function (valid) {
          valid ? resolve(valid) : reject(valid);
        };
      });
    }

    let valid = true;
    let count = 0; // 如果需要验证的fields为空，调用验证时立刻返回callback

    if (fields.length === 0 && callback) {
      callback(valid);
    }

    let invalidFields = {};
    fields.forEach(field => {
      field.validate('', (message, field) => {
        if (message) {
          valid = false;
        }

        invalidFields = merge({}, invalidFields, field);

        if (typeof callback === 'function' && ++count === fields.length) {
          callback(valid, invalidFields);
        }
      });
    });

    if (promise) {
      return promise;
    }
  };

  const validateField = (props, cb) => {
    props = [].concat(props);
    const validateFields = fields.filter(field => props.includes(field.prop));

    if (!validateFields.length) {
      console.warn('[Element Warn]please pass correct props!');
      return;
    }

    validateFields.forEach(field => {
      field.validate('', cb);
    });
  };

  if (rules) {
    watch(rules, () => {
      // remove then add event listeners on form-item after form rules change
      fields.forEach(field => {
        field.removeValidateEvents();
        field.addValidateEvents();
      });

      if (unref(validateOnRuleChange)) {
        validate(() => {});
      }
    });
  }

  return {
    validateField,
    validate,
    clearValidate
  };
};

function render$H(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("form", {
    class: ["el-form", [
      $props.labelPosition ? 'el-form--label-' + $props.labelPosition : '',
      { 'el-form--inline': $props.inline }
    ]]
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2 /* CLASS */))
}

script$K.render = render$H;
script$K.__file = "packages/form/Form.vue";

/* istanbul ignore next */

script$K.install = function (app) {
  app.component(script$K.name, script$K);
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

function _inheritsLoose(subClass, superClass) {
  subClass.prototype = Object.create(superClass.prototype);
  subClass.prototype.constructor = subClass;
  subClass.__proto__ = superClass;
}

function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}

function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };

  return _setPrototypeOf(o, p);
}

function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}

function _construct(Parent, args, Class) {
  if (_isNativeReflectConstruct()) {
    _construct = Reflect.construct;
  } else {
    _construct = function _construct(Parent, args, Class) {
      var a = [null];
      a.push.apply(a, args);
      var Constructor = Function.bind.apply(Parent, a);
      var instance = new Constructor();
      if (Class) _setPrototypeOf(instance, Class.prototype);
      return instance;
    };
  }

  return _construct.apply(null, arguments);
}

function _isNativeFunction(fn) {
  return Function.toString.call(fn).indexOf("[native code]") !== -1;
}

function _wrapNativeSuper(Class) {
  var _cache = typeof Map === "function" ? new Map() : undefined;

  _wrapNativeSuper = function _wrapNativeSuper(Class) {
    if (Class === null || !_isNativeFunction(Class)) return Class;

    if (typeof Class !== "function") {
      throw new TypeError("Super expression must either be null or a function");
    }

    if (typeof _cache !== "undefined") {
      if (_cache.has(Class)) return _cache.get(Class);

      _cache.set(Class, Wrapper);
    }

    function Wrapper() {
      return _construct(Class, arguments, _getPrototypeOf(this).constructor);
    }

    Wrapper.prototype = Object.create(Class.prototype, {
      constructor: {
        value: Wrapper,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    return _setPrototypeOf(Wrapper, Class);
  };

  return _wrapNativeSuper(Class);
}
/* eslint no-console:0 */


var formatRegExp = /%[sdj%]/g;

var warning = function warning() {}; // don't print warning message when in production env or node runtime


if (typeof process !== 'undefined' && process.env && process.env.NODE_ENV !== 'production' && typeof window !== 'undefined' && typeof document !== 'undefined') {
  warning = function warning(type, errors) {
    if (typeof console !== 'undefined' && console.warn) {
      if (errors.every(function (e) {
        return typeof e === 'string';
      })) {
        console.warn(type, errors);
      }
    }
  };
}

function convertFieldsError(errors) {
  if (!errors || !errors.length) return null;
  var fields = {};
  errors.forEach(function (error) {
    var field = error.field;
    fields[field] = fields[field] || [];
    fields[field].push(error);
  });
  return fields;
}

function format$1() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }

  var i = 1;
  var f = args[0];
  var len = args.length;

  if (typeof f === 'function') {
    return f.apply(null, args.slice(1));
  }

  if (typeof f === 'string') {
    var str = String(f).replace(formatRegExp, function (x) {
      if (x === '%%') {
        return '%';
      }

      if (i >= len) {
        return x;
      }

      switch (x) {
        case '%s':
          return String(args[i++]);

        case '%d':
          return Number(args[i++]);

        case '%j':
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return '[Circular]';
          }

          break;

        default:
          return x;
      }
    });
    return str;
  }

  return f;
}

function isNativeStringType(type) {
  return type === 'string' || type === 'url' || type === 'hex' || type === 'email' || type === 'date' || type === 'pattern';
}

function isEmptyValue(value, type) {
  if (value === undefined || value === null) {
    return true;
  }

  if (type === 'array' && Array.isArray(value) && !value.length) {
    return true;
  }

  if (isNativeStringType(type) && typeof value === 'string' && !value) {
    return true;
  }

  return false;
}

function asyncParallelArray(arr, func, callback) {
  var results = [];
  var total = 0;
  var arrLength = arr.length;

  function count(errors) {
    results.push.apply(results, errors);
    total++;

    if (total === arrLength) {
      callback(results);
    }
  }

  arr.forEach(function (a) {
    func(a, count);
  });
}

function asyncSerialArray(arr, func, callback) {
  var index = 0;
  var arrLength = arr.length;

  function next(errors) {
    if (errors && errors.length) {
      callback(errors);
      return;
    }

    var original = index;
    index = index + 1;

    if (original < arrLength) {
      func(arr[original], next);
    } else {
      callback([]);
    }
  }

  next([]);
}

function flattenObjArr(objArr) {
  var ret = [];
  Object.keys(objArr).forEach(function (k) {
    ret.push.apply(ret, objArr[k]);
  });
  return ret;
}

var AsyncValidationError = /*#__PURE__*/function (_Error) {
  _inheritsLoose(AsyncValidationError, _Error);

  function AsyncValidationError(errors, fields) {
    var _this;

    _this = _Error.call(this, 'Async Validation Error') || this;
    _this.errors = errors;
    _this.fields = fields;
    return _this;
  }

  return AsyncValidationError;
}( /*#__PURE__*/_wrapNativeSuper(Error));

function asyncMap(objArr, option, func, callback) {
  if (option.first) {
    var _pending = new Promise(function (resolve, reject) {
      var next = function next(errors) {
        callback(errors);
        return errors.length ? reject(new AsyncValidationError(errors, convertFieldsError(errors))) : resolve();
      };

      var flattenArr = flattenObjArr(objArr);
      asyncSerialArray(flattenArr, func, next);
    });

    _pending["catch"](function (e) {
      return e;
    });

    return _pending;
  }

  var firstFields = option.firstFields || [];

  if (firstFields === true) {
    firstFields = Object.keys(objArr);
  }

  var objArrKeys = Object.keys(objArr);
  var objArrLength = objArrKeys.length;
  var total = 0;
  var results = [];
  var pending = new Promise(function (resolve, reject) {
    var next = function next(errors) {
      results.push.apply(results, errors);
      total++;

      if (total === objArrLength) {
        callback(results);
        return results.length ? reject(new AsyncValidationError(results, convertFieldsError(results))) : resolve();
      }
    };

    if (!objArrKeys.length) {
      callback(results);
      resolve();
    }

    objArrKeys.forEach(function (key) {
      var arr = objArr[key];

      if (firstFields.indexOf(key) !== -1) {
        asyncSerialArray(arr, func, next);
      } else {
        asyncParallelArray(arr, func, next);
      }
    });
  });
  pending["catch"](function (e) {
    return e;
  });
  return pending;
}

function complementError(rule) {
  return function (oe) {
    if (oe && oe.message) {
      oe.field = oe.field || rule.fullField;
      return oe;
    }

    return {
      message: typeof oe === 'function' ? oe() : oe,
      field: oe.field || rule.fullField
    };
  };
}

function deepMerge(target, source) {
  if (source) {
    for (var s in source) {
      if (source.hasOwnProperty(s)) {
        var value = source[s];

        if (typeof value === 'object' && typeof target[s] === 'object') {
          target[s] = _extends(_extends({}, target[s]), value);
        } else {
          target[s] = value;
        }
      }
    }
  }

  return target;
}
/**
 *  Rule for validating required fields.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function required(rule, value, source, errors, options, type) {
  if (rule.required && (!source.hasOwnProperty(rule.field) || isEmptyValue(value, type || rule.type))) {
    errors.push(format$1(options.messages.required, rule.fullField));
  }
}
/**
 *  Rule for validating whitespace.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function whitespace(rule, value, source, errors, options) {
  if (/^\s+$/.test(value) || value === '') {
    errors.push(format$1(options.messages.whitespace, rule.fullField));
  }
}
/* eslint max-len:0 */


var pattern = {
  // http://emailregex.com/
  email: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/,
  url: new RegExp("^(?!mailto:)(?:(?:http|https|ftp)://|//)(?:\\S+(?::\\S*)?@)?(?:(?:(?:[1-9]\\d?|1\\d\\d|2[01]\\d|22[0-3])(?:\\.(?:1?\\d{1,2}|2[0-4]\\d|25[0-5])){2}(?:\\.(?:[0-9]\\d?|1\\d\\d|2[0-4]\\d|25[0-4]))|(?:(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)(?:\\.(?:[a-z\\u00a1-\\uffff0-9]+-*)*[a-z\\u00a1-\\uffff0-9]+)*(?:\\.(?:[a-z\\u00a1-\\uffff]{2,})))|localhost)(?::\\d{2,5})?(?:(/|\\?|#)[^\\s]*)?$", 'i'),
  hex: /^#?([a-f0-9]{6}|[a-f0-9]{3})$/i
};
var types = {
  integer: function integer(value) {
    return types.number(value) && parseInt(value, 10) === value;
  },
  "float": function float(value) {
    return types.number(value) && !types.integer(value);
  },
  array: function array(value) {
    return Array.isArray(value);
  },
  regexp: function regexp(value) {
    if (value instanceof RegExp) {
      return true;
    }

    try {
      return !!new RegExp(value);
    } catch (e) {
      return false;
    }
  },
  date: function date(value) {
    return typeof value.getTime === 'function' && typeof value.getMonth === 'function' && typeof value.getYear === 'function' && !isNaN(value.getTime());
  },
  number: function number(value) {
    if (isNaN(value)) {
      return false;
    }

    return typeof value === 'number';
  },
  object: function object(value) {
    return typeof value === 'object' && !types.array(value);
  },
  method: function method(value) {
    return typeof value === 'function';
  },
  email: function email(value) {
    return typeof value === 'string' && !!value.match(pattern.email) && value.length < 255;
  },
  url: function url(value) {
    return typeof value === 'string' && !!value.match(pattern.url);
  },
  hex: function hex(value) {
    return typeof value === 'string' && !!value.match(pattern.hex);
  }
};
/**
 *  Rule for validating the type of a value.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function type(rule, value, source, errors, options) {
  if (rule.required && value === undefined) {
    required(rule, value, source, errors, options);
    return;
  }

  var custom = ['integer', 'float', 'array', 'regexp', 'object', 'method', 'email', 'number', 'date', 'url', 'hex'];
  var ruleType = rule.type;

  if (custom.indexOf(ruleType) > -1) {
    if (!types[ruleType](value)) {
      errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
    } // straight typeof check

  } else if (ruleType && typeof value !== rule.type) {
    errors.push(format$1(options.messages.types[ruleType], rule.fullField, rule.type));
  }
}
/**
 *  Rule for validating minimum and maximum allowed values.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function range(rule, value, source, errors, options) {
  var len = typeof rule.len === 'number';
  var min = typeof rule.min === 'number';
  var max = typeof rule.max === 'number'; // 正则匹配码点范围从U+010000一直到U+10FFFF的文字（补充平面Supplementary Plane）

  var spRegexp = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g;
  var val = value;
  var key = null;
  var num = typeof value === 'number';
  var str = typeof value === 'string';
  var arr = Array.isArray(value);

  if (num) {
    key = 'number';
  } else if (str) {
    key = 'string';
  } else if (arr) {
    key = 'array';
  } // if the value is not of a supported type for range validation
  // the validation rule rule should use the
  // type property to also test for a particular type


  if (!key) {
    return false;
  }

  if (arr) {
    val = value.length;
  }

  if (str) {
    // 处理码点大于U+010000的文字length属性不准确的bug，如"𠮷𠮷𠮷".lenght !== 3
    val = value.replace(spRegexp, '_').length;
  }

  if (len) {
    if (val !== rule.len) {
      errors.push(format$1(options.messages[key].len, rule.fullField, rule.len));
    }
  } else if (min && !max && val < rule.min) {
    errors.push(format$1(options.messages[key].min, rule.fullField, rule.min));
  } else if (max && !min && val > rule.max) {
    errors.push(format$1(options.messages[key].max, rule.fullField, rule.max));
  } else if (min && max && (val < rule.min || val > rule.max)) {
    errors.push(format$1(options.messages[key].range, rule.fullField, rule.min, rule.max));
  }
}

var ENUM = 'enum';
/**
 *  Rule for validating a value exists in an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function enumerable(rule, value, source, errors, options) {
  rule[ENUM] = Array.isArray(rule[ENUM]) ? rule[ENUM] : [];

  if (rule[ENUM].indexOf(value) === -1) {
    errors.push(format$1(options.messages[ENUM], rule.fullField, rule[ENUM].join(', ')));
  }
}
/**
 *  Rule for validating a regular expression pattern.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param source The source object being validated.
 *  @param errors An array of errors that this rule may add
 *  validation errors to.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function pattern$1(rule, value, source, errors, options) {
  if (rule.pattern) {
    if (rule.pattern instanceof RegExp) {
      // if a RegExp instance is passed, reset `lastIndex` in case its `global`
      // flag is accidentally set to `true`, which in a validation scenario
      // is not necessary and the result might be misleading
      rule.pattern.lastIndex = 0;

      if (!rule.pattern.test(value)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    } else if (typeof rule.pattern === 'string') {
      var _pattern = new RegExp(rule.pattern);

      if (!_pattern.test(value)) {
        errors.push(format$1(options.messages.pattern.mismatch, rule.fullField, value, rule.pattern));
      }
    }
  }
}

var rules = {
  required: required,
  whitespace: whitespace,
  type: type,
  range: range,
  "enum": enumerable,
  pattern: pattern$1
};
/**
 *  Performs validation for string types.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function string(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'string');

    if (!isEmptyValue(value, 'string')) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
      rules.pattern(rule, value, source, errors, options);

      if (rule.whitespace === true) {
        rules.whitespace(rule, value, source, errors, options);
      }
    }
  }

  callback(errors);
}
/**
 *  Validates a function.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function method(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Validates a number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function number(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (value === '') {
      value = undefined;
    }

    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Validates a boolean.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function _boolean(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Validates the regular expression type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function regexp(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Validates a number is an integer.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function integer(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Validates a number is a floating point number.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function floatFn(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Validates an array.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function array(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'array') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, 'array');

    if (!isEmptyValue(value, 'array')) {
      rules.type(rule, value, source, errors, options);
      rules.range(rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Validates an object.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function object(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

var ENUM$1 = 'enum';
/**
 *  Validates an enumerable list.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */

function enumerable$1(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (value !== undefined) {
      rules[ENUM$1](rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Validates a regular expression pattern.
 *
 *  Performs validation when a rule only contains
 *  a pattern property but is not declared as a string type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function pattern$2(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, 'string') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'string')) {
      rules.pattern(rule, value, source, errors, options);
    }
  }

  callback(errors);
}

function date(rule, value, callback, source, options) {
  // console.log('integer rule called %j', rule);
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field); // console.log('validate on %s value', value);

  if (validate) {
    if (isEmptyValue(value, 'date') && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);

    if (!isEmptyValue(value, 'date')) {
      var dateObject;

      if (value instanceof Date) {
        dateObject = value;
      } else {
        dateObject = new Date(value);
      }

      rules.type(rule, dateObject, source, errors, options);

      if (dateObject) {
        rules.range(rule, dateObject.getTime(), source, errors, options);
      }
    }
  }

  callback(errors);
}

function required$1(rule, value, callback, source, options) {
  var errors = [];
  var type = Array.isArray(value) ? 'array' : typeof value;
  rules.required(rule, value, source, errors, options, type);
  callback(errors);
}

function type$1(rule, value, callback, source, options) {
  var ruleType = rule.type;
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value, ruleType) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options, ruleType);

    if (!isEmptyValue(value, ruleType)) {
      rules.type(rule, value, source, errors, options);
    }
  }

  callback(errors);
}
/**
 *  Performs validation for any type.
 *
 *  @param rule The validation rule.
 *  @param value The value of the field on the source object.
 *  @param callback The callback function.
 *  @param source The source object being validated.
 *  @param options The validation options.
 *  @param options.messages The validation messages.
 */


function any(rule, value, callback, source, options) {
  var errors = [];
  var validate = rule.required || !rule.required && source.hasOwnProperty(rule.field);

  if (validate) {
    if (isEmptyValue(value) && !rule.required) {
      return callback();
    }

    rules.required(rule, value, source, errors, options);
  }

  callback(errors);
}

var validators = {
  string: string,
  method: method,
  number: number,
  "boolean": _boolean,
  regexp: regexp,
  integer: integer,
  "float": floatFn,
  array: array,
  object: object,
  "enum": enumerable$1,
  pattern: pattern$2,
  date: date,
  url: type$1,
  hex: type$1,
  email: type$1,
  required: required$1,
  any: any
};

function newMessages() {
  return {
    "default": 'Validation error on field %s',
    required: '%s is required',
    "enum": '%s must be one of %s',
    whitespace: '%s cannot be empty',
    date: {
      format: '%s date %s is invalid for format %s',
      parse: '%s date could not be parsed, %s is invalid ',
      invalid: '%s date %s is invalid'
    },
    types: {
      string: '%s is not a %s',
      method: '%s is not a %s (function)',
      array: '%s is not an %s',
      object: '%s is not an %s',
      number: '%s is not a %s',
      date: '%s is not a %s',
      "boolean": '%s is not a %s',
      integer: '%s is not an %s',
      "float": '%s is not a %s',
      regexp: '%s is not a valid %s',
      email: '%s is not a valid %s',
      url: '%s is not a valid %s',
      hex: '%s is not a valid %s'
    },
    string: {
      len: '%s must be exactly %s characters',
      min: '%s must be at least %s characters',
      max: '%s cannot be longer than %s characters',
      range: '%s must be between %s and %s characters'
    },
    number: {
      len: '%s must equal %s',
      min: '%s cannot be less than %s',
      max: '%s cannot be greater than %s',
      range: '%s must be between %s and %s'
    },
    array: {
      len: '%s must be exactly %s in length',
      min: '%s cannot be less than %s in length',
      max: '%s cannot be greater than %s in length',
      range: '%s must be between %s and %s in length'
    },
    pattern: {
      mismatch: '%s value %s does not match pattern %s'
    },
    clone: function clone() {
      var cloned = JSON.parse(JSON.stringify(this));
      cloned.clone = this.clone;
      return cloned;
    }
  };
}

var messages = newMessages();
/**
 *  Encapsulates a validation schema.
 *
 *  @param descriptor An object declaring validation rules
 *  for this schema.
 */

function Schema(descriptor) {
  this.rules = null;
  this._messages = messages;
  this.define(descriptor);
}

Schema.prototype = {
  messages: function messages(_messages) {
    if (_messages) {
      this._messages = deepMerge(newMessages(), _messages);
    }

    return this._messages;
  },
  define: function define(rules) {
    if (!rules) {
      throw new Error('Cannot configure a schema with no rules');
    }

    if (typeof rules !== 'object' || Array.isArray(rules)) {
      throw new Error('Rules must be an object');
    }

    this.rules = {};
    var z;
    var item;

    for (z in rules) {
      if (rules.hasOwnProperty(z)) {
        item = rules[z];
        this.rules[z] = Array.isArray(item) ? item : [item];
      }
    }
  },
  validate: function validate(source_, o, oc) {
    var _this = this;

    if (o === void 0) {
      o = {};
    }

    if (oc === void 0) {
      oc = function oc() {};
    }

    var source = source_;
    var options = o;
    var callback = oc;

    if (typeof options === 'function') {
      callback = options;
      options = {};
    }

    if (!this.rules || Object.keys(this.rules).length === 0) {
      if (callback) {
        callback();
      }

      return Promise.resolve();
    }

    function complete(results) {
      var i;
      var errors = [];
      var fields = {};

      function add(e) {
        if (Array.isArray(e)) {
          var _errors;

          errors = (_errors = errors).concat.apply(_errors, e);
        } else {
          errors.push(e);
        }
      }

      for (i = 0; i < results.length; i++) {
        add(results[i]);
      }

      if (!errors.length) {
        errors = null;
        fields = null;
      } else {
        fields = convertFieldsError(errors);
      }

      callback(errors, fields);
    }

    if (options.messages) {
      var messages$1 = this.messages();

      if (messages$1 === messages) {
        messages$1 = newMessages();
      }

      deepMerge(messages$1, options.messages);
      options.messages = messages$1;
    } else {
      options.messages = this.messages();
    }

    var arr;
    var value;
    var series = {};
    var keys = options.keys || Object.keys(this.rules);
    keys.forEach(function (z) {
      arr = _this.rules[z];
      value = source[z];
      arr.forEach(function (r) {
        var rule = r;

        if (typeof rule.transform === 'function') {
          if (source === source_) {
            source = _extends({}, source);
          }

          value = source[z] = rule.transform(value);
        }

        if (typeof rule === 'function') {
          rule = {
            validator: rule
          };
        } else {
          rule = _extends({}, rule);
        }

        rule.validator = _this.getValidationMethod(rule);
        rule.field = z;
        rule.fullField = rule.fullField || z;
        rule.type = _this.getType(rule);

        if (!rule.validator) {
          return;
        }

        series[z] = series[z] || [];
        series[z].push({
          rule: rule,
          value: value,
          source: source,
          field: z
        });
      });
    });
    var errorFields = {};
    return asyncMap(series, options, function (data, doIt) {
      var rule = data.rule;
      var deep = (rule.type === 'object' || rule.type === 'array') && (typeof rule.fields === 'object' || typeof rule.defaultField === 'object');
      deep = deep && (rule.required || !rule.required && data.value);
      rule.field = data.field;

      function addFullfield(key, schema) {
        return _extends(_extends({}, schema), {}, {
          fullField: rule.fullField + "." + key
        });
      }

      function cb(e) {
        if (e === void 0) {
          e = [];
        }

        var errors = e;

        if (!Array.isArray(errors)) {
          errors = [errors];
        }

        if (!options.suppressWarning && errors.length) {
          Schema.warning('async-validator:', errors);
        }

        if (errors.length && rule.message) {
          errors = [].concat(rule.message);
        }

        errors = errors.map(complementError(rule));

        if (options.first && errors.length) {
          errorFields[rule.field] = 1;
          return doIt(errors);
        }

        if (!deep) {
          doIt(errors);
        } else {
          // if rule is required but the target object
          // does not exist fail at the rule level and don't
          // go deeper
          if (rule.required && !data.value) {
            if (rule.message) {
              errors = [].concat(rule.message).map(complementError(rule));
            } else if (options.error) {
              errors = [options.error(rule, format$1(options.messages.required, rule.field))];
            }

            return doIt(errors);
          }

          var fieldsSchema = {};

          if (rule.defaultField) {
            for (var k in data.value) {
              if (data.value.hasOwnProperty(k)) {
                fieldsSchema[k] = rule.defaultField;
              }
            }
          }

          fieldsSchema = _extends(_extends({}, fieldsSchema), data.rule.fields);

          for (var f in fieldsSchema) {
            if (fieldsSchema.hasOwnProperty(f)) {
              var fieldSchema = Array.isArray(fieldsSchema[f]) ? fieldsSchema[f] : [fieldsSchema[f]];
              fieldsSchema[f] = fieldSchema.map(addFullfield.bind(null, f));
            }
          }

          var schema = new Schema(fieldsSchema);
          schema.messages(options.messages);

          if (data.rule.options) {
            data.rule.options.messages = options.messages;
            data.rule.options.error = options.error;
          }

          schema.validate(data.value, data.rule.options || options, function (errs) {
            var finalErrors = [];

            if (errors && errors.length) {
              finalErrors.push.apply(finalErrors, errors);
            }

            if (errs && errs.length) {
              finalErrors.push.apply(finalErrors, errs);
            }

            doIt(finalErrors.length ? finalErrors : null);
          });
        }
      }

      var res;

      if (rule.asyncValidator) {
        res = rule.asyncValidator(rule, data.value, cb, data.source, options);
      } else if (rule.validator) {
        res = rule.validator(rule, data.value, cb, data.source, options);

        if (res === true) {
          cb();
        } else if (res === false) {
          cb(rule.message || rule.field + " fails");
        } else if (res instanceof Array) {
          cb(res);
        } else if (res instanceof Error) {
          cb(res.message);
        }
      }

      if (res && res.then) {
        res.then(function () {
          return cb();
        }, function (e) {
          return cb(e);
        });
      }
    }, function (results) {
      complete(results);
    });
  },
  getType: function getType(rule) {
    if (rule.type === undefined && rule.pattern instanceof RegExp) {
      rule.type = 'pattern';
    }

    if (typeof rule.validator !== 'function' && rule.type && !validators.hasOwnProperty(rule.type)) {
      throw new Error(format$1('Unknown rule type %s', rule.type));
    }

    return rule.type || 'string';
  },
  getValidationMethod: function getValidationMethod(rule) {
    if (typeof rule.validator === 'function') {
      return rule.validator;
    }

    var keys = Object.keys(rule);
    var messageIndex = keys.indexOf('message');

    if (messageIndex !== -1) {
      keys.splice(messageIndex, 1);
    }

    if (keys.length === 1 && keys[0] === 'required') {
      return validators.required;
    }

    return validators[this.getType(rule)] || false;
  }
};

Schema.register = function register(type, validator) {
  if (typeof validator !== 'function') {
    throw new Error('Cannot register a validator by type, validator is not a function');
  }

  validators[type] = validator;
};

Schema.warning = warning;
Schema.messages = messages;
Schema.validators = validators;

var script$L = {
  props: {
    isAutoWidth: Boolean,
    updateAll: Boolean
  },

  setup(props, {
    slots
  }) {
    const {
      labelStyle,
      labelRef
    } = useLabelWidth$1(props, slots);
    return () => {
      if (!slots.default) return null;

      if (props.isAutoWidth) {
        return createVNode("div", {
          "ref": labelRef,
          "class": "el-form-item__label-wrap",
          "style": labelStyle
        }, [slots.default()]);
      } else {
        return slots.default();
      }
    };
  }

};

function useLabelWidth$1(props, slots) {
  const computedWidth = ref(0);
  const labelRef = ref(null);

  const _elForm = inject('elForm');

  const _elFormItem = inject('elFormItem');

  const getLabelWidth = () => {
    const $el = unref(labelRef);

    if ($el && $el.firstElementChild) {
      const {
        width
      } = window.getComputedStyle($el.firstElementChild);
      return Math.ceil(parseFloat(width));
    } else {
      return 0;
    }
  };

  const updateLabelWidth = (action = 'update') => {
    const $el = unref(labelRef);

    if (slots.default && props.isAutoWidth && $el.firstElementChild) {
      if (action === 'update') {
        computedWidth.value = getLabelWidth();
      } else if (action === 'remove') {
        _elForm.deregisterLabelWidth(unref(computedWidth));
      }
    }
  };

  watch(computedWidth, (val, oldVal) => {
    if (props.updateAll) {
      _elForm.registerLabelWidth(val, oldVal);

      _elFormItem.updateComputedLabelWidth(val);
    }
  });
  const labelStyle = computed(() => {
    const autoLabelWidth = _elForm.autoLabelWidth;
    const style = {};

    if (autoLabelWidth && autoLabelWidth !== 'auto') {
      const marginLeft = parseInt(autoLabelWidth, 10) - unref(computedWidth);

      if (marginLeft) {
        style.marginLeft = marginLeft + 'px';
      }
    }

    return style;
  });
  onMounted(() => {
    updateLabelWidth('update');
  });
  onUpdated(() => {
    updateLabelWidth('update');
  });
  onBeforeUnmount(() => {
    updateLabelWidth('remove');
  });
  return {
    labelStyle,
    labelRef
  };
}

script$L.__file = "packages/form-item/LabelWrap.vue";

var script$M = {
  name: 'ElFormItem',
  componentName: 'ElFormItem',
  props: {
    label: String,
    labelWidth: String,
    prop: String,
    required: {
      type: Boolean,
      default: undefined
    },
    rules: [Object, Array],
    error: String,
    validateStatus: String,
    for: String,
    inlineMessage: {
      type: [String, Boolean],
      default: ''
    },
    showMessage: {
      type: Boolean,
      default: true
    },
    size: String
  },
  components: {
    // use this component to calculate auto width
    LabelWrap: script$L
  },

  setup(props) {
    const isNested = ref(false);
    const elForm = inject('elForm', {});
    const elFormItem = inject('elFormItem', null);
    isNested.value = !!elFormItem;
    useDispatchFiled(props);
    const {
      labelFor,
      labelStyle,
      computedLabelWidth,
      updateComputedLabelWidth
    } = useLabel(props, elForm);
    const {
      elFormItemSize,
      sizeClass
    } = useFontSize(props, elForm);
    const {
      getRules,
      getFilteredRule
    } = useRules(props, elForm);
    const {
      contentStyle
    } = useContentStyle(props, elForm, isNested, computedLabelWidth);
    const isRequired = useIsRequired(getRules);
    const {
      validateState,
      validateMessage,
      validateDisabled,
      validate,
      clearValidate,
      resetField
    } = useValidate$2(props, elForm, getFilteredRule);
    const {
      removeValidateEvents,
      addValidateEvents
    } = useValidateEvent(props, validate, getRules, validateDisabled);
    provide('elFormItem', reactive({
      name: 'ElFormItem',
      elFormItemSize,
      updateComputedLabelWidth,
      validateState
    }));
    return {
      labelFor,
      labelStyle,
      sizeClass,
      contentStyle,
      isRequired,
      validate,
      validateState,
      validateMessage,
      resetField,
      clearValidate,
      removeValidateEvents,
      addValidateEvents,
      elForm
    };
  }

};

function useLabel(props, elForm) {
  const computedLabelWidth = ref('');
  const labelFor = computed(() => props.for || props.prop);
  const labelStyle = computed(() => {
    const ret = {};
    if (elForm.labelPosition === 'top') return ret;
    const labelWidth = props.labelWidth || elForm.labelWidth;

    if (labelWidth) {
      ret.width = labelWidth;
    }

    return ret;
  });

  const updateComputedLabelWidth = width => {
    computedLabelWidth.value = width ? `${width}px` : '';
  };

  return {
    labelFor,
    labelStyle,
    computedLabelWidth,
    updateComputedLabelWidth
  };
}

function useFontSize(props, elForm) {
  const _this = getCurrentInstance();

  const elFormItemSize = computed(() => {
    return props.size || unref(elForm.size);
  });
  const sizeClass = computed(() => {
    return unref(elFormItemSize) || (_this.$ELEMENT || {}).size;
  });
  return {
    elFormItemSize,
    sizeClass
  };
}

function useContentStyle(props, elForm, isNested, computedLabelWidth) {
  const contentStyle = computed(() => {
    const ret = {};
    const label = props.label;
    if (elForm.labelPosition === 'top' || elForm.inline) return ret;
    if (!label && !props.labelWidth && unref(isNested)) return ret;
    const labelWidth = props.labelWidth || elForm.labelWidth;

    if (labelWidth === 'auto') {
      if (props.labelWidth === 'auto') {
        ret.marginLeft = unref(computedLabelWidth);
      } else if (elForm.labelWidth === 'auto') {
        ret.marginLeft = elForm.autoLabelWidth;
      }
    } else {
      ret.marginLeft = labelWidth;
    }

    return ret;
  });
  return {
    contentStyle
  };
}

function useFieldValue(props, elForm) {
  const initialValue = ref();
  const fieldValue = computed(() => {
    const model = elForm.model;

    if (!model || !props.prop) {
      return;
    }

    let path = props.prop;

    if (path.indexOf(':') !== -1) {
      path = path.replace(/:/, '.');
    }

    return getPropByPath(model, path, true).v;
  });
  onMounted(function () {
    if (props.prop) {
      initialValue.value = unref(fieldValue);

      if (Array.isArray(initialValue.value)) {
        initialValue.value = initialValue.value.slice();
      }
    }
  });
  return {
    fieldValue,
    initialValue
  };
}

function useDispatchFiled(props) {
  const {
    dispatch
  } = useEmitter();
  const {
    proxy
  } = getCurrentInstance();
  onMounted(() => {
    if (props.prop) {
      dispatch('el.form.addField', proxy);
    }
  });
  onBeforeUnmount(() => {
    dispatch('el.form.removeField', proxy);
  });
}

function useValidateEvent(props, validate, getRules, validateDisabled) {
  const {
    on,
    off
  } = useEmitter();

  const onFieldBlur = () => {
    validate('blur');
  };

  const onFieldChange = () => {
    if (unref(validateDisabled)) {
      validateDisabled.value = false;
      return;
    }

    validate('change');
  };

  const addValidateEvents = () => {
    const rules = getRules();

    if (rules.length || props.required !== undefined) {
      on('el.form.blur', onFieldBlur);
      on('el.form.change', onFieldChange);
    }
  };

  onMounted(() => {
    if (props.prop) {
      addValidateEvents();
    }
  });
  return {
    removeValidateEvents: off,
    addValidateEvents
  };
}

const useIsRequired = getRules => {
  return computed(() => {
    const rules = getRules();
    let isRequired = false;

    if (rules && rules.length) {
      rules.every(rule => {
        if (rule.required) {
          isRequired = true;
          return false;
        }

        return true;
      });
    }

    return isRequired;
  });
};

const useRules = (props, elForm) => {
  const getRules = () => {
    let formRules = elForm.rules;
    const selfRules = props.rules;
    const requiredRule = props.required !== undefined ? {
      required: !!props.required
    } : [];
    const prop = getPropByPath(formRules, props.prop || '');
    formRules = formRules ? prop.o[props.prop || ''] || prop.v : [];
    return [].concat(selfRules || formRules || []).concat(requiredRule);
  };

  const getFilteredRule = trigger => {
    const rules = getRules();
    return rules.filter(rule => {
      if (!rule.trigger || trigger === '') return true;

      if (Array.isArray(rule.trigger)) {
        return rule.trigger.indexOf(trigger) > -1;
      } else {
        return rule.trigger === trigger;
      }
    }).map(rule => merge({}, rule));
  };

  return {
    getRules,
    getFilteredRule
  };
};

function useValidate$2(props, elForm, getFilteredRule) {
  const {
    fieldValue,
    initialValue
  } = useFieldValue(props, elForm);
  const {
    broadcast
  } = useEmitter();
  const validateState = ref('');
  const validateMessage = ref('');
  const validateDisabled = ref(false);
  watch(() => props.error, value => {
    validateMessage.value = value;
    validateState.value = value ? 'error' : '';
  }, {
    immediate: true
  });
  watch(() => props.validateStatus, value => validateState.value = value);

  const validate = (trigger, callback = noop) => {
    validateDisabled.value = false;
    const rules = getFilteredRule(trigger);
    validateState.value = 'validating';

    if ((!rules || rules.length === 0) && props.required === undefined) {
      callback();
      return true;
    }

    const descriptor = {};

    if (rules && rules.length > 0) {
      rules.forEach(rule => {
        delete rule.trigger;
      });
    }

    descriptor[props.prop] = rules;
    const validator = new Schema(descriptor);
    const model = {};
    model[props.prop] = unref(fieldValue);
    validator.validate(model, {
      firstFields: true
    }, (errors, invalidFields) => {
      validateState.value = !errors ? 'success' : 'error';
      validateMessage.value = errors ? errors[0].message : '';
      callback(validateMessage.value, invalidFields);
      elForm && elForm.emit('validate', props.prop, !errors, validateMessage.value || null);
    });
  };

  const clearValidate = () => {
    validateState.value = '';
    validateMessage.value = '';
    validateDisabled.value = false;
  };

  const resetField = () => {
    validateState.value = '';
    validateMessage.value = '';
    const model = elForm.model;
    const value = unref(fieldValue);
    let path = props.prop;

    if (path.indexOf(':') !== -1) {
      path = path.replace(/:/, '.');
    }

    const prop = getPropByPath(model, path, true);
    validateDisabled.value = true;

    if (Array.isArray(value)) {
      prop.o[prop.k] = [].concat(initialValue.value);
    } else {
      prop.o[prop.k] = initialValue.value;
    } // reset validateDisabled after onFieldChange triggered


    nextTick(() => {
      validateDisabled.value = false;
    });
    broadcast('fieldReset', initialValue.value);
  };

  return {
    validateState,
    validateMessage,
    validateDisabled,
    validate,
    clearValidate,
    resetField
  };
}

function render$I(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_label_wrap = resolveComponent("label-wrap");

  return (openBlock(), createBlock("div", {
    class: ["el-form-item", [
      {
        'el-form-item--feedback': $setup.elForm && $setup.elForm.statusIcon,
        'is-error': $setup.validateState === 'error',
        'is-validating': $setup.validateState === 'validating',
        'is-success': $setup.validateState === 'success',
        'is-required': $setup.isRequired || $props.required,
        'is-no-asterisk': $setup.elForm && $setup.elForm.hideRequiredAsterisk
      },
      $setup.sizeClass ? 'el-form-item--' + $setup.sizeClass : ''
    ]]
  }, [
    createVNode(_component_label_wrap, {
      "is-auto-width": $setup.labelStyle && $setup.labelStyle.width === 'auto',
      "update-all": $setup.elForm.labelWidth === 'auto'
    }, {
      default: withCtx(() => [
        ($props.label || _ctx.$slots.label)
          ? (openBlock(), createBlock("label", {
              key: 0,
              for: $setup.labelFor,
              class: "el-form-item__label",
              style: $setup.labelStyle
            }, [
              renderSlot(_ctx.$slots, "label", {}, () => [
                createTextVNode(toDisplayString($props.label + $setup.elForm.labelSuffix), 1 /* TEXT */)
              ])
            ], 12 /* STYLE, PROPS */, ["for"]))
          : createCommentVNode("v-if", true)
      ]),
      _: 1
    }, 8 /* PROPS */, ["is-auto-width", "update-all"]),
    createVNode("div", {
      class: "el-form-item__content",
      style: $setup.contentStyle
    }, [
      renderSlot(_ctx.$slots, "default"),
      createVNode(Transition, { name: "el-zoom-in-top" }, {
        default: withCtx(() => [
          ($setup.validateState === 'error' && $props.showMessage && $setup.elForm.showMessage)
            ? renderSlot(_ctx.$slots, "error", {
                key: 0,
                error: $setup.validateMessage
              }, () => [
                createVNode("div", {
                  class: ["el-form-item__error", {
              'el-form-item__error--inline':
                typeof $props.inlineMessage === 'boolean'
                  ? $props.inlineMessage
                  : ($setup.elForm && $setup.elForm.inlineMessage) || false
            }]
                }, toDisplayString($setup.validateMessage), 3 /* TEXT, CLASS */)
              ])
            : createCommentVNode("v-if", true)
        ]),
        _: 1
      })
    ], 4 /* STYLE */)
  ], 2 /* CLASS */))
}

script$M.render = render$I;
script$M.__file = "packages/form-item/FormItem.vue";

/* istanbul ignore next */

script$M.install = function (app) {
  app.component(script$M.name, script$M);
};

const getCell = function (event) {
  let cell = event.target;

  while (cell && cell.tagName.toUpperCase() !== 'HTML') {
    if (cell.tagName.toUpperCase() === 'TD') {
      return cell;
    }

    cell = cell.parentNode;
  }

  return null;
};

const isObject$1 = function (obj) {
  return obj !== null && typeof obj === 'object';
};

const orderBy = function (array, sortKey, reverse, sortMethod, sortBy) {
  if (!sortKey && !sortMethod && (!sortBy || Array.isArray(sortBy) && !sortBy.length)) {
    return array;
  }

  if (typeof reverse === 'string') {
    reverse = reverse === 'descending' ? -1 : 1;
  } else {
    reverse = reverse && reverse < 0 ? -1 : 1;
  }

  const getKey = sortMethod ? null : function (value, index) {
    if (sortBy) {
      if (!Array.isArray(sortBy)) {
        sortBy = [sortBy];
      }

      return sortBy.map(function (by) {
        if (typeof by === 'string') {
          return getValueByPath(value, by);
        } else {
          return by(value, index, array);
        }
      });
    }

    if (sortKey !== '$key') {
      if (isObject$1(value) && '$value' in value) value = value.$value;
    }

    return [isObject$1(value) ? getValueByPath(value, sortKey) : value];
  };

  const compare = function (a, b) {
    if (sortMethod) {
      return sortMethod(a.value, b.value);
    }

    for (let i = 0, len = a.key.length; i < len; i++) {
      if (a.key[i] < b.key[i]) {
        return -1;
      }

      if (a.key[i] > b.key[i]) {
        return 1;
      }
    }

    return 0;
  };

  return array.map(function (value, index) {
    return {
      value: value,
      index: index,
      key: getKey ? getKey(value, index) : null
    };
  }).sort(function (a, b) {
    let order = compare(a, b);

    if (!order) {
      // make stable https://en.wikipedia.org/wiki/Sorting_algorithm#Stability
      order = a.index - b.index;
    }

    return order * reverse;
  }).map(item => item.value);
};
const getColumnById = function (table, columnId) {
  let column = null;
  table.columns.forEach(function (item) {
    if (item.id === columnId) {
      column = item;
    }
  });
  return column;
};
const getColumnByKey = function (table, columnKey) {
  let column = null;

  for (let i = 0; i < table.columns.length; i++) {
    const item = table.columns[i];

    if (item.columnKey === columnKey) {
      column = item;
      break;
    }
  }

  return column;
};
const getColumnByCell = function (table, cell) {
  const matches = (cell.className || '').match(/el-table_[^\s]+/gm);

  if (matches) {
    return getColumnById(table, matches[0]);
  }

  return null;
};
const getRowIdentity = (row, rowKey) => {
  if (!row) throw new Error('row is required when get row identity');

  if (typeof rowKey === 'string') {
    if (rowKey.indexOf('.') < 0) {
      return row[rowKey];
    }

    const key = rowKey.split('.');
    let current = row;

    for (let i = 0; i < key.length; i++) {
      current = current[key[i]];
    }

    return current;
  } else if (typeof rowKey === 'function') {
    return rowKey.call(null, row);
  }
};
const getKeysMap = function (array, rowKey) {
  const arrayMap = {};
  (array || []).forEach((row, index) => {
    arrayMap[getRowIdentity(row, rowKey)] = {
      row,
      index
    };
  });
  return arrayMap;
};

function hasOwn$1(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}

function mergeOptions(defaults, config) {
  const options = {};
  let key;

  for (key in defaults) {
    options[key] = defaults[key];
  }

  for (key in config) {
    if (hasOwn$1(config, key)) {
      const value = config[key];

      if (typeof value !== 'undefined') {
        options[key] = value;
      }
    }
  }

  return options;
}
function parseWidth(width) {
  if (width !== undefined) {
    width = parseInt(width, 10);

    if (isNaN(width)) {
      width = null;
    }
  }

  return width;
}
function parseMinWidth(minWidth) {
  if (typeof minWidth !== 'undefined') {
    minWidth = parseWidth(minWidth);

    if (isNaN(minWidth)) {
      minWidth = 80;
    }
  }

  return minWidth;
}
function parseHeight(height) {
  if (typeof height === 'number') {
    return height;
  }

  if (typeof height === 'string') {
    if (/^\d+(?:px)?$/.test(height)) {
      return parseInt(height, 10);
    } else {
      return height;
    }
  }

  return null;
} // https://github.com/reduxjs/redux/blob/master/src/compose.js

function compose(...funcs) {
  if (funcs.length === 0) {
    return arg => arg;
  }

  if (funcs.length === 1) {
    return funcs[0];
  }

  return funcs.reduce((a, b) => (...args) => a(b(...args)));
}
function toggleRowStatus(statusArr, row, newVal) {
  let changed = false;
  const index = statusArr.indexOf(row);
  const included = index !== -1;

  const addRow = () => {
    statusArr.push(row);
    changed = true;
  };

  const removeRow = () => {
    statusArr.splice(index, 1);
    changed = true;
  };

  if (typeof newVal === 'boolean') {
    if (newVal && !included) {
      addRow();
    } else if (!newVal && included) {
      removeRow();
    }
  } else {
    if (included) {
      removeRow();
    } else {
      addRow();
    }
  }

  return changed;
}
function walkTreeNode(root, cb, childrenKey = 'children', lazyKey = 'hasChildren') {
  const isNil = array => !(Array.isArray(array) && array.length);

  function _walker(parent, children, level) {
    cb(parent, children, level);
    children.forEach(item => {
      if (item[lazyKey]) {
        cb(item, null, level + 1);
        return;
      }

      const children = item[childrenKey];

      if (!isNil(children)) {
        _walker(item, children, level + 1);
      }
    });
  }

  root.forEach(item => {
    if (item[lazyKey]) {
      cb(item, null, 0);
      return;
    }

    const children = item[childrenKey];

    if (!isNil(children)) {
      _walker(item, children, 0);
    }
  });
}

function useExpand(watcherData) {
  const instance = getCurrentInstance();
  const defaultExpandAll = ref(false);
  const expandRows = ref([]);

  const updateExpandRows = () => {
    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;

    if (defaultExpandAll.value) {
      expandRows.value = data.slice();
    } else if (rowKey) {
      // TODO：这里的代码可以优化
      const expandRowsMap = getKeysMap(expandRows.value, rowKey);
      expandRows.value = data.reduce((prev, row) => {
        const rowId = getRowIdentity(row, rowKey);
        const rowInfo = expandRowsMap[rowId];

        if (rowInfo) {
          prev.push(row);
        }

        return prev;
      }, []);
    } else {
      expandRows.value = [];
    }
  };

  const toggleRowExpansion = (row, expanded) => {
    const changed = toggleRowStatus(expandRows.value, row, expanded);

    if (changed) {
      instance.emit('expand-change', row, expandRows.value.slice());
      instance.store.scheduleLayout();
    }
  };

  const setExpandRowKeys = rowKeys => {
    instance.store.assertRowKey(); // TODO：这里的代码可以优化

    const data = watcherData.data.value || [];
    const rowKey = watcherData.rowKey.value;
    const keysMap = getKeysMap(data, rowKey);
    expandRows.value = rowKeys.reduce((prev, cur) => {
      const info = keysMap[cur];

      if (info) {
        prev.push(info.row);
      }

      return prev;
    }, []);
  };

  const isRowExpanded = row => {
    const rowKey = watcherData.rowKey.value;

    if (rowKey) {
      const expandMap = getKeysMap(expandRows.value, rowKey);
      return !!expandMap[getRowIdentity(row, rowKey)];
    }

    return expandRows.value.indexOf(row) !== -1;
  };

  return {
    updateExpandRows,
    toggleRowExpansion,
    setExpandRowKeys,
    isRowExpanded,
    states: {
      expandRows,
      defaultExpandAll
    }
  };
}

function useCurrent(watcherData) {
  const instance = getCurrentInstance();

  const _currentRowKey = ref(null);

  const currentRow = ref(null);

  const setCurrentRowKey = key => {
    instance.store.assertRowKey();
    _currentRowKey.value = key;
    setCurrentRowByKey(key);
  };

  const restoreCurrentRowKey = () => {
    _currentRowKey.value = null;
  };

  const setCurrentRowByKey = key => {
    const {
      data = [],
      rowKey
    } = watcherData;
    let _currentRow = null;

    if (rowKey.value) {
      _currentRow = arrayFind(unref(data), item => getRowIdentity(item, rowKey.value) === key);
    }

    currentRow.value = _currentRow;
  };

  const updateCurrentRow = _currentRow => {
    const oldCurrentRow = currentRow.value;

    if (_currentRow && _currentRow !== oldCurrentRow) {
      currentRow.value = _currentRow;
      instance.emit('current-change', currentRow.value, oldCurrentRow);
      return;
    }

    if (!_currentRow && oldCurrentRow) {
      currentRow.value = null;
      instance.emit('current-change', null, oldCurrentRow);
    }
  };

  const updateCurrentRowData = () => {
    const rowKey = watcherData.rowKey.value; // data 为 null 时，解构时的默认值会被忽略

    const data = watcherData.data.value || [];
    const oldCurrentRow = currentRow.value; // 当 currentRow 不在 data 中时尝试更新数据

    if (data.indexOf(oldCurrentRow) === -1 && oldCurrentRow) {
      if (rowKey) {
        const currentRowKey = getRowIdentity(oldCurrentRow, rowKey);
        setCurrentRowByKey(currentRowKey);
      } else {
        currentRow.value = null;
      }

      if (currentRow.value === null) {
        instance.emit('current-change', null, oldCurrentRow);
      }
    } else if (_currentRowKey.value) {
      // 把初始时下设置的 rowKey 转化成 rowData
      setCurrentRowByKey(_currentRowKey.value);
      restoreCurrentRowKey();
    }
  };

  return {
    setCurrentRowKey,
    restoreCurrentRowKey,
    setCurrentRowByKey,
    updateCurrentRow,
    updateCurrentRowData,
    states: {
      _currentRowKey,
      currentRow
    }
  };
}

function useTree(watcherData) {
  const expandRowKeys = ref([]);
  const treeData = ref({});
  const indent = ref(16);
  const lazy = ref(false);
  const lazyTreeNodeMap = ref({});
  const lazyColumnIdentifier = ref('hasChildren');
  const childrenColumnName = ref('children');
  const instance = getCurrentInstance();
  const normalizedData = computed(() => {
    if (!watcherData.rowKey.value) return {};
    const data = watcherData.data.value || [];
    return normalize(data);
  });
  const normalizedLazyNode = computed(() => {
    const rowKey = watcherData.rowKey.value;
    const keys = Object.keys(lazyTreeNodeMap.value);
    const res = {};
    if (!keys.length) return res;
    keys.forEach(key => {
      if (lazyTreeNodeMap.value[key].length) {
        const item = {
          children: []
        };
        lazyTreeNodeMap.value[key].forEach(row => {
          const currentRowKey = getRowIdentity(row, rowKey);
          item.children.push(currentRowKey);

          if (row[lazyColumnIdentifier.value] && !res[currentRowKey]) {
            res[currentRowKey] = {
              children: []
            };
          }
        });
        res[key] = item;
      }
    });
    return res;
  });

  const normalize = data => {
    const rowKey = watcherData.rowKey.value;
    const res = {};
    walkTreeNode(data, (parent, children, level) => {
      const parentId = getRowIdentity(parent, rowKey);

      if (Array.isArray(children)) {
        res[parentId] = {
          children: children.map(row => getRowIdentity(row, rowKey)),
          level
        };
      } else if (lazy.value) {
        // 当 children 不存在且 lazy 为 true，该节点即为懒加载的节点
        res[parentId] = {
          children: [],
          lazy: true,
          level
        };
      }
    }, childrenColumnName.value, lazyColumnIdentifier.value);
    return res;
  };

  const updateTreeData = () => {
    var _instance$store2;

    const nested = normalizedData.value;
    const normalizedLazyNode_ = normalizedLazyNode.value;
    const keys = Object.keys(nested);
    const newTreeData = {};

    if (keys.length) {
      var _instance$store;

      const oldTreeData = unref(treeData);
      const defaultExpandAll = (_instance$store = instance.store) === null || _instance$store === void 0 ? void 0 : _instance$store.states.defaultExpandAll.value;
      const rootLazyRowKeys = [];

      const getExpanded = (oldValue, key) => {
        const included = defaultExpandAll || expandRowKeys.value && expandRowKeys.value.indexOf(key) !== -1;
        return !!(oldValue && oldValue.expanded || included);
      }; // 合并 expanded 与 display，确保数据刷新后，状态不变


      keys.forEach(key => {
        const oldValue = oldTreeData[key];
        const newValue = { ...nested[key]
        };
        newValue.expanded = getExpanded(oldValue, key);

        if (newValue.lazy) {
          const {
            loaded = false,
            loading = false
          } = oldValue || {};
          newValue.loaded = !!loaded;
          newValue.loading = !!loading;
          rootLazyRowKeys.push(key);
        }

        newTreeData[key] = newValue;
      }); // 根据懒加载数据更新 treeData

      const lazyKeys = Object.keys(normalizedLazyNode_);

      if (lazy.value && lazyKeys.length && rootLazyRowKeys.length) {
        lazyKeys.forEach(key => {
          const oldValue = oldTreeData[key];
          const lazyNodeChildren = normalizedLazyNode_[key].children;

          if (rootLazyRowKeys.indexOf(key) !== -1) {
            // 懒加载的 root 节点，更新一下原有的数据，原来的 children 一定是空数组
            if (newTreeData[key].children.length !== 0) {
              throw new Error('[ElTable]children must be an empty array.');
            }

            newTreeData[key].children = lazyNodeChildren;
          } else {
            const {
              loaded = false,
              loading = false
            } = oldValue || {};
            newTreeData[key] = {
              lazy: true,
              loaded: !!loaded,
              loading: !!loading,
              expanded: getExpanded(oldValue, key),
              children: lazyNodeChildren,
              level: ''
            };
          }
        });
      }
    }

    treeData.value = newTreeData;
    (_instance$store2 = instance.store) === null || _instance$store2 === void 0 ? void 0 : _instance$store2.updateTableScrollY();
  };

  watch(() => normalizedData.value, updateTreeData);
  watch(() => normalizedLazyNode.value, updateTreeData);

  const updateTreeExpandKeys = value => {
    expandRowKeys.value = value;
    updateTreeData();
  };

  const toggleTreeExpansion = (row, expanded) => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id = getRowIdentity(row, rowKey);
    const data = id && treeData.value[id];

    if (id && data && 'expanded' in data) {
      const oldExpanded = data.expanded;
      expanded = typeof expanded === 'undefined' ? !data.expanded : expanded;
      treeData.value[id].expanded = expanded;

      if (oldExpanded !== expanded) {
        instance.emit('expand-change', row, expanded);
      }

      instance.store.updateTableScrollY();
    }
  };

  const loadOrToggle = row => {
    instance.store.assertRowKey();
    const rowKey = watcherData.rowKey.value;
    const id = getRowIdentity(row, rowKey);
    const data = treeData.value[id];

    if (lazy.value && data && 'loaded' in data && !data.loaded) {
      loadData(row, id, data);
    } else {
      toggleTreeExpansion(row, undefined);
    }
  };

  const loadData = (row, key, treeNode) => {
    const {
      load
    } = instance.props;

    if (load && !treeData.value[key].loaded) {
      treeData.value[key].loading = true;
      load(row, treeNode, data => {
        if (!Array.isArray(data)) {
          throw new Error('[ElTable] data must be an array');
        }

        treeData.value[key].loading = false;
        treeData.value[key].loaded = true;
        treeData.value[key].expanded = true;

        if (data.length) {
          lazyTreeNodeMap.value[key] = data;
        }

        instance.emit('expand-change', row, true);
      });
    }
  };

  return {
    loadData,
    loadOrToggle,
    toggleTreeExpansion,
    updateTreeExpandKeys,
    updateTreeData,
    normalize,
    states: {
      expandRowKeys,
      treeData,
      indent,
      lazy,
      lazyTreeNodeMap,
      lazyColumnIdentifier,
      childrenColumnName
    }
  };
}

const sortData = (data, states) => {
  const sortingColumn = states.sortingColumn;

  if (!sortingColumn || typeof sortingColumn.sortable === 'string') {
    return data;
  }

  return orderBy(data, states.sortProp, states.sortOrder, sortingColumn.sortMethod, sortingColumn.sortBy);
};

const doFlattenColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.children) {
      // eslint-disable-next-line prefer-spread
      result.push.apply(result, doFlattenColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};

function useWatcher() {
  const instance = getCurrentInstance();
  const rowKey = ref(null);
  const data = ref([]);

  const _data = ref([]);

  const isComplex = ref(false);

  const _columns = ref([]);

  const originColumns = ref([]);
  const columns = ref([]);
  const fixedColumns = ref([]);
  const rightFixedColumns = ref([]);
  const leafColumns = ref([]);
  const fixedLeafColumns = ref([]);
  const rightFixedLeafColumns = ref([]);
  const leafColumnsLength = ref(0);
  const fixedLeafColumnsLength = ref(0);
  const rightFixedLeafColumnsLength = ref(0);
  const isAllSelected = ref(false);
  const selection = ref([]);
  const reserveSelection = ref(false);
  const selectOnIndeterminate = ref(false);
  const selectable = ref(null);
  const filters = ref({});
  const filteredData = ref(null);
  const sortingColumn = ref(null);
  const sortProp = ref(null);
  const sortOrder = ref(null);
  const hoverRow = ref(null); // 检查 rowKey 是否存在

  const assertRowKey = () => {
    if (!rowKey.value) throw new Error('[ElTable] prop row-key is required');
  }; // 更新列


  const updateColumns = () => {
    fixedColumns.value = _columns.value.filter(column => column.fixed === true || column.fixed === 'left');
    rightFixedColumns.value = _columns.value.filter(column => column.fixed === 'right');

    if (fixedColumns.value.length > 0 && _columns.value[0] && _columns.value[0].type === 'selection' && !_columns.value[0].fixed) {
      _columns.value[0].fixed = true;
      fixedColumns.value.unshift(_columns.value[0]);
    }

    const notFixedColumns = _columns.value.filter(column => !column.fixed);

    originColumns.value = [].concat(fixedColumns.value).concat(notFixedColumns).concat(rightFixedColumns.value);
    const leafColumns = doFlattenColumns(notFixedColumns);
    const fixedLeafColumns = doFlattenColumns(fixedColumns.value);
    const rightFixedLeafColumns = doFlattenColumns(rightFixedColumns.value);
    leafColumnsLength.value = leafColumns.length;
    fixedLeafColumnsLength.value = fixedLeafColumns.length;
    rightFixedLeafColumnsLength.value = rightFixedLeafColumns.length;
    columns.value = [].concat(fixedLeafColumns).concat(leafColumns).concat(rightFixedLeafColumns);
    isComplex.value = fixedColumns.value.length > 0 || rightFixedColumns.value.length > 0;
  }; // 更新 DOM


  const scheduleLayout = (needUpdateColumns, immediate = false) => {
    if (needUpdateColumns) {
      updateColumns();
    }

    if (immediate) {
      instance.state.doLayout();
    } else {
      instance.state.debouncedUpdateLayout();
    }
  }; // 选择


  const isSelected = row => {
    return selection.value.indexOf(row) > -1;
  };

  const clearSelection = () => {
    isAllSelected.value = false;
    const oldSelection = selection.value;

    if (oldSelection.length) {
      selection.value = [];
      instance.emit('selection-change', []);
    }
  };

  const cleanSelection = () => {
    let deleted;

    if (rowKey.value) {
      deleted = [];
      const selectedMap = getKeysMap(selection.value, rowKey.value);
      const dataMap = getKeysMap(data.value, rowKey.value);

      for (const key in selectedMap) {
        // eslint-disable-next-line no-prototype-builtins
        if (selectedMap.hasOwnProperty(key) && !dataMap[key]) {
          deleted.push(selectedMap[key].row);
        }
      }
    } else {
      deleted = selection.value.filter(item => data.value.indexOf(item) === -1);
    }

    if (deleted.length) {
      const newSelection = selection.value.filter(item => deleted.indexOf(item) === -1);
      selection.value = newSelection;
      instance.emit('selection-change', newSelection.slice());
    }
  };

  const toggleRowSelection = (row, selected, emitChange = true) => {
    const changed = toggleRowStatus(selection.value, row, selected);

    if (changed) {
      const newSelection = (selection.value || []).slice(); // 调用 API 修改选中值，不触发 select 事件

      if (emitChange) {
        instance.emit('select', newSelection, row);
      }

      instance.emit('selection-change', newSelection);
    }
  };

  const _toggleAllSelection = () => {
    // when only some rows are selected (but not all), select or deselect all of them
    // depending on the value of selectOnIndeterminate
    const value = selectOnIndeterminate.value ? !isAllSelected.value : !(isAllSelected.value || selection.value.length);
    isAllSelected.value = value;
    let selectionChanged = false;
    data.value.forEach((row, index) => {
      if (selectable.value) {
        if (selectable.value.call(null, row, index) && toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      } else {
        if (toggleRowStatus(selection.value, row, value)) {
          selectionChanged = true;
        }
      }
    });

    if (selectionChanged) {
      instance.emit('selection-change', selection.value ? selection.value.slice() : []);
    }

    instance.emit('select-all', selection.value);
  };

  const updateSelectionByRowKey = () => {
    const selectedMap = getKeysMap(selection.value, rowKey.value);
    data.value.forEach(row => {
      const rowId = getRowIdentity(row, rowKey.value);
      const rowInfo = selectedMap[rowId];

      if (rowInfo) {
        selection.value[rowInfo.index] = row;
      }
    });
  };

  const updateAllSelected = () => {
    var _data$value;

    // data 为 null 时，解构时的默认值会被忽略
    if (((_data$value = data.value) === null || _data$value === void 0 ? void 0 : _data$value.length) === 0) {
      isAllSelected.value = false;
      return;
    }

    let selectedMap;

    if (rowKey.value) {
      selectedMap = getKeysMap(selection.value, rowKey.value);
    }

    const isSelected = function (row) {
      if (selectedMap) {
        return !!selectedMap[getRowIdentity(row, rowKey.value)];
      } else {
        return selection.value.indexOf(row) !== -1;
      }
    };

    let isAllSelected_ = true;
    let selectedCount = 0;

    for (let i = 0, j = (data.value || []).length; i < j; i++) {
      const item = data.value[i];
      const isRowSelectable = selectable.value && selectable.value.call(null, item, i);

      if (!isSelected(item)) {
        if (!selectable.value || isRowSelectable) {
          isAllSelected_ = false;
          break;
        }
      } else {
        selectedCount++;
      }
    }

    if (selectedCount === 0) isAllSelected_ = false;
    isAllSelected.value = isAllSelected_;
  }; // 过滤与排序


  const updateFilters = (columns, values) => {
    if (!Array.isArray(columns)) {
      columns = [columns];
    }

    const filters_ = {};
    columns.forEach(col => {
      filters.value[col.id] = values;
      filters_[col.columnKey || col.id] = values;
    });
    return filters_;
  };

  const updateSort = (column, prop, order) => {
    if (sortingColumn.value && sortingColumn.value !== column) {
      sortingColumn.value.order = null;
    }

    sortingColumn.value = column;
    sortProp.value = prop;
    sortOrder.value = order;
  };

  const execFilter = () => {
    let sourceData = unref(_data);
    Object.keys(filters.value).forEach(columnId => {
      const values = filters.value[columnId];
      if (!values || values.length === 0) return;
      const column = getColumnById({
        columns: columns.value
      }, columnId);

      if (column && column.filterMethod) {
        sourceData = sourceData.filter(row => {
          return values.some(value => column.filterMethod.call(null, value, row, column));
        });
      }
    });
    filteredData.value = sourceData;
  };

  const execSort = () => {
    data.value = sortData(filteredData.value, {
      sortingColumn: sortingColumn.value,
      sortProp: sortProp.value,
      sortOrder: sortOrder.value
    });
  }; // 根据 filters 与 sort 去过滤 data


  const execQuery = ignore => {
    if (!(ignore && ignore.filter)) {
      execFilter();
    }

    execSort();
  };

  const clearFilter = columnKeys => {
    const {
      tableHeader,
      fixedTableHeader,
      rightFixedTableHeader
    } = instance.refs;
    let panels = {};
    if (tableHeader) panels = merge(panels, tableHeader.filterPanels);
    if (fixedTableHeader) panels = merge(panels, fixedTableHeader.filterPanels);
    if (rightFixedTableHeader) panels = merge(panels, rightFixedTableHeader.filterPanels);
    const keys = Object.keys(panels);
    if (!keys.length) return;

    if (typeof columnKeys === 'string') {
      columnKeys = [columnKeys];
    }

    if (Array.isArray(columnKeys)) {
      const columns_ = columnKeys.map(key => getColumnByKey({
        columns: columns.value
      }, key));
      keys.forEach(key => {
        const column = columns_.find(col => col.id === key);

        if (column) {
          column.filteredValue = [];
        }
      });
      instance.store.commit('filterChange', {
        column: columns_,
        values: [],
        silent: true,
        multi: true
      });
    } else {
      keys.forEach(key => {
        const column = columns.value.find(col => col.id === key);

        if (column) {
          column.filteredValue = [];
        }
      });
      filters.value = {};
      instance.store.commit('filterChange', {
        column: {},
        values: [],
        silent: true
      });
    }
  };

  const clearSort = () => {
    if (!sortingColumn.value) return;
    updateSort(null, null, null);
    instance.store.commit('changeSortCondition', {
      silent: true
    });
  };

  const {
    setExpandRowKeys,
    toggleRowExpansion,
    updateExpandRows,
    states: expandStates,
    isRowExpanded
  } = useExpand({
    data,
    rowKey
  });
  const {
    updateTreeExpandKeys,
    toggleTreeExpansion,
    loadOrToggle,
    states: treeStates
  } = useTree({
    data,
    rowKey
  });
  const {
    updateCurrentRowData,
    updateCurrentRow,
    setCurrentRowKey,
    states: currentData
  } = useCurrent({
    data,
    rowKey
  }); // 适配层，expand-row-keys 在 Expand 与 TreeTable 中都有使用

  const setExpandRowKeysAdapter = val => {
    // 这里会触发额外的计算，但为了兼容性，暂时这么做
    setExpandRowKeys(val);
    updateTreeExpandKeys(val);
  }; // 展开行与 TreeTable 都要使用


  const toggleRowExpansionAdapter = (row, expanded) => {
    const hasExpandColumn = columns.value.some(({
      type
    }) => type === 'expand');

    if (hasExpandColumn) {
      toggleRowExpansion(row, expanded);
    } else {
      toggleTreeExpansion(row, expanded);
    }
  };

  return {
    assertRowKey,
    updateColumns,
    scheduleLayout,
    isSelected,
    clearSelection,
    cleanSelection,
    toggleRowSelection,
    _toggleAllSelection,
    updateSelectionByRowKey,
    updateAllSelected,
    updateFilters,
    updateCurrentRow,
    updateSort,
    execFilter,
    execSort,
    execQuery,
    clearFilter,
    clearSort,
    toggleRowExpansion,
    setExpandRowKeysAdapter,
    setCurrentRowKey,
    toggleRowExpansionAdapter,
    isRowExpanded,
    updateExpandRows,
    updateCurrentRowData,
    loadOrToggle,
    states: {
      rowKey,
      data,
      _data,
      isComplex,
      _columns,
      originColumns,
      columns,
      fixedColumns,
      rightFixedColumns,
      leafColumns,
      fixedLeafColumns,
      rightFixedLeafColumns,
      leafColumnsLength,
      fixedLeafColumnsLength,
      rightFixedLeafColumnsLength,
      isAllSelected,
      selection,
      reserveSelection,
      selectOnIndeterminate,
      selectable,
      filters,
      filteredData,
      sortingColumn,
      sortProp,
      sortOrder,
      hoverRow,
      ...expandStates,
      ...treeStates,
      ...currentData
    }
  };
}

function replaceColumn(array, column) {
  return array.map(item => {
    var _item$children;

    if (item.id === column.id) {
      return column;
    } else if (((_item$children = item.children) === null || _item$children === void 0 ? void 0 : _item$children.length) > 0) {
      item.children = replaceColumn(item.children, column);
    }

    return item;
  });
}

function useStore() {
  const instance = getCurrentInstance();
  const mutations = {
    setData(states, data) {
      const dataInstanceChanged = unref(states.data) !== data;
      states.data.value = data;
      states._data.value = data;
      instance.store.execQuery(); // 数据变化，更新部分数据。
      // 没有使用 computed，而是手动更新部分数据 https://github.com/vuejs/vue/issues/6660#issuecomment-331417140

      instance.store.updateCurrentRowData();
      instance.store.updateExpandRows();

      if (unref(states.reserveSelection)) {
        instance.store.assertRowKey();
        instance.store.updateSelectionByRowKey();
      } else {
        if (dataInstanceChanged) {
          instance.store.clearSelection();
        } else {
          instance.store.cleanSelection();
        }
      }

      instance.store.updateAllSelected();
      instance.store.updateTableScrollY();
    },

    insertColumn(states, column, index, parent) {
      if (index < -1) return;
      const array = unref(states._columns);

      if (!parent) {
        array.splice(index, 0, column);
        states._columns.value = array;
      } else {
        if (parent && !parent.children) {
          parent.children = [];
        }

        parent.children.push(column);
        const newColumns = replaceColumn(array, parent);
        states._columns.value = newColumns;
      }

      if (column.type === 'selection') {
        states.selectable.value = column.selectable;
        states.reserveSelection.value = column.reserveSelection;
      }

      if (instance.$ready) {
        instance.store.updateColumns(); // hack for dynamics insert column

        instance.store.scheduleLayout();
      }
    },

    removeColumn(states, column, parent) {
      const array = unref(states._columns) || [];

      if (parent) {
        parent.children.splice(parent.children.findIndex(item => item.id === column.id), 1);
        states._columns.value = replaceColumn(array, parent);
      } else {
        array.splice(array.indexOf(column), 1);
        states._columns.value = array;
      }

      if (instance.$ready) {
        instance.store.updateColumns(); // hack for dynamics remove column

        instance.store.scheduleLayout();
      }
    },

    sort(states, options) {
      const {
        prop,
        order,
        init
      } = options;

      if (prop) {
        const column = arrayFind(unref(states.columns), column => column.property === prop);

        if (column) {
          column.order = order;
          instance.store.updateSort(column, prop, order);
          instance.store.commit('changeSortCondition', {
            init
          });
        }
      }
    },

    changeSortCondition(states, options) {
      // 修复 pr https://github.com/ElemeFE/element/pull/15012 导致的 bug
      const {
        sortingColumn: column,
        sortProp: prop,
        sortOrder: order
      } = states;

      if (unref(order) === null) {
        states.sortingColumn.value = null;
        states.sortProp.value = null;
      }

      const ingore = {
        filter: true
      };
      instance.store.execQuery(ingore);

      if (!options || !(options.silent || options.init)) {
        instance.emit('sort-change', {
          column: unref(column),
          prop: unref(prop),
          order: unref(order)
        });
      }

      instance.store.updateTableScrollY();
    },

    filterChange(states, options) {
      const {
        column,
        values,
        silent
      } = options;
      const newFilters = instance.store.updateFilters(column, values);
      instance.store.execQuery();

      if (!silent) {
        instance.emit('filter-change', newFilters);
      }

      instance.store.updateTableScrollY();
    },

    toggleAllSelection() {
      instance.store.toggleAllSelection();
    },

    rowSelectedChanged(states, row) {
      instance.store.toggleRowSelection(row);
      instance.store.updateAllSelected();
    },

    setHoverRow(states, row) {
      states.hoverRow.value = row;
    },

    setCurrentRow(states, row) {
      instance.store.updateCurrentRow(row);
    }

  };

  const commit = function (name, ...args) {
    const mutations = instance.store.mutations;

    if (mutations[name]) {
      mutations[name].apply(instance, [instance.store.states].concat(args));
    } else {
      throw new Error(`Action not found: ${name}`);
    }
  };

  const updateTableScrollY = function () {
    nextTick(instance.layout.updateScrollY.apply(instance.layout));
  };

  const watcher = useWatcher();
  return { ...watcher,
    mutations,
    commit,
    updateTableScrollY
  };
}

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function createCommonjsModule(fn, basedir, module) {
	return module = {
	  path: basedir,
	  exports: {},
	  require: function (path, base) {
      return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
    }
	}, fn(module, module.exports), module.exports;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var lodash = createCommonjsModule(function (module, exports) {
(function(){/** Used as a safe reference for `undefined` in pre-ES5 environments. */var undefined$1;/** Used as the semantic version number. */var VERSION='4.17.19';/** Used as the size to enable large array optimizations. */var LARGE_ARRAY_SIZE=200;/** Error message constants. */var CORE_ERROR_TEXT='Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',FUNC_ERROR_TEXT='Expected a function';/** Used to stand-in for `undefined` hash values. */var HASH_UNDEFINED='__lodash_hash_undefined__';/** Used as the maximum memoize cache size. */var MAX_MEMOIZE_SIZE=500;/** Used as the internal argument placeholder. */var PLACEHOLDER='__lodash_placeholder__';/** Used to compose bitmasks for cloning. */var CLONE_DEEP_FLAG=1,CLONE_FLAT_FLAG=2,CLONE_SYMBOLS_FLAG=4;/** Used to compose bitmasks for value comparisons. */var COMPARE_PARTIAL_FLAG=1,COMPARE_UNORDERED_FLAG=2;/** Used to compose bitmasks for function metadata. */var WRAP_BIND_FLAG=1,WRAP_BIND_KEY_FLAG=2,WRAP_CURRY_BOUND_FLAG=4,WRAP_CURRY_FLAG=8,WRAP_CURRY_RIGHT_FLAG=16,WRAP_PARTIAL_FLAG=32,WRAP_PARTIAL_RIGHT_FLAG=64,WRAP_ARY_FLAG=128,WRAP_REARG_FLAG=256,WRAP_FLIP_FLAG=512;/** Used as default options for `_.truncate`. */var DEFAULT_TRUNC_LENGTH=30,DEFAULT_TRUNC_OMISSION='...';/** Used to detect hot functions by number of calls within a span of milliseconds. */var HOT_COUNT=800,HOT_SPAN=16;/** Used to indicate the type of lazy iteratees. */var LAZY_FILTER_FLAG=1,LAZY_MAP_FLAG=2,LAZY_WHILE_FLAG=3;/** Used as references for various `Number` constants. */var INFINITY=1/0,MAX_SAFE_INTEGER=9007199254740991,MAX_INTEGER=1.7976931348623157e+308,NAN=0/0;/** Used as references for the maximum length and index of an array. */var MAX_ARRAY_LENGTH=4294967295,MAX_ARRAY_INDEX=MAX_ARRAY_LENGTH-1,HALF_MAX_ARRAY_LENGTH=MAX_ARRAY_LENGTH>>>1;/** Used to associate wrap methods with their bit flags. */var wrapFlags=[['ary',WRAP_ARY_FLAG],['bind',WRAP_BIND_FLAG],['bindKey',WRAP_BIND_KEY_FLAG],['curry',WRAP_CURRY_FLAG],['curryRight',WRAP_CURRY_RIGHT_FLAG],['flip',WRAP_FLIP_FLAG],['partial',WRAP_PARTIAL_FLAG],['partialRight',WRAP_PARTIAL_RIGHT_FLAG],['rearg',WRAP_REARG_FLAG]];/** `Object#toString` result references. */var argsTag='[object Arguments]',arrayTag='[object Array]',asyncTag='[object AsyncFunction]',boolTag='[object Boolean]',dateTag='[object Date]',domExcTag='[object DOMException]',errorTag='[object Error]',funcTag='[object Function]',genTag='[object GeneratorFunction]',mapTag='[object Map]',numberTag='[object Number]',nullTag='[object Null]',objectTag='[object Object]',promiseTag='[object Promise]',proxyTag='[object Proxy]',regexpTag='[object RegExp]',setTag='[object Set]',stringTag='[object String]',symbolTag='[object Symbol]',undefinedTag='[object Undefined]',weakMapTag='[object WeakMap]',weakSetTag='[object WeakSet]';var arrayBufferTag='[object ArrayBuffer]',dataViewTag='[object DataView]',float32Tag='[object Float32Array]',float64Tag='[object Float64Array]',int8Tag='[object Int8Array]',int16Tag='[object Int16Array]',int32Tag='[object Int32Array]',uint8Tag='[object Uint8Array]',uint8ClampedTag='[object Uint8ClampedArray]',uint16Tag='[object Uint16Array]',uint32Tag='[object Uint32Array]';/** Used to match empty string literals in compiled template source. */var reEmptyStringLeading=/\b__p \+= '';/g,reEmptyStringMiddle=/\b(__p \+=) '' \+/g,reEmptyStringTrailing=/(__e\(.*?\)|\b__t\)) \+\n'';/g;/** Used to match HTML entities and HTML characters. */var reEscapedHtml=/&(?:amp|lt|gt|quot|#39);/g,reUnescapedHtml=/[&<>"']/g,reHasEscapedHtml=RegExp(reEscapedHtml.source),reHasUnescapedHtml=RegExp(reUnescapedHtml.source);/** Used to match template delimiters. */var reEscape=/<%-([\s\S]+?)%>/g,reEvaluate=/<%([\s\S]+?)%>/g,reInterpolate=/<%=([\s\S]+?)%>/g;/** Used to match property names within property paths. */var reIsDeepProp=/\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,reIsPlainProp=/^\w*$/,rePropName=/[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;/**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */var reRegExpChar=/[\\^$.*+?()[\]{}|]/g,reHasRegExpChar=RegExp(reRegExpChar.source);/** Used to match leading and trailing whitespace. */var reTrim=/^\s+|\s+$/g,reTrimStart=/^\s+/,reTrimEnd=/\s+$/;/** Used to match wrap detail comments. */var reWrapComment=/\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,reWrapDetails=/\{\n\/\* \[wrapped with (.+)\] \*/,reSplitDetails=/,? & /;/** Used to match words composed of alphanumeric characters. */var reAsciiWord=/[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;/** Used to match backslashes in property paths. */var reEscapeChar=/\\(\\)?/g;/**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */var reEsTemplate=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;/** Used to match `RegExp` flags from their coerced string values. */var reFlags=/\w*$/;/** Used to detect bad signed hexadecimal string values. */var reIsBadHex=/^[-+]0x[0-9a-f]+$/i;/** Used to detect binary string values. */var reIsBinary=/^0b[01]+$/i;/** Used to detect host constructors (Safari). */var reIsHostCtor=/^\[object .+?Constructor\]$/;/** Used to detect octal string values. */var reIsOctal=/^0o[0-7]+$/i;/** Used to detect unsigned integer values. */var reIsUint=/^(?:0|[1-9]\d*)$/;/** Used to match Latin Unicode letters (excluding mathematical operators). */var reLatin=/[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;/** Used to ensure capturing order of template delimiters. */var reNoMatch=/($^)/;/** Used to match unescaped characters in compiled string literals. */var reUnescapedString=/['\n\r\u2028\u2029\\]/g;/** Used to compose unicode character classes. */var rsAstralRange='\\ud800-\\udfff',rsComboMarksRange='\\u0300-\\u036f',reComboHalfMarksRange='\\ufe20-\\ufe2f',rsComboSymbolsRange='\\u20d0-\\u20ff',rsComboRange=rsComboMarksRange+reComboHalfMarksRange+rsComboSymbolsRange,rsDingbatRange='\\u2700-\\u27bf',rsLowerRange='a-z\\xdf-\\xf6\\xf8-\\xff',rsMathOpRange='\\xac\\xb1\\xd7\\xf7',rsNonCharRange='\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',rsPunctuationRange='\\u2000-\\u206f',rsSpaceRange=' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',rsUpperRange='A-Z\\xc0-\\xd6\\xd8-\\xde',rsVarRange='\\ufe0e\\ufe0f',rsBreakRange=rsMathOpRange+rsNonCharRange+rsPunctuationRange+rsSpaceRange;/** Used to compose unicode capture groups. */var rsApos="['\u2019]",rsAstral='['+rsAstralRange+']',rsBreak='['+rsBreakRange+']',rsCombo='['+rsComboRange+']',rsDigits='\\d+',rsDingbat='['+rsDingbatRange+']',rsLower='['+rsLowerRange+']',rsMisc='[^'+rsAstralRange+rsBreakRange+rsDigits+rsDingbatRange+rsLowerRange+rsUpperRange+']',rsFitz='\\ud83c[\\udffb-\\udfff]',rsModifier='(?:'+rsCombo+'|'+rsFitz+')',rsNonAstral='[^'+rsAstralRange+']',rsRegional='(?:\\ud83c[\\udde6-\\uddff]){2}',rsSurrPair='[\\ud800-\\udbff][\\udc00-\\udfff]',rsUpper='['+rsUpperRange+']',rsZWJ='\\u200d';/** Used to compose unicode regexes. */var rsMiscLower='(?:'+rsLower+'|'+rsMisc+')',rsMiscUpper='(?:'+rsUpper+'|'+rsMisc+')',rsOptContrLower='(?:'+rsApos+'(?:d|ll|m|re|s|t|ve))?',rsOptContrUpper='(?:'+rsApos+'(?:D|LL|M|RE|S|T|VE))?',reOptMod=rsModifier+'?',rsOptVar='['+rsVarRange+']?',rsOptJoin='(?:'+rsZWJ+'(?:'+[rsNonAstral,rsRegional,rsSurrPair].join('|')+')'+rsOptVar+reOptMod+')*',rsOrdLower='\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',rsOrdUpper='\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',rsSeq=rsOptVar+reOptMod+rsOptJoin,rsEmoji='(?:'+[rsDingbat,rsRegional,rsSurrPair].join('|')+')'+rsSeq,rsSymbol='(?:'+[rsNonAstral+rsCombo+'?',rsCombo,rsRegional,rsSurrPair,rsAstral].join('|')+')';/** Used to match apostrophes. */var reApos=RegExp(rsApos,'g');/**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */var reComboMark=RegExp(rsCombo,'g');/** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */var reUnicode=RegExp(rsFitz+'(?='+rsFitz+')|'+rsSymbol+rsSeq,'g');/** Used to match complex or compound words. */var reUnicodeWord=RegExp([rsUpper+'?'+rsLower+'+'+rsOptContrLower+'(?='+[rsBreak,rsUpper,'$'].join('|')+')',rsMiscUpper+'+'+rsOptContrUpper+'(?='+[rsBreak,rsUpper+rsMiscLower,'$'].join('|')+')',rsUpper+'?'+rsMiscLower+'+'+rsOptContrLower,rsUpper+'+'+rsOptContrUpper,rsOrdUpper,rsOrdLower,rsDigits,rsEmoji].join('|'),'g');/** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */var reHasUnicode=RegExp('['+rsZWJ+rsAstralRange+rsComboRange+rsVarRange+']');/** Used to detect strings that need a more robust regexp to match words. */var reHasUnicodeWord=/[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;/** Used to assign default `context` object properties. */var contextProps=['Array','Buffer','DataView','Date','Error','Float32Array','Float64Array','Function','Int8Array','Int16Array','Int32Array','Map','Math','Object','Promise','RegExp','Set','String','Symbol','TypeError','Uint8Array','Uint8ClampedArray','Uint16Array','Uint32Array','WeakMap','_','clearTimeout','isFinite','parseInt','setTimeout'];/** Used to make template sourceURLs easier to identify. */var templateCounter=-1;/** Used to identify `toStringTag` values of typed arrays. */var typedArrayTags={};typedArrayTags[float32Tag]=typedArrayTags[float64Tag]=typedArrayTags[int8Tag]=typedArrayTags[int16Tag]=typedArrayTags[int32Tag]=typedArrayTags[uint8Tag]=typedArrayTags[uint8ClampedTag]=typedArrayTags[uint16Tag]=typedArrayTags[uint32Tag]=true;typedArrayTags[argsTag]=typedArrayTags[arrayTag]=typedArrayTags[arrayBufferTag]=typedArrayTags[boolTag]=typedArrayTags[dataViewTag]=typedArrayTags[dateTag]=typedArrayTags[errorTag]=typedArrayTags[funcTag]=typedArrayTags[mapTag]=typedArrayTags[numberTag]=typedArrayTags[objectTag]=typedArrayTags[regexpTag]=typedArrayTags[setTag]=typedArrayTags[stringTag]=typedArrayTags[weakMapTag]=false;/** Used to identify `toStringTag` values supported by `_.clone`. */var cloneableTags={};cloneableTags[argsTag]=cloneableTags[arrayTag]=cloneableTags[arrayBufferTag]=cloneableTags[dataViewTag]=cloneableTags[boolTag]=cloneableTags[dateTag]=cloneableTags[float32Tag]=cloneableTags[float64Tag]=cloneableTags[int8Tag]=cloneableTags[int16Tag]=cloneableTags[int32Tag]=cloneableTags[mapTag]=cloneableTags[numberTag]=cloneableTags[objectTag]=cloneableTags[regexpTag]=cloneableTags[setTag]=cloneableTags[stringTag]=cloneableTags[symbolTag]=cloneableTags[uint8Tag]=cloneableTags[uint8ClampedTag]=cloneableTags[uint16Tag]=cloneableTags[uint32Tag]=true;cloneableTags[errorTag]=cloneableTags[funcTag]=cloneableTags[weakMapTag]=false;/** Used to map Latin Unicode letters to basic Latin letters. */var deburredLetters={// Latin-1 Supplement block.
'\xc0':'A','\xc1':'A','\xc2':'A','\xc3':'A','\xc4':'A','\xc5':'A','\xe0':'a','\xe1':'a','\xe2':'a','\xe3':'a','\xe4':'a','\xe5':'a','\xc7':'C','\xe7':'c','\xd0':'D','\xf0':'d','\xc8':'E','\xc9':'E','\xca':'E','\xcb':'E','\xe8':'e','\xe9':'e','\xea':'e','\xeb':'e','\xcc':'I','\xcd':'I','\xce':'I','\xcf':'I','\xec':'i','\xed':'i','\xee':'i','\xef':'i','\xd1':'N','\xf1':'n','\xd2':'O','\xd3':'O','\xd4':'O','\xd5':'O','\xd6':'O','\xd8':'O','\xf2':'o','\xf3':'o','\xf4':'o','\xf5':'o','\xf6':'o','\xf8':'o','\xd9':'U','\xda':'U','\xdb':'U','\xdc':'U','\xf9':'u','\xfa':'u','\xfb':'u','\xfc':'u','\xdd':'Y','\xfd':'y','\xff':'y','\xc6':'Ae','\xe6':'ae','\xde':'Th','\xfe':'th','\xdf':'ss',// Latin Extended-A block.
'\u0100':'A','\u0102':'A','\u0104':'A','\u0101':'a','\u0103':'a','\u0105':'a','\u0106':'C','\u0108':'C','\u010a':'C','\u010c':'C','\u0107':'c','\u0109':'c','\u010b':'c','\u010d':'c','\u010e':'D','\u0110':'D','\u010f':'d','\u0111':'d','\u0112':'E','\u0114':'E','\u0116':'E','\u0118':'E','\u011a':'E','\u0113':'e','\u0115':'e','\u0117':'e','\u0119':'e','\u011b':'e','\u011c':'G','\u011e':'G','\u0120':'G','\u0122':'G','\u011d':'g','\u011f':'g','\u0121':'g','\u0123':'g','\u0124':'H','\u0126':'H','\u0125':'h','\u0127':'h','\u0128':'I','\u012a':'I','\u012c':'I','\u012e':'I','\u0130':'I','\u0129':'i','\u012b':'i','\u012d':'i','\u012f':'i','\u0131':'i','\u0134':'J','\u0135':'j','\u0136':'K','\u0137':'k','\u0138':'k','\u0139':'L','\u013b':'L','\u013d':'L','\u013f':'L','\u0141':'L','\u013a':'l','\u013c':'l','\u013e':'l','\u0140':'l','\u0142':'l','\u0143':'N','\u0145':'N','\u0147':'N','\u014a':'N','\u0144':'n','\u0146':'n','\u0148':'n','\u014b':'n','\u014c':'O','\u014e':'O','\u0150':'O','\u014d':'o','\u014f':'o','\u0151':'o','\u0154':'R','\u0156':'R','\u0158':'R','\u0155':'r','\u0157':'r','\u0159':'r','\u015a':'S','\u015c':'S','\u015e':'S','\u0160':'S','\u015b':'s','\u015d':'s','\u015f':'s','\u0161':'s','\u0162':'T','\u0164':'T','\u0166':'T','\u0163':'t','\u0165':'t','\u0167':'t','\u0168':'U','\u016a':'U','\u016c':'U','\u016e':'U','\u0170':'U','\u0172':'U','\u0169':'u','\u016b':'u','\u016d':'u','\u016f':'u','\u0171':'u','\u0173':'u','\u0174':'W','\u0175':'w','\u0176':'Y','\u0177':'y','\u0178':'Y','\u0179':'Z','\u017b':'Z','\u017d':'Z','\u017a':'z','\u017c':'z','\u017e':'z','\u0132':'IJ','\u0133':'ij','\u0152':'Oe','\u0153':'oe','\u0149':"'n",'\u017f':'s'};/** Used to map characters to HTML entities. */var htmlEscapes={'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'};/** Used to map HTML entities to characters. */var htmlUnescapes={'&amp;':'&','&lt;':'<','&gt;':'>','&quot;':'"','&#39;':"'"};/** Used to escape characters for inclusion in compiled string literals. */var stringEscapes={'\\':'\\',"'":"'",'\n':'n','\r':'r','\u2028':'u2028','\u2029':'u2029'};/** Built-in method references without a dependency on `root`. */var freeParseFloat=parseFloat,freeParseInt=parseInt;/** Detect free variable `global` from Node.js. */var freeGlobal=typeof commonjsGlobal=='object'&&commonjsGlobal&&commonjsGlobal.Object===Object&&commonjsGlobal;/** Detect free variable `self`. */var freeSelf=typeof self=='object'&&self&&self.Object===Object&&self;/** Used as a reference to the global object. */var root=freeGlobal||freeSelf||Function('return this')();/** Detect free variable `exports`. */var freeExports=exports&&!exports.nodeType&&exports;/** Detect free variable `module`. */var freeModule=freeExports&&'object'=='object'&&module&&!module.nodeType&&module;/** Detect the popular CommonJS extension `module.exports`. */var moduleExports=freeModule&&freeModule.exports===freeExports;/** Detect free variable `process` from Node.js. */var freeProcess=moduleExports&&freeGlobal.process;/** Used to access faster Node.js helpers. */var nodeUtil=function(){try{// Use `util.types` for Node.js 10+.
var types=freeModule&&freeModule.require&&freeModule.require('util').types;if(types){return types;}// Legacy `process.binding('util')` for Node.js < 10.
return freeProcess&&freeProcess.binding&&freeProcess.binding('util');}catch(e){}}();/* Node.js helper references. */var nodeIsArrayBuffer=nodeUtil&&nodeUtil.isArrayBuffer,nodeIsDate=nodeUtil&&nodeUtil.isDate,nodeIsMap=nodeUtil&&nodeUtil.isMap,nodeIsRegExp=nodeUtil&&nodeUtil.isRegExp,nodeIsSet=nodeUtil&&nodeUtil.isSet,nodeIsTypedArray=nodeUtil&&nodeUtil.isTypedArray;/*--------------------------------------------------------------------------*/ /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */function apply(func,thisArg,args){switch(args.length){case 0:return func.call(thisArg);case 1:return func.call(thisArg,args[0]);case 2:return func.call(thisArg,args[0],args[1]);case 3:return func.call(thisArg,args[0],args[1],args[2]);}return func.apply(thisArg,args);}/**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */function arrayAggregator(array,setter,iteratee,accumulator){var index=-1,length=array==null?0:array.length;while(++index<length){var value=array[index];setter(accumulator,value,iteratee(value),array);}return accumulator;}/**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEach(array,iteratee){var index=-1,length=array==null?0:array.length;while(++index<length){if(iteratee(array[index],index,array)===false){break;}}return array;}/**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */function arrayEachRight(array,iteratee){var length=array==null?0:array.length;while(length--){if(iteratee(array[length],length,array)===false){break;}}return array;}/**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */function arrayEvery(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(!predicate(array[index],index,array)){return false;}}return true;}/**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */function arrayFilter(array,predicate){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(predicate(value,index,array)){result[resIndex++]=value;}}return result;}/**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludes(array,value){var length=array==null?0:array.length;return !!length&&baseIndexOf(array,value,0)>-1;}/**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */function arrayIncludesWith(array,value,comparator){var index=-1,length=array==null?0:array.length;while(++index<length){if(comparator(value,array[index])){return true;}}return false;}/**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */function arrayMap(array,iteratee){var index=-1,length=array==null?0:array.length,result=Array(length);while(++index<length){result[index]=iteratee(array[index],index,array);}return result;}/**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */function arrayPush(array,values){var index=-1,length=values.length,offset=array.length;while(++index<length){array[offset+index]=values[index];}return array;}/**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduce(array,iteratee,accumulator,initAccum){var index=-1,length=array==null?0:array.length;if(initAccum&&length){accumulator=array[++index];}while(++index<length){accumulator=iteratee(accumulator,array[index],index,array);}return accumulator;}/**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */function arrayReduceRight(array,iteratee,accumulator,initAccum){var length=array==null?0:array.length;if(initAccum&&length){accumulator=array[--length];}while(length--){accumulator=iteratee(accumulator,array[length],length,array);}return accumulator;}/**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */function arraySome(array,predicate){var index=-1,length=array==null?0:array.length;while(++index<length){if(predicate(array[index],index,array)){return true;}}return false;}/**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */var asciiSize=baseProperty('length');/**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function asciiToArray(string){return string.split('');}/**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function asciiWords(string){return string.match(reAsciiWord)||[];}/**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */function baseFindKey(collection,predicate,eachFunc){var result;eachFunc(collection,function(value,key,collection){if(predicate(value,key,collection)){result=key;return false;}});return result;}/**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseFindIndex(array,predicate,fromIndex,fromRight){var length=array.length,index=fromIndex+(fromRight?1:-1);while(fromRight?index--:++index<length){if(predicate(array[index],index,array)){return index;}}return -1;}/**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOf(array,value,fromIndex){return value===value?strictIndexOf(array,value,fromIndex):baseFindIndex(array,baseIsNaN,fromIndex);}/**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function baseIndexOfWith(array,value,fromIndex,comparator){var index=fromIndex-1,length=array.length;while(++index<length){if(comparator(array[index],value)){return index;}}return -1;}/**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */function baseIsNaN(value){return value!==value;}/**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */function baseMean(array,iteratee){var length=array==null?0:array.length;return length?baseSum(array,iteratee)/length:NAN;}/**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */function baseProperty(key){return function(object){return object==null?undefined$1:object[key];};}/**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */function basePropertyOf(object){return function(key){return object==null?undefined$1:object[key];};}/**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */function baseReduce(collection,iteratee,accumulator,initAccum,eachFunc){eachFunc(collection,function(value,index,collection){accumulator=initAccum?(initAccum=false,value):iteratee(accumulator,value,index,collection);});return accumulator;}/**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */function baseSortBy(array,comparer){var length=array.length;array.sort(comparer);while(length--){array[length]=array[length].value;}return array;}/**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */function baseSum(array,iteratee){var result,index=-1,length=array.length;while(++index<length){var current=iteratee(array[index]);if(current!==undefined$1){result=result===undefined$1?current:result+current;}}return result;}/**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */function baseTimes(n,iteratee){var index=-1,result=Array(n);while(++index<n){result[index]=iteratee(index);}return result;}/**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */function baseToPairs(object,props){return arrayMap(props,function(key){return [key,object[key]];});}/**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */function baseUnary(func){return function(value){return func(value);};}/**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */function baseValues(object,props){return arrayMap(props,function(key){return object[key];});}/**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */function cacheHas(cache,key){return cache.has(key);}/**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */function charsStartIndex(strSymbols,chrSymbols){var index=-1,length=strSymbols.length;while(++index<length&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */function charsEndIndex(strSymbols,chrSymbols){var index=strSymbols.length;while(index--&&baseIndexOf(chrSymbols,strSymbols[index],0)>-1){}return index;}/**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */function countHolders(array,placeholder){var length=array.length,result=0;while(length--){if(array[length]===placeholder){++result;}}return result;}/**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */var deburrLetter=basePropertyOf(deburredLetters);/**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */var escapeHtmlChar=basePropertyOf(htmlEscapes);/**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */function escapeStringChar(chr){return '\\'+stringEscapes[chr];}/**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */function getValue(object,key){return object==null?undefined$1:object[key];}/**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */function hasUnicode(string){return reHasUnicode.test(string);}/**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */function hasUnicodeWord(string){return reHasUnicodeWord.test(string);}/**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */function iteratorToArray(iterator){var data,result=[];while(!(data=iterator.next()).done){result.push(data.value);}return result;}/**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */function mapToArray(map){var index=-1,result=Array(map.size);map.forEach(function(value,key){result[++index]=[key,value];});return result;}/**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */function overArg(func,transform){return function(arg){return func(transform(arg));};}/**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */function replaceHolders(array,placeholder){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value===placeholder||value===PLACEHOLDER){array[index]=PLACEHOLDER;result[resIndex++]=index;}}return result;}/**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */function setToArray(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=value;});return result;}/**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */function setToPairs(set){var index=-1,result=Array(set.size);set.forEach(function(value){result[++index]=[value,value];});return result;}/**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictIndexOf(array,value,fromIndex){var index=fromIndex-1,length=array.length;while(++index<length){if(array[index]===value){return index;}}return -1;}/**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */function strictLastIndexOf(array,value,fromIndex){var index=fromIndex+1;while(index--){if(array[index]===value){return index;}}return index;}/**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */function stringSize(string){return hasUnicode(string)?unicodeSize(string):asciiSize(string);}/**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function stringToArray(string){return hasUnicode(string)?unicodeToArray(string):asciiToArray(string);}/**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */var unescapeHtmlChar=basePropertyOf(htmlUnescapes);/**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */function unicodeSize(string){var result=reUnicode.lastIndex=0;while(reUnicode.test(string)){++result;}return result;}/**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */function unicodeToArray(string){return string.match(reUnicode)||[];}/**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */function unicodeWords(string){return string.match(reUnicodeWord)||[];}/*--------------------------------------------------------------------------*/ /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */var runInContext=function runInContext(context){context=context==null?root:_.defaults(root.Object(),context,_.pick(root,contextProps));/** Built-in constructor references. */var Array=context.Array,Date=context.Date,Error=context.Error,Function=context.Function,Math=context.Math,Object=context.Object,RegExp=context.RegExp,String=context.String,TypeError=context.TypeError;/** Used for built-in method references. */var arrayProto=Array.prototype,funcProto=Function.prototype,objectProto=Object.prototype;/** Used to detect overreaching core-js shims. */var coreJsData=context['__core-js_shared__'];/** Used to resolve the decompiled source of functions. */var funcToString=funcProto.toString;/** Used to check objects for own properties. */var hasOwnProperty=objectProto.hasOwnProperty;/** Used to generate unique IDs. */var idCounter=0;/** Used to detect methods masquerading as native. */var maskSrcKey=function(){var uid=/[^.]+$/.exec(coreJsData&&coreJsData.keys&&coreJsData.keys.IE_PROTO||'');return uid?'Symbol(src)_1.'+uid:'';}();/**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */var nativeObjectToString=objectProto.toString;/** Used to infer the `Object` constructor. */var objectCtorString=funcToString.call(Object);/** Used to restore the original `_` reference in `_.noConflict`. */var oldDash=root._;/** Used to detect if a method is native. */var reIsNative=RegExp('^'+funcToString.call(hasOwnProperty).replace(reRegExpChar,'\\$&').replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g,'$1.*?')+'$');/** Built-in value references. */var Buffer=moduleExports?context.Buffer:undefined$1,Symbol=context.Symbol,Uint8Array=context.Uint8Array,allocUnsafe=Buffer?Buffer.allocUnsafe:undefined$1,getPrototype=overArg(Object.getPrototypeOf,Object),objectCreate=Object.create,propertyIsEnumerable=objectProto.propertyIsEnumerable,splice=arrayProto.splice,spreadableSymbol=Symbol?Symbol.isConcatSpreadable:undefined$1,symIterator=Symbol?Symbol.iterator:undefined$1,symToStringTag=Symbol?Symbol.toStringTag:undefined$1;var defineProperty=function(){try{var func=getNative(Object,'defineProperty');func({},'',{});return func;}catch(e){}}();/** Mocked built-ins. */var ctxClearTimeout=context.clearTimeout!==root.clearTimeout&&context.clearTimeout,ctxNow=Date&&Date.now!==root.Date.now&&Date.now,ctxSetTimeout=context.setTimeout!==root.setTimeout&&context.setTimeout;/* Built-in method references for those with the same name as other `lodash` methods. */var nativeCeil=Math.ceil,nativeFloor=Math.floor,nativeGetSymbols=Object.getOwnPropertySymbols,nativeIsBuffer=Buffer?Buffer.isBuffer:undefined$1,nativeIsFinite=context.isFinite,nativeJoin=arrayProto.join,nativeKeys=overArg(Object.keys,Object),nativeMax=Math.max,nativeMin=Math.min,nativeNow=Date.now,nativeParseInt=context.parseInt,nativeRandom=Math.random,nativeReverse=arrayProto.reverse;/* Built-in method references that are verified to be native. */var DataView=getNative(context,'DataView'),Map=getNative(context,'Map'),Promise=getNative(context,'Promise'),Set=getNative(context,'Set'),WeakMap=getNative(context,'WeakMap'),nativeCreate=getNative(Object,'create');/** Used to store function metadata. */var metaMap=WeakMap&&new WeakMap();/** Used to lookup unminified function names. */var realNames={};/** Used to detect maps, sets, and weakmaps. */var dataViewCtorString=toSource(DataView),mapCtorString=toSource(Map),promiseCtorString=toSource(Promise),setCtorString=toSource(Set),weakMapCtorString=toSource(WeakMap);/** Used to convert symbols to primitives and strings. */var symbolProto=Symbol?Symbol.prototype:undefined$1,symbolValueOf=symbolProto?symbolProto.valueOf:undefined$1,symbolToString=symbolProto?symbolProto.toString:undefined$1;/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */function lodash(value){if(isObjectLike(value)&&!isArray(value)&&!(value instanceof LazyWrapper)){if(value instanceof LodashWrapper){return value;}if(hasOwnProperty.call(value,'__wrapped__')){return wrapperClone(value);}}return new LodashWrapper(value);}/**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */var baseCreate=function(){function object(){}return function(proto){if(!isObject(proto)){return {};}if(objectCreate){return objectCreate(proto);}object.prototype=proto;var result=new object();object.prototype=undefined$1;return result;};}();/**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */function baseLodash(){// No operation performed.
}/**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */function LodashWrapper(value,chainAll){this.__wrapped__=value;this.__actions__=[];this.__chain__=!!chainAll;this.__index__=0;this.__values__=undefined$1;}/**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */lodash.templateSettings={/**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'escape':reEscape,/**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'evaluate':reEvaluate,/**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */'interpolate':reInterpolate,/**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */'variable':'',/**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */'imports':{/**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */'_':lodash}};// Ensure wrappers are instances of `baseLodash`.
lodash.prototype=baseLodash.prototype;lodash.prototype.constructor=lodash;LodashWrapper.prototype=baseCreate(baseLodash.prototype);LodashWrapper.prototype.constructor=LodashWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */function LazyWrapper(value){this.__wrapped__=value;this.__actions__=[];this.__dir__=1;this.__filtered__=false;this.__iteratees__=[];this.__takeCount__=MAX_ARRAY_LENGTH;this.__views__=[];}/**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */function lazyClone(){var result=new LazyWrapper(this.__wrapped__);result.__actions__=copyArray(this.__actions__);result.__dir__=this.__dir__;result.__filtered__=this.__filtered__;result.__iteratees__=copyArray(this.__iteratees__);result.__takeCount__=this.__takeCount__;result.__views__=copyArray(this.__views__);return result;}/**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */function lazyReverse(){if(this.__filtered__){var result=new LazyWrapper(this);result.__dir__=-1;result.__filtered__=true;}else {result=this.clone();result.__dir__*=-1;}return result;}/**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */function lazyValue(){var array=this.__wrapped__.value(),dir=this.__dir__,isArr=isArray(array),isRight=dir<0,arrLength=isArr?array.length:0,view=getView(0,arrLength,this.__views__),start=view.start,end=view.end,length=end-start,index=isRight?end:start-1,iteratees=this.__iteratees__,iterLength=iteratees.length,resIndex=0,takeCount=nativeMin(length,this.__takeCount__);if(!isArr||!isRight&&arrLength==length&&takeCount==length){return baseWrapperValue(array,this.__actions__);}var result=[];outer:while(length--&&resIndex<takeCount){index+=dir;var iterIndex=-1,value=array[index];while(++iterIndex<iterLength){var data=iteratees[iterIndex],iteratee=data.iteratee,type=data.type,computed=iteratee(value);if(type==LAZY_MAP_FLAG){value=computed;}else if(!computed){if(type==LAZY_FILTER_FLAG){continue outer;}else {break outer;}}}result[resIndex++]=value;}return result;}// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype=baseCreate(baseLodash.prototype);LazyWrapper.prototype.constructor=LazyWrapper;/*------------------------------------------------------------------------*/ /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Hash(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */function hashClear(){this.__data__=nativeCreate?nativeCreate(null):{};this.size=0;}/**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function hashDelete(key){var result=this.has(key)&&delete this.__data__[key];this.size-=result?1:0;return result;}/**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function hashGet(key){var data=this.__data__;if(nativeCreate){var result=data[key];return result===HASH_UNDEFINED?undefined$1:result;}return hasOwnProperty.call(data,key)?data[key]:undefined$1;}/**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function hashHas(key){var data=this.__data__;return nativeCreate?data[key]!==undefined$1:hasOwnProperty.call(data,key);}/**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */function hashSet(key,value){var data=this.__data__;this.size+=this.has(key)?0:1;data[key]=nativeCreate&&value===undefined$1?HASH_UNDEFINED:value;return this;}// Add methods to `Hash`.
Hash.prototype.clear=hashClear;Hash.prototype['delete']=hashDelete;Hash.prototype.get=hashGet;Hash.prototype.has=hashHas;Hash.prototype.set=hashSet;/*------------------------------------------------------------------------*/ /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function ListCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */function listCacheClear(){this.__data__=[];this.size=0;}/**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function listCacheDelete(key){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){return false;}var lastIndex=data.length-1;if(index==lastIndex){data.pop();}else {splice.call(data,index,1);}--this.size;return true;}/**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function listCacheGet(key){var data=this.__data__,index=assocIndexOf(data,key);return index<0?undefined$1:data[index][1];}/**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function listCacheHas(key){return assocIndexOf(this.__data__,key)>-1;}/**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */function listCacheSet(key,value){var data=this.__data__,index=assocIndexOf(data,key);if(index<0){++this.size;data.push([key,value]);}else {data[index][1]=value;}return this;}// Add methods to `ListCache`.
ListCache.prototype.clear=listCacheClear;ListCache.prototype['delete']=listCacheDelete;ListCache.prototype.get=listCacheGet;ListCache.prototype.has=listCacheHas;ListCache.prototype.set=listCacheSet;/*------------------------------------------------------------------------*/ /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function MapCache(entries){var index=-1,length=entries==null?0:entries.length;this.clear();while(++index<length){var entry=entries[index];this.set(entry[0],entry[1]);}}/**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */function mapCacheClear(){this.size=0;this.__data__={'hash':new Hash(),'map':new(Map||ListCache)(),'string':new Hash()};}/**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function mapCacheDelete(key){var result=getMapData(this,key)['delete'](key);this.size-=result?1:0;return result;}/**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function mapCacheGet(key){return getMapData(this,key).get(key);}/**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function mapCacheHas(key){return getMapData(this,key).has(key);}/**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */function mapCacheSet(key,value){var data=getMapData(this,key),size=data.size;data.set(key,value);this.size+=data.size==size?0:1;return this;}// Add methods to `MapCache`.
MapCache.prototype.clear=mapCacheClear;MapCache.prototype['delete']=mapCacheDelete;MapCache.prototype.get=mapCacheGet;MapCache.prototype.has=mapCacheHas;MapCache.prototype.set=mapCacheSet;/*------------------------------------------------------------------------*/ /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */function SetCache(values){var index=-1,length=values==null?0:values.length;this.__data__=new MapCache();while(++index<length){this.add(values[index]);}}/**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */function setCacheAdd(value){this.__data__.set(value,HASH_UNDEFINED);return this;}/**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */function setCacheHas(value){return this.__data__.has(value);}// Add methods to `SetCache`.
SetCache.prototype.add=SetCache.prototype.push=setCacheAdd;SetCache.prototype.has=setCacheHas;/*------------------------------------------------------------------------*/ /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */function Stack(entries){var data=this.__data__=new ListCache(entries);this.size=data.size;}/**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */function stackClear(){this.__data__=new ListCache();this.size=0;}/**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */function stackDelete(key){var data=this.__data__,result=data['delete'](key);this.size=data.size;return result;}/**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */function stackGet(key){return this.__data__.get(key);}/**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */function stackHas(key){return this.__data__.has(key);}/**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */function stackSet(key,value){var data=this.__data__;if(data instanceof ListCache){var pairs=data.__data__;if(!Map||pairs.length<LARGE_ARRAY_SIZE-1){pairs.push([key,value]);this.size=++data.size;return this;}data=this.__data__=new MapCache(pairs);}data.set(key,value);this.size=data.size;return this;}// Add methods to `Stack`.
Stack.prototype.clear=stackClear;Stack.prototype['delete']=stackDelete;Stack.prototype.get=stackGet;Stack.prototype.has=stackHas;Stack.prototype.set=stackSet;/*------------------------------------------------------------------------*/ /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */function arrayLikeKeys(value,inherited){var isArr=isArray(value),isArg=!isArr&&isArguments(value),isBuff=!isArr&&!isArg&&isBuffer(value),isType=!isArr&&!isArg&&!isBuff&&isTypedArray(value),skipIndexes=isArr||isArg||isBuff||isType,result=skipIndexes?baseTimes(value.length,String):[],length=result.length;for(var key in value){if((inherited||hasOwnProperty.call(value,key))&&!(skipIndexes&&(// Safari 9 has enumerable `arguments.length` in strict mode.
key=='length'||// Node.js 0.10 has enumerable non-index properties on buffers.
isBuff&&(key=='offset'||key=='parent')||// PhantomJS 2 has enumerable non-index properties on typed arrays.
isType&&(key=='buffer'||key=='byteLength'||key=='byteOffset')||// Skip index properties.
isIndex(key,length)))){result.push(key);}}return result;}/**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */function arraySample(array){var length=array.length;return length?array[baseRandom(0,length-1)]:undefined$1;}/**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function arraySampleSize(array,n){return shuffleSelf(copyArray(array),baseClamp(n,0,array.length));}/**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function arrayShuffle(array){return shuffleSelf(copyArray(array));}/**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignMergeValue(object,key,value){if(value!==undefined$1&&!eq(object[key],value)||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function assignValue(object,key,value){var objValue=object[key];if(!(hasOwnProperty.call(object,key)&&eq(objValue,value))||value===undefined$1&&!(key in object)){baseAssignValue(object,key,value);}}/**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */function assocIndexOf(array,key){var length=array.length;while(length--){if(eq(array[length][0],key)){return length;}}return -1;}/**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */function baseAggregator(collection,setter,iteratee,accumulator){baseEach(collection,function(value,key,collection){setter(accumulator,value,iteratee(value),collection);});return accumulator;}/**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssign(object,source){return object&&copyObject(source,keys(source),object);}/**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */function baseAssignIn(object,source){return object&&copyObject(source,keysIn(source),object);}/**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */function baseAssignValue(object,key,value){if(key=='__proto__'&&defineProperty){defineProperty(object,key,{'configurable':true,'enumerable':true,'value':value,'writable':true});}else {object[key]=value;}}/**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */function baseAt(object,paths){var index=-1,length=paths.length,result=Array(length),skip=object==null;while(++index<length){result[index]=skip?undefined$1:get(object,paths[index]);}return result;}/**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */function baseClamp(number,lower,upper){if(number===number){if(upper!==undefined$1){number=number<=upper?number:upper;}if(lower!==undefined$1){number=number>=lower?number:lower;}}return number;}/**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */function baseClone(value,bitmask,customizer,key,object,stack){var result,isDeep=bitmask&CLONE_DEEP_FLAG,isFlat=bitmask&CLONE_FLAT_FLAG,isFull=bitmask&CLONE_SYMBOLS_FLAG;if(customizer){result=object?customizer(value,key,object,stack):customizer(value);}if(result!==undefined$1){return result;}if(!isObject(value)){return value;}var isArr=isArray(value);if(isArr){result=initCloneArray(value);if(!isDeep){return copyArray(value,result);}}else {var tag=getTag(value),isFunc=tag==funcTag||tag==genTag;if(isBuffer(value)){return cloneBuffer(value,isDeep);}if(tag==objectTag||tag==argsTag||isFunc&&!object){result=isFlat||isFunc?{}:initCloneObject(value);if(!isDeep){return isFlat?copySymbolsIn(value,baseAssignIn(result,value)):copySymbols(value,baseAssign(result,value));}}else {if(!cloneableTags[tag]){return object?value:{};}result=initCloneByTag(value,tag,isDeep);}}// Check for circular references and return its corresponding clone.
stack||(stack=new Stack());var stacked=stack.get(value);if(stacked){return stacked;}stack.set(value,result);if(isSet(value)){value.forEach(function(subValue){result.add(baseClone(subValue,bitmask,customizer,subValue,value,stack));});}else if(isMap(value)){value.forEach(function(subValue,key){result.set(key,baseClone(subValue,bitmask,customizer,key,value,stack));});}var keysFunc=isFull?isFlat?getAllKeysIn:getAllKeys:isFlat?keysIn:keys;var props=isArr?undefined$1:keysFunc(value);arrayEach(props||value,function(subValue,key){if(props){key=subValue;subValue=value[key];}// Recursively populate clone (susceptible to call stack limits).
assignValue(result,key,baseClone(subValue,bitmask,customizer,key,value,stack));});return result;}/**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */function baseConforms(source){var props=keys(source);return function(object){return baseConformsTo(object,source,props);};}/**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */function baseConformsTo(object,source,props){var length=props.length;if(object==null){return !length;}object=Object(object);while(length--){var key=props[length],predicate=source[key],value=object[key];if(value===undefined$1&&!(key in object)||!predicate(value)){return false;}}return true;}/**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */function baseDelay(func,wait,args){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return setTimeout(function(){func.apply(undefined$1,args);},wait);}/**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */function baseDifference(array,values,iteratee,comparator){var index=-1,includes=arrayIncludes,isCommon=true,length=array.length,result=[],valuesLength=values.length;if(!length){return result;}if(iteratee){values=arrayMap(values,baseUnary(iteratee));}if(comparator){includes=arrayIncludesWith;isCommon=false;}else if(values.length>=LARGE_ARRAY_SIZE){includes=cacheHas;isCommon=false;values=new SetCache(values);}outer:while(++index<length){var value=array[index],computed=iteratee==null?value:iteratee(value);value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var valuesIndex=valuesLength;while(valuesIndex--){if(values[valuesIndex]===computed){continue outer;}}result.push(value);}else if(!includes(values,computed,comparator)){result.push(value);}}return result;}/**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEach=createBaseEach(baseForOwn);/**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */var baseEachRight=createBaseEach(baseForOwnRight,true);/**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */function baseEvery(collection,predicate){var result=true;baseEach(collection,function(value,index,collection){result=!!predicate(value,index,collection);return result;});return result;}/**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */function baseExtremum(array,iteratee,comparator){var index=-1,length=array.length;while(++index<length){var value=array[index],current=iteratee(value);if(current!=null&&(computed===undefined$1?current===current&&!isSymbol(current):comparator(current,computed))){var computed=current,result=value;}}return result;}/**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */function baseFill(array,value,start,end){var length=array.length;start=toInteger(start);if(start<0){start=-start>length?0:length+start;}end=end===undefined$1||end>length?length:toInteger(end);if(end<0){end+=length;}end=start>end?0:toLength(end);while(start<end){array[start++]=value;}return array;}/**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */function baseFilter(collection,predicate){var result=[];baseEach(collection,function(value,index,collection){if(predicate(value,index,collection)){result.push(value);}});return result;}/**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */function baseFlatten(array,depth,predicate,isStrict,result){var index=-1,length=array.length;predicate||(predicate=isFlattenable);result||(result=[]);while(++index<length){var value=array[index];if(depth>0&&predicate(value)){if(depth>1){// Recursively flatten arrays (susceptible to call stack limits).
baseFlatten(value,depth-1,predicate,isStrict,result);}else {arrayPush(result,value);}}else if(!isStrict){result[result.length]=value;}}return result;}/**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseFor=createBaseFor();/**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */var baseForRight=createBaseFor(true);/**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwn(object,iteratee){return object&&baseFor(object,iteratee,keys);}/**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */function baseForOwnRight(object,iteratee){return object&&baseForRight(object,iteratee,keys);}/**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */function baseFunctions(object,props){return arrayFilter(props,function(key){return isFunction(object[key]);});}/**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */function baseGet(object,path){path=castPath(path,object);var index=0,length=path.length;while(object!=null&&index<length){object=object[toKey(path[index++])];}return index&&index==length?object:undefined$1;}/**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */function baseGetAllKeys(object,keysFunc,symbolsFunc){var result=keysFunc(object);return isArray(object)?result:arrayPush(result,symbolsFunc(object));}/**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */function baseGetTag(value){if(value==null){return value===undefined$1?undefinedTag:nullTag;}return symToStringTag&&symToStringTag in Object(value)?getRawTag(value):objectToString(value);}/**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */function baseGt(value,other){return value>other;}/**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHas(object,key){return object!=null&&hasOwnProperty.call(object,key);}/**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */function baseHasIn(object,key){return object!=null&&key in Object(object);}/**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */function baseInRange(number,start,end){return number>=nativeMin(start,end)&&number<nativeMax(start,end);}/**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */function baseIntersection(arrays,iteratee,comparator){var includes=comparator?arrayIncludesWith:arrayIncludes,length=arrays[0].length,othLength=arrays.length,othIndex=othLength,caches=Array(othLength),maxLength=Infinity,result=[];while(othIndex--){var array=arrays[othIndex];if(othIndex&&iteratee){array=arrayMap(array,baseUnary(iteratee));}maxLength=nativeMin(array.length,maxLength);caches[othIndex]=!comparator&&(iteratee||length>=120&&array.length>=120)?new SetCache(othIndex&&array):undefined$1;}array=arrays[0];var index=-1,seen=caches[0];outer:while(++index<length&&result.length<maxLength){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(!(seen?cacheHas(seen,computed):includes(result,computed,comparator))){othIndex=othLength;while(--othIndex){var cache=caches[othIndex];if(!(cache?cacheHas(cache,computed):includes(arrays[othIndex],computed,comparator))){continue outer;}}if(seen){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */function baseInverter(object,setter,iteratee,accumulator){baseForOwn(object,function(value,key,object){setter(accumulator,iteratee(value),key,object);});return accumulator;}/**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */function baseInvoke(object,path,args){path=castPath(path,object);object=parent(object,path);var func=object==null?object:object[toKey(last(path))];return func==null?undefined$1:apply(func,object,args);}/**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */function baseIsArguments(value){return isObjectLike(value)&&baseGetTag(value)==argsTag;}/**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */function baseIsArrayBuffer(value){return isObjectLike(value)&&baseGetTag(value)==arrayBufferTag;}/**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */function baseIsDate(value){return isObjectLike(value)&&baseGetTag(value)==dateTag;}/**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */function baseIsEqual(value,other,bitmask,customizer,stack){if(value===other){return true;}if(value==null||other==null||!isObjectLike(value)&&!isObjectLike(other)){return value!==value&&other!==other;}return baseIsEqualDeep(value,other,bitmask,customizer,baseIsEqual,stack);}/**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function baseIsEqualDeep(object,other,bitmask,customizer,equalFunc,stack){var objIsArr=isArray(object),othIsArr=isArray(other),objTag=objIsArr?arrayTag:getTag(object),othTag=othIsArr?arrayTag:getTag(other);objTag=objTag==argsTag?objectTag:objTag;othTag=othTag==argsTag?objectTag:othTag;var objIsObj=objTag==objectTag,othIsObj=othTag==objectTag,isSameTag=objTag==othTag;if(isSameTag&&isBuffer(object)){if(!isBuffer(other)){return false;}objIsArr=true;objIsObj=false;}if(isSameTag&&!objIsObj){stack||(stack=new Stack());return objIsArr||isTypedArray(object)?equalArrays(object,other,bitmask,customizer,equalFunc,stack):equalByTag(object,other,objTag,bitmask,customizer,equalFunc,stack);}if(!(bitmask&COMPARE_PARTIAL_FLAG)){var objIsWrapped=objIsObj&&hasOwnProperty.call(object,'__wrapped__'),othIsWrapped=othIsObj&&hasOwnProperty.call(other,'__wrapped__');if(objIsWrapped||othIsWrapped){var objUnwrapped=objIsWrapped?object.value():object,othUnwrapped=othIsWrapped?other.value():other;stack||(stack=new Stack());return equalFunc(objUnwrapped,othUnwrapped,bitmask,customizer,stack);}}if(!isSameTag){return false;}stack||(stack=new Stack());return equalObjects(object,other,bitmask,customizer,equalFunc,stack);}/**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */function baseIsMap(value){return isObjectLike(value)&&getTag(value)==mapTag;}/**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */function baseIsMatch(object,source,matchData,customizer){var index=matchData.length,length=index,noCustomizer=!customizer;if(object==null){return !length;}object=Object(object);while(index--){var data=matchData[index];if(noCustomizer&&data[2]?data[1]!==object[data[0]]:!(data[0]in object)){return false;}}while(++index<length){data=matchData[index];var key=data[0],objValue=object[key],srcValue=data[1];if(noCustomizer&&data[2]){if(objValue===undefined$1&&!(key in object)){return false;}}else {var stack=new Stack();if(customizer){var result=customizer(objValue,srcValue,key,object,source,stack);}if(!(result===undefined$1?baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG,customizer,stack):result)){return false;}}}return true;}/**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */function baseIsNative(value){if(!isObject(value)||isMasked(value)){return false;}var pattern=isFunction(value)?reIsNative:reIsHostCtor;return pattern.test(toSource(value));}/**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */function baseIsRegExp(value){return isObjectLike(value)&&baseGetTag(value)==regexpTag;}/**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */function baseIsSet(value){return isObjectLike(value)&&getTag(value)==setTag;}/**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */function baseIsTypedArray(value){return isObjectLike(value)&&isLength(value.length)&&!!typedArrayTags[baseGetTag(value)];}/**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */function baseIteratee(value){// Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
// See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
if(typeof value=='function'){return value;}if(value==null){return identity;}if(typeof value=='object'){return isArray(value)?baseMatchesProperty(value[0],value[1]):baseMatches(value);}return property(value);}/**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeys(object){if(!isPrototype(object)){return nativeKeys(object);}var result=[];for(var key in Object(object)){if(hasOwnProperty.call(object,key)&&key!='constructor'){result.push(key);}}return result;}/**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function baseKeysIn(object){if(!isObject(object)){return nativeKeysIn(object);}var isProto=isPrototype(object),result=[];for(var key in object){if(!(key=='constructor'&&(isProto||!hasOwnProperty.call(object,key)))){result.push(key);}}return result;}/**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */function baseLt(value,other){return value<other;}/**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */function baseMap(collection,iteratee){var index=-1,result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value,key,collection){result[++index]=iteratee(value,key,collection);});return result;}/**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatches(source){var matchData=getMatchData(source);if(matchData.length==1&&matchData[0][2]){return matchesStrictComparable(matchData[0][0],matchData[0][1]);}return function(object){return object===source||baseIsMatch(object,source,matchData);};}/**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function baseMatchesProperty(path,srcValue){if(isKey(path)&&isStrictComparable(srcValue)){return matchesStrictComparable(toKey(path),srcValue);}return function(object){var objValue=get(object,path);return objValue===undefined$1&&objValue===srcValue?hasIn(object,path):baseIsEqual(srcValue,objValue,COMPARE_PARTIAL_FLAG|COMPARE_UNORDERED_FLAG);};}/**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMerge(object,source,srcIndex,customizer,stack){if(object===source){return;}baseFor(source,function(srcValue,key){stack||(stack=new Stack());if(isObject(srcValue)){baseMergeDeep(object,source,key,srcIndex,baseMerge,customizer,stack);}else {var newValue=customizer?customizer(safeGet(object,key),srcValue,key+'',object,source,stack):undefined$1;if(newValue===undefined$1){newValue=srcValue;}assignMergeValue(object,key,newValue);}},keysIn);}/**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */function baseMergeDeep(object,source,key,srcIndex,mergeFunc,customizer,stack){var objValue=safeGet(object,key),srcValue=safeGet(source,key),stacked=stack.get(srcValue);if(stacked){assignMergeValue(object,key,stacked);return;}var newValue=customizer?customizer(objValue,srcValue,key+'',object,source,stack):undefined$1;var isCommon=newValue===undefined$1;if(isCommon){var isArr=isArray(srcValue),isBuff=!isArr&&isBuffer(srcValue),isTyped=!isArr&&!isBuff&&isTypedArray(srcValue);newValue=srcValue;if(isArr||isBuff||isTyped){if(isArray(objValue)){newValue=objValue;}else if(isArrayLikeObject(objValue)){newValue=copyArray(objValue);}else if(isBuff){isCommon=false;newValue=cloneBuffer(srcValue,true);}else if(isTyped){isCommon=false;newValue=cloneTypedArray(srcValue,true);}else {newValue=[];}}else if(isPlainObject(srcValue)||isArguments(srcValue)){newValue=objValue;if(isArguments(objValue)){newValue=toPlainObject(objValue);}else if(!isObject(objValue)||isFunction(objValue)){newValue=initCloneObject(srcValue);}}else {isCommon=false;}}if(isCommon){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,newValue);mergeFunc(newValue,srcValue,srcIndex,customizer,stack);stack['delete'](srcValue);}assignMergeValue(object,key,newValue);}/**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */function baseNth(array,n){var length=array.length;if(!length){return;}n+=n<0?length:0;return isIndex(n,length)?array[n]:undefined$1;}/**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */function baseOrderBy(collection,iteratees,orders){if(iteratees.length){iteratees=arrayMap(iteratees,function(iteratee){if(isArray(iteratee)){return function(value){return baseGet(value,iteratee.length===1?iteratee[0]:iteratee);};}return iteratee;});}else {iteratees=[identity];}var index=-1;iteratees=arrayMap(iteratees,baseUnary(getIteratee()));var result=baseMap(collection,function(value,key,collection){var criteria=arrayMap(iteratees,function(iteratee){return iteratee(value);});return {'criteria':criteria,'index':++index,'value':value};});return baseSortBy(result,function(object,other){return compareMultiple(object,other,orders);});}/**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */function basePick(object,paths){return basePickBy(object,paths,function(value,path){return hasIn(object,path);});}/**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */function basePickBy(object,paths,predicate){var index=-1,length=paths.length,result={};while(++index<length){var path=paths[index],value=baseGet(object,path);if(predicate(value,path)){baseSet(result,castPath(path,object),value);}}return result;}/**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */function basePropertyDeep(path){return function(object){return baseGet(object,path);};}/**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */function basePullAll(array,values,iteratee,comparator){var indexOf=comparator?baseIndexOfWith:baseIndexOf,index=-1,length=values.length,seen=array;if(array===values){values=copyArray(values);}if(iteratee){seen=arrayMap(array,baseUnary(iteratee));}while(++index<length){var fromIndex=0,value=values[index],computed=iteratee?iteratee(value):value;while((fromIndex=indexOf(seen,computed,fromIndex,comparator))>-1){if(seen!==array){splice.call(seen,fromIndex,1);}splice.call(array,fromIndex,1);}}return array;}/**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */function basePullAt(array,indexes){var length=array?indexes.length:0,lastIndex=length-1;while(length--){var index=indexes[length];if(length==lastIndex||index!==previous){var previous=index;if(isIndex(index)){splice.call(array,index,1);}else {baseUnset(array,index);}}}return array;}/**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */function baseRandom(lower,upper){return lower+nativeFloor(nativeRandom()*(upper-lower+1));}/**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */function baseRange(start,end,step,fromRight){var index=-1,length=nativeMax(nativeCeil((end-start)/(step||1)),0),result=Array(length);while(length--){result[fromRight?length:++index]=start;start+=step;}return result;}/**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */function baseRepeat(string,n){var result='';if(!string||n<1||n>MAX_SAFE_INTEGER){return result;}// Leverage the exponentiation by squaring algorithm for a faster repeat.
// See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
do{if(n%2){result+=string;}n=nativeFloor(n/2);if(n){string+=string;}}while(n);return result;}/**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */function baseRest(func,start){return setToString(overRest(func,start,identity),func+'');}/**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */function baseSample(collection){return arraySample(values(collection));}/**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */function baseSampleSize(collection,n){var array=values(collection);return shuffleSelf(array,baseClamp(n,0,array.length));}/**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseSet(object,path,value,customizer){if(!isObject(object)){return object;}path=castPath(path,object);var index=-1,length=path.length,lastIndex=length-1,nested=object;while(nested!=null&&++index<length){var key=toKey(path[index]),newValue=value;if(key==='__proto__'||key==='constructor'||key==='prototype'){return object;}if(index!=lastIndex){var objValue=nested[key];newValue=customizer?customizer(objValue,key,nested):undefined$1;if(newValue===undefined$1){newValue=isObject(objValue)?objValue:isIndex(path[index+1])?[]:{};}}assignValue(nested,key,newValue);nested=nested[key];}return object;}/**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var baseSetData=!metaMap?identity:function(func,data){metaMap.set(func,data);return func;};/**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var baseSetToString=!defineProperty?identity:function(func,string){return defineProperty(func,'toString',{'configurable':true,'enumerable':false,'value':constant(string),'writable':true});};/**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */function baseShuffle(collection){return shuffleSelf(values(collection));}/**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function baseSlice(array,start,end){var index=-1,length=array.length;if(start<0){start=-start>length?0:length+start;}end=end>length?length:end;if(end<0){end+=length;}length=start>end?0:end-start>>>0;start>>>=0;var result=Array(length);while(++index<length){result[index]=array[index+start];}return result;}/**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */function baseSome(collection,predicate){var result;baseEach(collection,function(value,index,collection){result=predicate(value,index,collection);return !result;});return !!result;}/**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndex(array,value,retHighest){var low=0,high=array==null?low:array.length;if(typeof value=='number'&&value===value&&high<=HALF_MAX_ARRAY_LENGTH){while(low<high){var mid=low+high>>>1,computed=array[mid];if(computed!==null&&!isSymbol(computed)&&(retHighest?computed<=value:computed<value)){low=mid+1;}else {high=mid;}}return high;}return baseSortedIndexBy(array,value,identity,retHighest);}/**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */function baseSortedIndexBy(array,value,iteratee,retHighest){var low=0,high=array==null?0:array.length;if(high===0){return 0;}value=iteratee(value);var valIsNaN=value!==value,valIsNull=value===null,valIsSymbol=isSymbol(value),valIsUndefined=value===undefined$1;while(low<high){var mid=nativeFloor((low+high)/2),computed=iteratee(array[mid]),othIsDefined=computed!==undefined$1,othIsNull=computed===null,othIsReflexive=computed===computed,othIsSymbol=isSymbol(computed);if(valIsNaN){var setLow=retHighest||othIsReflexive;}else if(valIsUndefined){setLow=othIsReflexive&&(retHighest||othIsDefined);}else if(valIsNull){setLow=othIsReflexive&&othIsDefined&&(retHighest||!othIsNull);}else if(valIsSymbol){setLow=othIsReflexive&&othIsDefined&&!othIsNull&&(retHighest||!othIsSymbol);}else if(othIsNull||othIsSymbol){setLow=false;}else {setLow=retHighest?computed<=value:computed<value;}if(setLow){low=mid+1;}else {high=mid;}}return nativeMin(high,MAX_ARRAY_INDEX);}/**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseSortedUniq(array,iteratee){var index=-1,length=array.length,resIndex=0,result=[];while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;if(!index||!eq(computed,seen)){var seen=computed;result[resIndex++]=value===0?0:value;}}return result;}/**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */function baseToNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}return +value;}/**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */function baseToString(value){// Exit early for strings to avoid a performance hit in some environments.
if(typeof value=='string'){return value;}if(isArray(value)){// Recursively convert values (susceptible to call stack limits).
return arrayMap(value,baseToString)+'';}if(isSymbol(value)){return symbolToString?symbolToString.call(value):'';}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */function baseUniq(array,iteratee,comparator){var index=-1,includes=arrayIncludes,length=array.length,isCommon=true,result=[],seen=result;if(comparator){isCommon=false;includes=arrayIncludesWith;}else if(length>=LARGE_ARRAY_SIZE){var set=iteratee?null:createSet(array);if(set){return setToArray(set);}isCommon=false;includes=cacheHas;seen=new SetCache();}else {seen=iteratee?[]:result;}outer:while(++index<length){var value=array[index],computed=iteratee?iteratee(value):value;value=comparator||value!==0?value:0;if(isCommon&&computed===computed){var seenIndex=seen.length;while(seenIndex--){if(seen[seenIndex]===computed){continue outer;}}if(iteratee){seen.push(computed);}result.push(value);}else if(!includes(seen,computed,comparator)){if(seen!==result){seen.push(computed);}result.push(value);}}return result;}/**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */function baseUnset(object,path){path=castPath(path,object);object=parent(object,path);return object==null||delete object[toKey(last(path))];}/**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */function baseUpdate(object,path,updater,customizer){return baseSet(object,path,updater(baseGet(object,path)),customizer);}/**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */function baseWhile(array,predicate,isDrop,fromRight){var length=array.length,index=fromRight?length:-1;while((fromRight?index--:++index<length)&&predicate(array[index],index,array)){}return isDrop?baseSlice(array,fromRight?0:index,fromRight?index+1:length):baseSlice(array,fromRight?index+1:0,fromRight?length:index);}/**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */function baseWrapperValue(value,actions){var result=value;if(result instanceof LazyWrapper){result=result.value();}return arrayReduce(actions,function(result,action){return action.func.apply(action.thisArg,arrayPush([result],action.args));},result);}/**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */function baseXor(arrays,iteratee,comparator){var length=arrays.length;if(length<2){return length?baseUniq(arrays[0]):[];}var index=-1,result=Array(length);while(++index<length){var array=arrays[index],othIndex=-1;while(++othIndex<length){if(othIndex!=index){result[index]=baseDifference(result[index]||array,arrays[othIndex],iteratee,comparator);}}}return baseUniq(baseFlatten(result,1),iteratee,comparator);}/**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */function baseZipObject(props,values,assignFunc){var index=-1,length=props.length,valsLength=values.length,result={};while(++index<length){var value=index<valsLength?values[index]:undefined$1;assignFunc(result,props[index],value);}return result;}/**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */function castArrayLikeObject(value){return isArrayLikeObject(value)?value:[];}/**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */function castFunction(value){return typeof value=='function'?value:identity;}/**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */function castPath(value,object){if(isArray(value)){return value;}return isKey(value,object)?[value]:stringToPath(toString(value));}/**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */var castRest=baseRest;/**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */function castSlice(array,start,end){var length=array.length;end=end===undefined$1?length:end;return !start&&end>=length?array:baseSlice(array,start,end);}/**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */var clearTimeout=ctxClearTimeout||function(id){return root.clearTimeout(id);};/**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */function cloneBuffer(buffer,isDeep){if(isDeep){return buffer.slice();}var length=buffer.length,result=allocUnsafe?allocUnsafe(length):new buffer.constructor(length);buffer.copy(result);return result;}/**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */function cloneArrayBuffer(arrayBuffer){var result=new arrayBuffer.constructor(arrayBuffer.byteLength);new Uint8Array(result).set(new Uint8Array(arrayBuffer));return result;}/**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */function cloneDataView(dataView,isDeep){var buffer=isDeep?cloneArrayBuffer(dataView.buffer):dataView.buffer;return new dataView.constructor(buffer,dataView.byteOffset,dataView.byteLength);}/**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */function cloneRegExp(regexp){var result=new regexp.constructor(regexp.source,reFlags.exec(regexp));result.lastIndex=regexp.lastIndex;return result;}/**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */function cloneSymbol(symbol){return symbolValueOf?Object(symbolValueOf.call(symbol)):{};}/**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */function cloneTypedArray(typedArray,isDeep){var buffer=isDeep?cloneArrayBuffer(typedArray.buffer):typedArray.buffer;return new typedArray.constructor(buffer,typedArray.byteOffset,typedArray.length);}/**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */function compareAscending(value,other){if(value!==other){var valIsDefined=value!==undefined$1,valIsNull=value===null,valIsReflexive=value===value,valIsSymbol=isSymbol(value);var othIsDefined=other!==undefined$1,othIsNull=other===null,othIsReflexive=other===other,othIsSymbol=isSymbol(other);if(!othIsNull&&!othIsSymbol&&!valIsSymbol&&value>other||valIsSymbol&&othIsDefined&&othIsReflexive&&!othIsNull&&!othIsSymbol||valIsNull&&othIsDefined&&othIsReflexive||!valIsDefined&&othIsReflexive||!valIsReflexive){return 1;}if(!valIsNull&&!valIsSymbol&&!othIsSymbol&&value<other||othIsSymbol&&valIsDefined&&valIsReflexive&&!valIsNull&&!valIsSymbol||othIsNull&&valIsDefined&&valIsReflexive||!othIsDefined&&valIsReflexive||!othIsReflexive){return -1;}}return 0;}/**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */function compareMultiple(object,other,orders){var index=-1,objCriteria=object.criteria,othCriteria=other.criteria,length=objCriteria.length,ordersLength=orders.length;while(++index<length){var result=compareAscending(objCriteria[index],othCriteria[index]);if(result){if(index>=ordersLength){return result;}var order=orders[index];return result*(order=='desc'?-1:1);}}// Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
// that causes it, under certain circumstances, to provide the same value for
// `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
// for more details.
//
// This also ensures a stable sort in V8 and other engines.
// See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
return object.index-other.index;}/**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgs(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersLength=holders.length,leftIndex=-1,leftLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(leftLength+rangeLength),isUncurried=!isCurried;while(++leftIndex<leftLength){result[leftIndex]=partials[leftIndex];}while(++argsIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[holders[argsIndex]]=args[argsIndex];}}while(rangeLength--){result[leftIndex++]=args[argsIndex++];}return result;}/**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */function composeArgsRight(args,partials,holders,isCurried){var argsIndex=-1,argsLength=args.length,holdersIndex=-1,holdersLength=holders.length,rightIndex=-1,rightLength=partials.length,rangeLength=nativeMax(argsLength-holdersLength,0),result=Array(rangeLength+rightLength),isUncurried=!isCurried;while(++argsIndex<rangeLength){result[argsIndex]=args[argsIndex];}var offset=argsIndex;while(++rightIndex<rightLength){result[offset+rightIndex]=partials[rightIndex];}while(++holdersIndex<holdersLength){if(isUncurried||argsIndex<argsLength){result[offset+holders[holdersIndex]]=args[argsIndex++];}}return result;}/**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */function copyArray(source,array){var index=-1,length=source.length;array||(array=Array(length));while(++index<length){array[index]=source[index];}return array;}/**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */function copyObject(source,props,object,customizer){var isNew=!object;object||(object={});var index=-1,length=props.length;while(++index<length){var key=props[index];var newValue=customizer?customizer(object[key],source[key],key,object,source):undefined$1;if(newValue===undefined$1){newValue=source[key];}if(isNew){baseAssignValue(object,key,newValue);}else {assignValue(object,key,newValue);}}return object;}/**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbols(source,object){return copyObject(source,getSymbols(source),object);}/**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */function copySymbolsIn(source,object){return copyObject(source,getSymbolsIn(source),object);}/**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */function createAggregator(setter,initializer){return function(collection,iteratee){var func=isArray(collection)?arrayAggregator:baseAggregator,accumulator=initializer?initializer():{};return func(collection,setter,getIteratee(iteratee,2),accumulator);};}/**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */function createAssigner(assigner){return baseRest(function(object,sources){var index=-1,length=sources.length,customizer=length>1?sources[length-1]:undefined$1,guard=length>2?sources[2]:undefined$1;customizer=assigner.length>3&&typeof customizer=='function'?(length--,customizer):undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){customizer=length<3?undefined$1:customizer;length=1;}object=Object(object);while(++index<length){var source=sources[index];if(source){assigner(object,source,index,customizer);}}return object;});}/**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseEach(eachFunc,fromRight){return function(collection,iteratee){if(collection==null){return collection;}if(!isArrayLike(collection)){return eachFunc(collection,iteratee);}var length=collection.length,index=fromRight?length:-1,iterable=Object(collection);while(fromRight?index--:++index<length){if(iteratee(iterable[index],index,iterable)===false){break;}}return collection;};}/**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */function createBaseFor(fromRight){return function(object,iteratee,keysFunc){var index=-1,iterable=Object(object),props=keysFunc(object),length=props.length;while(length--){var key=props[fromRight?length:++index];if(iteratee(iterable[key],key,iterable)===false){break;}}return object;};}/**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createBind(func,bitmask,thisArg){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return fn.apply(isBind?thisArg:this,arguments);}return wrapper;}/**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */function createCaseFirst(methodName){return function(string){string=toString(string);var strSymbols=hasUnicode(string)?stringToArray(string):undefined$1;var chr=strSymbols?strSymbols[0]:string.charAt(0);var trailing=strSymbols?castSlice(strSymbols,1).join(''):string.slice(1);return chr[methodName]()+trailing;};}/**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */function createCompounder(callback){return function(string){return arrayReduce(words(deburr(string).replace(reApos,'')),callback,'');};}/**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */function createCtor(Ctor){return function(){// Use a `switch` statement to work with class constructors. See
// http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
// for more details.
var args=arguments;switch(args.length){case 0:return new Ctor();case 1:return new Ctor(args[0]);case 2:return new Ctor(args[0],args[1]);case 3:return new Ctor(args[0],args[1],args[2]);case 4:return new Ctor(args[0],args[1],args[2],args[3]);case 5:return new Ctor(args[0],args[1],args[2],args[3],args[4]);case 6:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5]);case 7:return new Ctor(args[0],args[1],args[2],args[3],args[4],args[5],args[6]);}var thisBinding=baseCreate(Ctor.prototype),result=Ctor.apply(thisBinding,args);// Mimic the constructor's `return` behavior.
// See https://es5.github.io/#x13.2.2 for more details.
return isObject(result)?result:thisBinding;};}/**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createCurry(func,bitmask,arity){var Ctor=createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length,placeholder=getHolder(wrapper);while(index--){args[index]=arguments[index];}var holders=length<3&&args[0]!==placeholder&&args[length-1]!==placeholder?[]:replaceHolders(args,placeholder);length-=holders.length;if(length<arity){return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,undefined$1,args,holders,undefined$1,undefined$1,arity-length);}var fn=this&&this!==root&&this instanceof wrapper?Ctor:func;return apply(fn,this,args);}return wrapper;}/**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */function createFind(findIndexFunc){return function(collection,predicate,fromIndex){var iterable=Object(collection);if(!isArrayLike(collection)){var iteratee=getIteratee(predicate,3);collection=keys(collection);predicate=function(key){return iteratee(iterable[key],key,iterable);};}var index=findIndexFunc(collection,predicate,fromIndex);return index>-1?iterable[iteratee?collection[index]:index]:undefined$1;};}/**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */function createFlow(fromRight){return flatRest(function(funcs){var length=funcs.length,index=length,prereq=LodashWrapper.prototype.thru;if(fromRight){funcs.reverse();}while(index--){var func=funcs[index];if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(prereq&&!wrapper&&getFuncName(func)=='wrapper'){var wrapper=new LodashWrapper([],true);}}index=wrapper?index:length;while(++index<length){func=funcs[index];var funcName=getFuncName(func),data=funcName=='wrapper'?getData(func):undefined$1;if(data&&isLaziable(data[0])&&data[1]==(WRAP_ARY_FLAG|WRAP_CURRY_FLAG|WRAP_PARTIAL_FLAG|WRAP_REARG_FLAG)&&!data[4].length&&data[9]==1){wrapper=wrapper[getFuncName(data[0])].apply(wrapper,data[3]);}else {wrapper=func.length==1&&isLaziable(func)?wrapper[funcName]():wrapper.thru(func);}}return function(){var args=arguments,value=args[0];if(wrapper&&args.length==1&&isArray(value)){return wrapper.plant(value).value();}var index=0,result=length?funcs[index].apply(this,args):value;while(++index<length){result=funcs[index].call(this,result);}return result;};});}/**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createHybrid(func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity){var isAry=bitmask&WRAP_ARY_FLAG,isBind=bitmask&WRAP_BIND_FLAG,isBindKey=bitmask&WRAP_BIND_KEY_FLAG,isCurried=bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG),isFlip=bitmask&WRAP_FLIP_FLAG,Ctor=isBindKey?undefined$1:createCtor(func);function wrapper(){var length=arguments.length,args=Array(length),index=length;while(index--){args[index]=arguments[index];}if(isCurried){var placeholder=getHolder(wrapper),holdersCount=countHolders(args,placeholder);}if(partials){args=composeArgs(args,partials,holders,isCurried);}if(partialsRight){args=composeArgsRight(args,partialsRight,holdersRight,isCurried);}length-=holdersCount;if(isCurried&&length<arity){var newHolders=replaceHolders(args,placeholder);return createRecurry(func,bitmask,createHybrid,wrapper.placeholder,thisArg,args,newHolders,argPos,ary,arity-length);}var thisBinding=isBind?thisArg:this,fn=isBindKey?thisBinding[func]:func;length=args.length;if(argPos){args=reorder(args,argPos);}else if(isFlip&&length>1){args.reverse();}if(isAry&&ary<length){args.length=ary;}if(this&&this!==root&&this instanceof wrapper){fn=Ctor||createCtor(fn);}return fn.apply(thisBinding,args);}return wrapper;}/**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */function createInverter(setter,toIteratee){return function(object,iteratee){return baseInverter(object,setter,toIteratee(iteratee),{});};}/**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */function createMathOperation(operator,defaultValue){return function(value,other){var result;if(value===undefined$1&&other===undefined$1){return defaultValue;}if(value!==undefined$1){result=value;}if(other!==undefined$1){if(result===undefined$1){return other;}if(typeof value=='string'||typeof other=='string'){value=baseToString(value);other=baseToString(other);}else {value=baseToNumber(value);other=baseToNumber(other);}result=operator(value,other);}return result;};}/**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */function createOver(arrayFunc){return flatRest(function(iteratees){iteratees=arrayMap(iteratees,baseUnary(getIteratee()));return baseRest(function(args){var thisArg=this;return arrayFunc(iteratees,function(iteratee){return apply(iteratee,thisArg,args);});});});}/**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */function createPadding(length,chars){chars=chars===undefined$1?' ':baseToString(chars);var charsLength=chars.length;if(charsLength<2){return charsLength?baseRepeat(chars,length):chars;}var result=baseRepeat(chars,nativeCeil(length/stringSize(chars)));return hasUnicode(chars)?castSlice(stringToArray(result),0,length).join(''):result.slice(0,length);}/**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */function createPartial(func,bitmask,thisArg,partials){var isBind=bitmask&WRAP_BIND_FLAG,Ctor=createCtor(func);function wrapper(){var argsIndex=-1,argsLength=arguments.length,leftIndex=-1,leftLength=partials.length,args=Array(leftLength+argsLength),fn=this&&this!==root&&this instanceof wrapper?Ctor:func;while(++leftIndex<leftLength){args[leftIndex]=partials[leftIndex];}while(argsLength--){args[leftIndex++]=arguments[++argsIndex];}return apply(fn,isBind?thisArg:this,args);}return wrapper;}/**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */function createRange(fromRight){return function(start,end,step){if(step&&typeof step!='number'&&isIterateeCall(start,end,step)){end=step=undefined$1;}// Ensure the sign of `-0` is preserved.
start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}step=step===undefined$1?start<end?1:-1:toFinite(step);return baseRange(start,end,step,fromRight);};}/**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */function createRelationalOperation(operator){return function(value,other){if(!(typeof value=='string'&&typeof other=='string')){value=toNumber(value);other=toNumber(other);}return operator(value,other);};}/**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createRecurry(func,bitmask,wrapFunc,placeholder,thisArg,partials,holders,argPos,ary,arity){var isCurry=bitmask&WRAP_CURRY_FLAG,newHolders=isCurry?holders:undefined$1,newHoldersRight=isCurry?undefined$1:holders,newPartials=isCurry?partials:undefined$1,newPartialsRight=isCurry?undefined$1:partials;bitmask|=isCurry?WRAP_PARTIAL_FLAG:WRAP_PARTIAL_RIGHT_FLAG;bitmask&=~(isCurry?WRAP_PARTIAL_RIGHT_FLAG:WRAP_PARTIAL_FLAG);if(!(bitmask&WRAP_CURRY_BOUND_FLAG)){bitmask&=~(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG);}var newData=[func,bitmask,thisArg,newPartials,newHolders,newPartialsRight,newHoldersRight,argPos,ary,arity];var result=wrapFunc.apply(undefined$1,newData);if(isLaziable(func)){setData(result,newData);}result.placeholder=placeholder;return setWrapToString(result,func,bitmask);}/**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */function createRound(methodName){var func=Math[methodName];return function(number,precision){number=toNumber(number);precision=precision==null?0:nativeMin(toInteger(precision),292);if(precision&&nativeIsFinite(number)){// Shift with exponential notation to avoid floating-point issues.
// See [MDN](https://mdn.io/round#Examples) for more details.
var pair=(toString(number)+'e').split('e'),value=func(pair[0]+'e'+(+pair[1]+precision));pair=(toString(value)+'e').split('e');return +(pair[0]+'e'+(+pair[1]-precision));}return func(number);};}/**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */var createSet=!(Set&&1/setToArray(new Set([,-0]))[1]==INFINITY)?noop:function(values){return new Set(values);};/**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */function createToPairs(keysFunc){return function(object){var tag=getTag(object);if(tag==mapTag){return mapToArray(object);}if(tag==setTag){return setToPairs(object);}return baseToPairs(object,keysFunc(object));};}/**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */function createWrap(func,bitmask,thisArg,partials,holders,argPos,ary,arity){var isBindKey=bitmask&WRAP_BIND_KEY_FLAG;if(!isBindKey&&typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var length=partials?partials.length:0;if(!length){bitmask&=~(WRAP_PARTIAL_FLAG|WRAP_PARTIAL_RIGHT_FLAG);partials=holders=undefined$1;}ary=ary===undefined$1?ary:nativeMax(toInteger(ary),0);arity=arity===undefined$1?arity:toInteger(arity);length-=holders?holders.length:0;if(bitmask&WRAP_PARTIAL_RIGHT_FLAG){var partialsRight=partials,holdersRight=holders;partials=holders=undefined$1;}var data=isBindKey?undefined$1:getData(func);var newData=[func,bitmask,thisArg,partials,holders,partialsRight,holdersRight,argPos,ary,arity];if(data){mergeData(newData,data);}func=newData[0];bitmask=newData[1];thisArg=newData[2];partials=newData[3];holders=newData[4];arity=newData[9]=newData[9]===undefined$1?isBindKey?0:func.length:nativeMax(newData[9]-length,0);if(!arity&&bitmask&(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG)){bitmask&=~(WRAP_CURRY_FLAG|WRAP_CURRY_RIGHT_FLAG);}if(!bitmask||bitmask==WRAP_BIND_FLAG){var result=createBind(func,bitmask,thisArg);}else if(bitmask==WRAP_CURRY_FLAG||bitmask==WRAP_CURRY_RIGHT_FLAG){result=createCurry(func,bitmask,arity);}else if((bitmask==WRAP_PARTIAL_FLAG||bitmask==(WRAP_BIND_FLAG|WRAP_PARTIAL_FLAG))&&!holders.length){result=createPartial(func,bitmask,thisArg,partials);}else {result=createHybrid.apply(undefined$1,newData);}var setter=data?baseSetData:setData;return setWrapToString(setter(result,newData),func,bitmask);}/**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */function customDefaultsAssignIn(objValue,srcValue,key,object){if(objValue===undefined$1||eq(objValue,objectProto[key])&&!hasOwnProperty.call(object,key)){return srcValue;}return objValue;}/**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */function customDefaultsMerge(objValue,srcValue,key,object,source,stack){if(isObject(objValue)&&isObject(srcValue)){// Recursively merge objects and arrays (susceptible to call stack limits).
stack.set(srcValue,objValue);baseMerge(objValue,srcValue,undefined$1,customDefaultsMerge,stack);stack['delete'](srcValue);}return objValue;}/**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */function customOmitClone(value){return isPlainObject(value)?undefined$1:value;}/**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */function equalArrays(array,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,arrLength=array.length,othLength=other.length;if(arrLength!=othLength&&!(isPartial&&othLength>arrLength)){return false;}// Check that cyclic values are equal.
var arrStacked=stack.get(array);var othStacked=stack.get(other);if(arrStacked&&othStacked){return arrStacked==other&&othStacked==array;}var index=-1,result=true,seen=bitmask&COMPARE_UNORDERED_FLAG?new SetCache():undefined$1;stack.set(array,other);stack.set(other,array);// Ignore non-index properties.
while(++index<arrLength){var arrValue=array[index],othValue=other[index];if(customizer){var compared=isPartial?customizer(othValue,arrValue,index,other,array,stack):customizer(arrValue,othValue,index,array,other,stack);}if(compared!==undefined$1){if(compared){continue;}result=false;break;}// Recursively compare arrays (susceptible to call stack limits).
if(seen){if(!arraySome(other,function(othValue,othIndex){if(!cacheHas(seen,othIndex)&&(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){return seen.push(othIndex);}})){result=false;break;}}else if(!(arrValue===othValue||equalFunc(arrValue,othValue,bitmask,customizer,stack))){result=false;break;}}stack['delete'](array);stack['delete'](other);return result;}/**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalByTag(object,other,tag,bitmask,customizer,equalFunc,stack){switch(tag){case dataViewTag:if(object.byteLength!=other.byteLength||object.byteOffset!=other.byteOffset){return false;}object=object.buffer;other=other.buffer;case arrayBufferTag:if(object.byteLength!=other.byteLength||!equalFunc(new Uint8Array(object),new Uint8Array(other))){return false;}return true;case boolTag:case dateTag:case numberTag:// Coerce booleans to `1` or `0` and dates to milliseconds.
// Invalid dates are coerced to `NaN`.
return eq(+object,+other);case errorTag:return object.name==other.name&&object.message==other.message;case regexpTag:case stringTag:// Coerce regexes to strings and treat strings, primitives and objects,
// as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
// for more details.
return object==other+'';case mapTag:var convert=mapToArray;case setTag:var isPartial=bitmask&COMPARE_PARTIAL_FLAG;convert||(convert=setToArray);if(object.size!=other.size&&!isPartial){return false;}// Assume cyclic values are equal.
var stacked=stack.get(object);if(stacked){return stacked==other;}bitmask|=COMPARE_UNORDERED_FLAG;// Recursively compare objects (susceptible to call stack limits).
stack.set(object,other);var result=equalArrays(convert(object),convert(other),bitmask,customizer,equalFunc,stack);stack['delete'](object);return result;case symbolTag:if(symbolValueOf){return symbolValueOf.call(object)==symbolValueOf.call(other);}}return false;}/**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */function equalObjects(object,other,bitmask,customizer,equalFunc,stack){var isPartial=bitmask&COMPARE_PARTIAL_FLAG,objProps=getAllKeys(object),objLength=objProps.length,othProps=getAllKeys(other),othLength=othProps.length;if(objLength!=othLength&&!isPartial){return false;}var index=objLength;while(index--){var key=objProps[index];if(!(isPartial?key in other:hasOwnProperty.call(other,key))){return false;}}// Check that cyclic values are equal.
var objStacked=stack.get(object);var othStacked=stack.get(other);if(objStacked&&othStacked){return objStacked==other&&othStacked==object;}var result=true;stack.set(object,other);stack.set(other,object);var skipCtor=isPartial;while(++index<objLength){key=objProps[index];var objValue=object[key],othValue=other[key];if(customizer){var compared=isPartial?customizer(othValue,objValue,key,other,object,stack):customizer(objValue,othValue,key,object,other,stack);}// Recursively compare objects (susceptible to call stack limits).
if(!(compared===undefined$1?objValue===othValue||equalFunc(objValue,othValue,bitmask,customizer,stack):compared)){result=false;break;}skipCtor||(skipCtor=key=='constructor');}if(result&&!skipCtor){var objCtor=object.constructor,othCtor=other.constructor;// Non `Object` object instances with different constructors are not equal.
if(objCtor!=othCtor&&'constructor'in object&&'constructor'in other&&!(typeof objCtor=='function'&&objCtor instanceof objCtor&&typeof othCtor=='function'&&othCtor instanceof othCtor)){result=false;}}stack['delete'](object);stack['delete'](other);return result;}/**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */function flatRest(func){return setToString(overRest(func,undefined$1,flatten),func+'');}/**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeys(object){return baseGetAllKeys(object,keys,getSymbols);}/**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */function getAllKeysIn(object){return baseGetAllKeys(object,keysIn,getSymbolsIn);}/**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */var getData=!metaMap?noop:function(func){return metaMap.get(func);};/**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */function getFuncName(func){var result=func.name+'',array=realNames[result],length=hasOwnProperty.call(realNames,result)?array.length:0;while(length--){var data=array[length],otherFunc=data.func;if(otherFunc==null||otherFunc==func){return data.name;}}return result;}/**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */function getHolder(func){var object=hasOwnProperty.call(lodash,'placeholder')?lodash:func;return object.placeholder;}/**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */function getIteratee(){var result=lodash.iteratee||iteratee;result=result===iteratee?baseIteratee:result;return arguments.length?result(arguments[0],arguments[1]):result;}/**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */function getMapData(map,key){var data=map.__data__;return isKeyable(key)?data[typeof key=='string'?'string':'hash']:data.map;}/**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */function getMatchData(object){var result=keys(object),length=result.length;while(length--){var key=result[length],value=object[key];result[length]=[key,value,isStrictComparable(value)];}return result;}/**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */function getNative(object,key){var value=getValue(object,key);return baseIsNative(value)?value:undefined$1;}/**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */function getRawTag(value){var isOwn=hasOwnProperty.call(value,symToStringTag),tag=value[symToStringTag];try{value[symToStringTag]=undefined$1;var unmasked=true;}catch(e){}var result=nativeObjectToString.call(value);if(unmasked){if(isOwn){value[symToStringTag]=tag;}else {delete value[symToStringTag];}}return result;}/**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbols=!nativeGetSymbols?stubArray:function(object){if(object==null){return [];}object=Object(object);return arrayFilter(nativeGetSymbols(object),function(symbol){return propertyIsEnumerable.call(object,symbol);});};/**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */var getSymbolsIn=!nativeGetSymbols?stubArray:function(object){var result=[];while(object){arrayPush(result,getSymbols(object));object=getPrototype(object);}return result;};/**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */var getTag=baseGetTag;// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if(DataView&&getTag(new DataView(new ArrayBuffer(1)))!=dataViewTag||Map&&getTag(new Map())!=mapTag||Promise&&getTag(Promise.resolve())!=promiseTag||Set&&getTag(new Set())!=setTag||WeakMap&&getTag(new WeakMap())!=weakMapTag){getTag=function(value){var result=baseGetTag(value),Ctor=result==objectTag?value.constructor:undefined$1,ctorString=Ctor?toSource(Ctor):'';if(ctorString){switch(ctorString){case dataViewCtorString:return dataViewTag;case mapCtorString:return mapTag;case promiseCtorString:return promiseTag;case setCtorString:return setTag;case weakMapCtorString:return weakMapTag;}}return result;};}/**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */function getView(start,end,transforms){var index=-1,length=transforms.length;while(++index<length){var data=transforms[index],size=data.size;switch(data.type){case'drop':start+=size;break;case'dropRight':end-=size;break;case'take':end=nativeMin(end,start+size);break;case'takeRight':start=nativeMax(start,end-size);break;}}return {'start':start,'end':end};}/**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */function getWrapDetails(source){var match=source.match(reWrapDetails);return match?match[1].split(reSplitDetails):[];}/**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */function hasPath(object,path,hasFunc){path=castPath(path,object);var index=-1,length=path.length,result=false;while(++index<length){var key=toKey(path[index]);if(!(result=object!=null&&hasFunc(object,key))){break;}object=object[key];}if(result||++index!=length){return result;}length=object==null?0:object.length;return !!length&&isLength(length)&&isIndex(key,length)&&(isArray(object)||isArguments(object));}/**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */function initCloneArray(array){var length=array.length,result=new array.constructor(length);// Add properties assigned by `RegExp#exec`.
if(length&&typeof array[0]=='string'&&hasOwnProperty.call(array,'index')){result.index=array.index;result.input=array.input;}return result;}/**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneObject(object){return typeof object.constructor=='function'&&!isPrototype(object)?baseCreate(getPrototype(object)):{};}/**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */function initCloneByTag(object,tag,isDeep){var Ctor=object.constructor;switch(tag){case arrayBufferTag:return cloneArrayBuffer(object);case boolTag:case dateTag:return new Ctor(+object);case dataViewTag:return cloneDataView(object,isDeep);case float32Tag:case float64Tag:case int8Tag:case int16Tag:case int32Tag:case uint8Tag:case uint8ClampedTag:case uint16Tag:case uint32Tag:return cloneTypedArray(object,isDeep);case mapTag:return new Ctor();case numberTag:case stringTag:return new Ctor(object);case regexpTag:return cloneRegExp(object);case setTag:return new Ctor();case symbolTag:return cloneSymbol(object);}}/**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */function insertWrapDetails(source,details){var length=details.length;if(!length){return source;}var lastIndex=length-1;details[lastIndex]=(length>1?'& ':'')+details[lastIndex];details=details.join(length>2?', ':' ');return source.replace(reWrapComment,'{\n/* [wrapped with '+details+'] */\n');}/**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */function isFlattenable(value){return isArray(value)||isArguments(value)||!!(spreadableSymbol&&value&&value[spreadableSymbol]);}/**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */function isIndex(value,length){var type=typeof value;length=length==null?MAX_SAFE_INTEGER:length;return !!length&&(type=='number'||type!='symbol'&&reIsUint.test(value))&&value>-1&&value%1==0&&value<length;}/**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */function isIterateeCall(value,index,object){if(!isObject(object)){return false;}var type=typeof index;if(type=='number'?isArrayLike(object)&&isIndex(index,object.length):type=='string'&&index in object){return eq(object[index],value);}return false;}/**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */function isKey(value,object){if(isArray(value)){return false;}var type=typeof value;if(type=='number'||type=='symbol'||type=='boolean'||value==null||isSymbol(value)){return true;}return reIsPlainProp.test(value)||!reIsDeepProp.test(value)||object!=null&&value in Object(object);}/**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */function isKeyable(value){var type=typeof value;return type=='string'||type=='number'||type=='symbol'||type=='boolean'?value!=='__proto__':value===null;}/**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */function isLaziable(func){var funcName=getFuncName(func),other=lodash[funcName];if(typeof other!='function'||!(funcName in LazyWrapper.prototype)){return false;}if(func===other){return true;}var data=getData(other);return !!data&&func===data[0];}/**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */function isMasked(func){return !!maskSrcKey&&maskSrcKey in func;}/**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */var isMaskable=coreJsData?isFunction:stubFalse;/**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */function isPrototype(value){var Ctor=value&&value.constructor,proto=typeof Ctor=='function'&&Ctor.prototype||objectProto;return value===proto;}/**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */function isStrictComparable(value){return value===value&&!isObject(value);}/**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */function matchesStrictComparable(key,srcValue){return function(object){if(object==null){return false;}return object[key]===srcValue&&(srcValue!==undefined$1||key in Object(object));};}/**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */function memoizeCapped(func){var result=memoize(func,function(key){if(cache.size===MAX_MEMOIZE_SIZE){cache.clear();}return key;});var cache=result.cache;return result;}/**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */function mergeData(data,source){var bitmask=data[1],srcBitmask=source[1],newBitmask=bitmask|srcBitmask,isCommon=newBitmask<(WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG|WRAP_ARY_FLAG);var isCombo=srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_CURRY_FLAG||srcBitmask==WRAP_ARY_FLAG&&bitmask==WRAP_REARG_FLAG&&data[7].length<=source[8]||srcBitmask==(WRAP_ARY_FLAG|WRAP_REARG_FLAG)&&source[7].length<=source[8]&&bitmask==WRAP_CURRY_FLAG;// Exit early if metadata can't be merged.
if(!(isCommon||isCombo)){return data;}// Use source `thisArg` if available.
if(srcBitmask&WRAP_BIND_FLAG){data[2]=source[2];// Set when currying a bound function.
newBitmask|=bitmask&WRAP_BIND_FLAG?0:WRAP_CURRY_BOUND_FLAG;}// Compose partial arguments.
var value=source[3];if(value){var partials=data[3];data[3]=partials?composeArgs(partials,value,source[4]):value;data[4]=partials?replaceHolders(data[3],PLACEHOLDER):source[4];}// Compose partial right arguments.
value=source[5];if(value){partials=data[5];data[5]=partials?composeArgsRight(partials,value,source[6]):value;data[6]=partials?replaceHolders(data[5],PLACEHOLDER):source[6];}// Use source `argPos` if available.
value=source[7];if(value){data[7]=value;}// Use source `ary` if it's smaller.
if(srcBitmask&WRAP_ARY_FLAG){data[8]=data[8]==null?source[8]:nativeMin(data[8],source[8]);}// Use source `arity` if one is not provided.
if(data[9]==null){data[9]=source[9];}// Use source `func` and merge bitmasks.
data[0]=source[0];data[1]=newBitmask;return data;}/**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */function nativeKeysIn(object){var result=[];if(object!=null){for(var key in Object(object)){result.push(key);}}return result;}/**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */function objectToString(value){return nativeObjectToString.call(value);}/**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */function overRest(func,start,transform){start=nativeMax(start===undefined$1?func.length-1:start,0);return function(){var args=arguments,index=-1,length=nativeMax(args.length-start,0),array=Array(length);while(++index<length){array[index]=args[start+index];}index=-1;var otherArgs=Array(start+1);while(++index<start){otherArgs[index]=args[index];}otherArgs[start]=transform(array);return apply(func,this,otherArgs);};}/**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */function parent(object,path){return path.length<2?object:baseGet(object,baseSlice(path,0,-1));}/**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */function reorder(array,indexes){var arrLength=array.length,length=nativeMin(indexes.length,arrLength),oldArray=copyArray(array);while(length--){var index=indexes[length];array[length]=isIndex(index,arrLength)?oldArray[index]:undefined$1;}return array;}/**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */function safeGet(object,key){if(key==='constructor'&&typeof object[key]==='function'){return;}if(key=='__proto__'){return;}return object[key];}/**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */var setData=shortOut(baseSetData);/**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */var setTimeout=ctxSetTimeout||function(func,wait){return root.setTimeout(func,wait);};/**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */var setToString=shortOut(baseSetToString);/**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */function setWrapToString(wrapper,reference,bitmask){var source=reference+'';return setToString(wrapper,insertWrapDetails(source,updateWrapDetails(getWrapDetails(source),bitmask)));}/**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */function shortOut(func){var count=0,lastCalled=0;return function(){var stamp=nativeNow(),remaining=HOT_SPAN-(stamp-lastCalled);lastCalled=stamp;if(remaining>0){if(++count>=HOT_COUNT){return arguments[0];}}else {count=0;}return func.apply(undefined$1,arguments);};}/**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */function shuffleSelf(array,size){var index=-1,length=array.length,lastIndex=length-1;size=size===undefined$1?length:size;while(++index<size){var rand=baseRandom(index,lastIndex),value=array[rand];array[rand]=array[index];array[index]=value;}array.length=size;return array;}/**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */var stringToPath=memoizeCapped(function(string){var result=[];if(string.charCodeAt(0)===46/* . */){result.push('');}string.replace(rePropName,function(match,number,quote,subString){result.push(quote?subString.replace(reEscapeChar,'$1'):number||match);});return result;});/**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */function toKey(value){if(typeof value=='string'||isSymbol(value)){return value;}var result=value+'';return result=='0'&&1/value==-INFINITY?'-0':result;}/**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */function toSource(func){if(func!=null){try{return funcToString.call(func);}catch(e){}try{return func+'';}catch(e){}}return '';}/**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */function updateWrapDetails(details,bitmask){arrayEach(wrapFlags,function(pair){var value='_.'+pair[0];if(bitmask&pair[1]&&!arrayIncludes(details,value)){details.push(value);}});return details.sort();}/**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */function wrapperClone(wrapper){if(wrapper instanceof LazyWrapper){return wrapper.clone();}var result=new LodashWrapper(wrapper.__wrapped__,wrapper.__chain__);result.__actions__=copyArray(wrapper.__actions__);result.__index__=wrapper.__index__;result.__values__=wrapper.__values__;return result;}/*------------------------------------------------------------------------*/ /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */function chunk(array,size,guard){if(guard?isIterateeCall(array,size,guard):size===undefined$1){size=1;}else {size=nativeMax(toInteger(size),0);}var length=array==null?0:array.length;if(!length||size<1){return [];}var index=0,resIndex=0,result=Array(nativeCeil(length/size));while(index<length){result[resIndex++]=baseSlice(array,index,index+=size);}return result;}/**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */function compact(array){var index=-1,length=array==null?0:array.length,resIndex=0,result=[];while(++index<length){var value=array[index];if(value){result[resIndex++]=value;}}return result;}/**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */function concat(){var length=arguments.length;if(!length){return [];}var args=Array(length-1),array=arguments[0],index=length;while(index--){args[index-1]=arguments[index];}return arrayPush(isArray(array)?copyArray(array):[array],baseFlatten(args,1));}/**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */var difference=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true)):[];});/**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var differenceBy=baseRest(function(array,values){var iteratee=last(values);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),getIteratee(iteratee,2)):[];});/**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */var differenceWith=baseRest(function(array,values){var comparator=last(values);if(isArrayLikeObject(comparator)){comparator=undefined$1;}return isArrayLikeObject(array)?baseDifference(array,baseFlatten(values,1,isArrayLikeObject,true),undefined$1,comparator):[];});/**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function drop(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */function dropRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true,true):[];}/**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */function dropWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),true):[];}/**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */function fill(array,value,start,end){var length=array==null?0:array.length;if(!length){return [];}if(start&&typeof start!='number'&&isIterateeCall(array,value,start)){start=0;end=length;}return baseFill(array,value,start,end);}/**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */function findIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseFindIndex(array,getIteratee(predicate,3),index);}/**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */function findLastIndex(array,predicate,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length-1;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=fromIndex<0?nativeMax(length+index,0):nativeMin(index,length-1);}return baseFindIndex(array,getIteratee(predicate,3),index,true);}/**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */function flatten(array){var length=array==null?0:array.length;return length?baseFlatten(array,1):[];}/**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */function flattenDeep(array){var length=array==null?0:array.length;return length?baseFlatten(array,INFINITY):[];}/**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */function flattenDepth(array,depth){var length=array==null?0:array.length;if(!length){return [];}depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(array,depth);}/**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */function fromPairs(pairs){var index=-1,length=pairs==null?0:pairs.length,result={};while(++index<length){var pair=pairs[index];result[pair[0]]=pair[1];}return result;}/**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */function head(array){return array&&array.length?array[0]:undefined$1;}/**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */function indexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=fromIndex==null?0:toInteger(fromIndex);if(index<0){index=nativeMax(length+index,0);}return baseIndexOf(array,value,index);}/**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */function initial(array){var length=array==null?0:array.length;return length?baseSlice(array,0,-1):[];}/**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */var intersection=baseRest(function(arrays){var mapped=arrayMap(arrays,castArrayLikeObject);return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped):[];});/**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */var intersectionBy=baseRest(function(arrays){var iteratee=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);if(iteratee===last(mapped)){iteratee=undefined$1;}else {mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,getIteratee(iteratee,2)):[];});/**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */var intersectionWith=baseRest(function(arrays){var comparator=last(arrays),mapped=arrayMap(arrays,castArrayLikeObject);comparator=typeof comparator=='function'?comparator:undefined$1;if(comparator){mapped.pop();}return mapped.length&&mapped[0]===arrays[0]?baseIntersection(mapped,undefined$1,comparator):[];});/**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */function join(array,separator){return array==null?'':nativeJoin.call(array,separator);}/**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */function last(array){var length=array==null?0:array.length;return length?array[length-1]:undefined$1;}/**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */function lastIndexOf(array,value,fromIndex){var length=array==null?0:array.length;if(!length){return -1;}var index=length;if(fromIndex!==undefined$1){index=toInteger(fromIndex);index=index<0?nativeMax(length+index,0):nativeMin(index,length-1);}return value===value?strictLastIndexOf(array,value,index):baseFindIndex(array,baseIsNaN,index,true);}/**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */function nth(array,n){return array&&array.length?baseNth(array,toInteger(n)):undefined$1;}/**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */var pull=baseRest(pullAll);/**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */function pullAll(array,values){return array&&array.length&&values&&values.length?basePullAll(array,values):array;}/**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */function pullAllBy(array,values,iteratee){return array&&array.length&&values&&values.length?basePullAll(array,values,getIteratee(iteratee,2)):array;}/**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */function pullAllWith(array,values,comparator){return array&&array.length&&values&&values.length?basePullAll(array,values,undefined$1,comparator):array;}/**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */var pullAt=flatRest(function(array,indexes){var length=array==null?0:array.length,result=baseAt(array,indexes);basePullAt(array,arrayMap(indexes,function(index){return isIndex(index,length)?+index:index;}).sort(compareAscending));return result;});/**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */function remove(array,predicate){var result=[];if(!(array&&array.length)){return result;}var index=-1,indexes=[],length=array.length;predicate=getIteratee(predicate,3);while(++index<length){var value=array[index];if(predicate(value,index,array)){result.push(value);indexes.push(index);}}basePullAt(array,indexes);return result;}/**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function reverse(array){return array==null?array:nativeReverse.call(array);}/**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */function slice(array,start,end){var length=array==null?0:array.length;if(!length){return [];}if(end&&typeof end!='number'&&isIterateeCall(array,start,end)){start=0;end=length;}else {start=start==null?0:toInteger(start);end=end===undefined$1?length:toInteger(end);}return baseSlice(array,start,end);}/**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */function sortedIndex(array,value){return baseSortedIndex(array,value);}/**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */function sortedIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2));}/**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */function sortedIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value);if(index<length&&eq(array[index],value)){return index;}}return -1;}/**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */function sortedLastIndex(array,value){return baseSortedIndex(array,value,true);}/**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */function sortedLastIndexBy(array,value,iteratee){return baseSortedIndexBy(array,value,getIteratee(iteratee,2),true);}/**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */function sortedLastIndexOf(array,value){var length=array==null?0:array.length;if(length){var index=baseSortedIndex(array,value,true)-1;if(eq(array[index],value)){return index;}}return -1;}/**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */function sortedUniq(array){return array&&array.length?baseSortedUniq(array):[];}/**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */function sortedUniqBy(array,iteratee){return array&&array.length?baseSortedUniq(array,getIteratee(iteratee,2)):[];}/**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */function tail(array){var length=array==null?0:array.length;return length?baseSlice(array,1,length):[];}/**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */function take(array,n,guard){if(!(array&&array.length)){return [];}n=guard||n===undefined$1?1:toInteger(n);return baseSlice(array,0,n<0?0:n);}/**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */function takeRight(array,n,guard){var length=array==null?0:array.length;if(!length){return [];}n=guard||n===undefined$1?1:toInteger(n);n=length-n;return baseSlice(array,n<0?0:n,length);}/**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */function takeRightWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3),false,true):[];}/**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */function takeWhile(array,predicate){return array&&array.length?baseWhile(array,getIteratee(predicate,3)):[];}/**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */var union=baseRest(function(arrays){return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true));});/**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */var unionBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),getIteratee(iteratee,2));});/**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var unionWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseUniq(baseFlatten(arrays,1,isArrayLikeObject,true),undefined$1,comparator);});/**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */function uniq(array){return array&&array.length?baseUniq(array):[];}/**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */function uniqBy(array,iteratee){return array&&array.length?baseUniq(array,getIteratee(iteratee,2)):[];}/**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */function uniqWith(array,comparator){comparator=typeof comparator=='function'?comparator:undefined$1;return array&&array.length?baseUniq(array,undefined$1,comparator):[];}/**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */function unzip(array){if(!(array&&array.length)){return [];}var length=0;array=arrayFilter(array,function(group){if(isArrayLikeObject(group)){length=nativeMax(group.length,length);return true;}});return baseTimes(length,function(index){return arrayMap(array,baseProperty(index));});}/**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */function unzipWith(array,iteratee){if(!(array&&array.length)){return [];}var result=unzip(array);if(iteratee==null){return result;}return arrayMap(result,function(group){return apply(iteratee,undefined$1,group);});}/**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */var without=baseRest(function(array,values){return isArrayLikeObject(array)?baseDifference(array,values):[];});/**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */var xor=baseRest(function(arrays){return baseXor(arrayFilter(arrays,isArrayLikeObject));});/**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */var xorBy=baseRest(function(arrays){var iteratee=last(arrays);if(isArrayLikeObject(iteratee)){iteratee=undefined$1;}return baseXor(arrayFilter(arrays,isArrayLikeObject),getIteratee(iteratee,2));});/**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */var xorWith=baseRest(function(arrays){var comparator=last(arrays);comparator=typeof comparator=='function'?comparator:undefined$1;return baseXor(arrayFilter(arrays,isArrayLikeObject),undefined$1,comparator);});/**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */var zip=baseRest(unzip);/**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */function zipObject(props,values){return baseZipObject(props||[],values||[],assignValue);}/**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */function zipObjectDeep(props,values){return baseZipObject(props||[],values||[],baseSet);}/**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */var zipWith=baseRest(function(arrays){var length=arrays.length,iteratee=length>1?arrays[length-1]:undefined$1;iteratee=typeof iteratee=='function'?(arrays.pop(),iteratee):undefined$1;return unzipWith(arrays,iteratee);});/*------------------------------------------------------------------------*/ /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */function chain(value){var result=lodash(value);result.__chain__=true;return result;}/**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */function tap(value,interceptor){interceptor(value);return value;}/**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */function thru(value,interceptor){return interceptor(value);}/**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */var wrapperAt=flatRest(function(paths){var length=paths.length,start=length?paths[0]:0,value=this.__wrapped__,interceptor=function(object){return baseAt(object,paths);};if(length>1||this.__actions__.length||!(value instanceof LazyWrapper)||!isIndex(start)){return this.thru(interceptor);}value=value.slice(start,+start+(length?1:0));value.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(value,this.__chain__).thru(function(array){if(length&&!array.length){array.push(undefined$1);}return array;});});/**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */function wrapperChain(){return chain(this);}/**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */function wrapperCommit(){return new LodashWrapper(this.value(),this.__chain__);}/**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */function wrapperNext(){if(this.__values__===undefined$1){this.__values__=toArray(this.value());}var done=this.__index__>=this.__values__.length,value=done?undefined$1:this.__values__[this.__index__++];return {'done':done,'value':value};}/**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */function wrapperToIterator(){return this;}/**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */function wrapperPlant(value){var result,parent=this;while(parent instanceof baseLodash){var clone=wrapperClone(parent);clone.__index__=0;clone.__values__=undefined$1;if(result){previous.__wrapped__=clone;}else {result=clone;}var previous=clone;parent=parent.__wrapped__;}previous.__wrapped__=value;return result;}/**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */function wrapperReverse(){var value=this.__wrapped__;if(value instanceof LazyWrapper){var wrapped=value;if(this.__actions__.length){wrapped=new LazyWrapper(this);}wrapped=wrapped.reverse();wrapped.__actions__.push({'func':thru,'args':[reverse],'thisArg':undefined$1});return new LodashWrapper(wrapped,this.__chain__);}return this.thru(reverse);}/**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */function wrapperValue(){return baseWrapperValue(this.__wrapped__,this.__actions__);}/*------------------------------------------------------------------------*/ /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */var countBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){++result[key];}else {baseAssignValue(result,key,1);}});/**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */function every(collection,predicate,guard){var func=isArray(collection)?arrayEvery:baseEvery;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */function filter(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,getIteratee(predicate,3));}/**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */var find=createFind(findIndex);/**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */var findLast=createFind(findLastIndex);/**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMap(collection,iteratee){return baseFlatten(map(collection,iteratee),1);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */function flatMapDeep(collection,iteratee){return baseFlatten(map(collection,iteratee),INFINITY);}/**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */function flatMapDepth(collection,iteratee,depth){depth=depth===undefined$1?1:toInteger(depth);return baseFlatten(map(collection,iteratee),depth);}/**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forEach(collection,iteratee){var func=isArray(collection)?arrayEach:baseEach;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */function forEachRight(collection,iteratee){var func=isArray(collection)?arrayEachRight:baseEachRight;return func(collection,getIteratee(iteratee,3));}/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */var groupBy=createAggregator(function(result,value,key){if(hasOwnProperty.call(result,key)){result[key].push(value);}else {baseAssignValue(result,key,[value]);}});/**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */function includes(collection,value,fromIndex,guard){collection=isArrayLike(collection)?collection:values(collection);fromIndex=fromIndex&&!guard?toInteger(fromIndex):0;var length=collection.length;if(fromIndex<0){fromIndex=nativeMax(length+fromIndex,0);}return isString(collection)?fromIndex<=length&&collection.indexOf(value,fromIndex)>-1:!!length&&baseIndexOf(collection,value,fromIndex)>-1;}/**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */var invokeMap=baseRest(function(collection,path,args){var index=-1,isFunc=typeof path=='function',result=isArrayLike(collection)?Array(collection.length):[];baseEach(collection,function(value){result[++index]=isFunc?apply(path,value,args):baseInvoke(value,path,args);});return result;});/**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */var keyBy=createAggregator(function(result,value,key){baseAssignValue(result,key,value);});/**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */function map(collection,iteratee){var func=isArray(collection)?arrayMap:baseMap;return func(collection,getIteratee(iteratee,3));}/**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */function orderBy(collection,iteratees,orders,guard){if(collection==null){return [];}if(!isArray(iteratees)){iteratees=iteratees==null?[]:[iteratees];}orders=guard?undefined$1:orders;if(!isArray(orders)){orders=orders==null?[]:[orders];}return baseOrderBy(collection,iteratees,orders);}/**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */var partition=createAggregator(function(result,value,key){result[key?0:1].push(value);},function(){return [[],[]];});/**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */function reduce(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduce:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEach);}/**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */function reduceRight(collection,iteratee,accumulator){var func=isArray(collection)?arrayReduceRight:baseReduce,initAccum=arguments.length<3;return func(collection,getIteratee(iteratee,4),accumulator,initAccum,baseEachRight);}/**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */function reject(collection,predicate){var func=isArray(collection)?arrayFilter:baseFilter;return func(collection,negate(getIteratee(predicate,3)));}/**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */function sample(collection){var func=isArray(collection)?arraySample:baseSample;return func(collection);}/**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */function sampleSize(collection,n,guard){if(guard?isIterateeCall(collection,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}var func=isArray(collection)?arraySampleSize:baseSampleSize;return func(collection,n);}/**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */function shuffle(collection){var func=isArray(collection)?arrayShuffle:baseShuffle;return func(collection);}/**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */function size(collection){if(collection==null){return 0;}if(isArrayLike(collection)){return isString(collection)?stringSize(collection):collection.length;}var tag=getTag(collection);if(tag==mapTag||tag==setTag){return collection.size;}return baseKeys(collection).length;}/**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */function some(collection,predicate,guard){var func=isArray(collection)?arraySome:baseSome;if(guard&&isIterateeCall(collection,predicate,guard)){predicate=undefined$1;}return func(collection,getIteratee(predicate,3));}/**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */var sortBy=baseRest(function(collection,iteratees){if(collection==null){return [];}var length=iteratees.length;if(length>1&&isIterateeCall(collection,iteratees[0],iteratees[1])){iteratees=[];}else if(length>2&&isIterateeCall(iteratees[0],iteratees[1],iteratees[2])){iteratees=[iteratees[0]];}return baseOrderBy(collection,baseFlatten(iteratees,1),[]);});/*------------------------------------------------------------------------*/ /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */var now=ctxNow||function(){return root.Date.now();};/*------------------------------------------------------------------------*/ /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */function after(n,func){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n<1){return func.apply(this,arguments);}};}/**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */function ary(func,n,guard){n=guard?undefined$1:n;n=func&&n==null?func.length:n;return createWrap(func,WRAP_ARY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,n);}/**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */function before(n,func){var result;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}n=toInteger(n);return function(){if(--n>0){result=func.apply(this,arguments);}if(n<=1){func=undefined$1;}return result;};}/**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */var bind=baseRest(function(func,thisArg,partials){var bitmask=WRAP_BIND_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bind));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(func,bitmask,thisArg,partials,holders);});/**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */var bindKey=baseRest(function(object,key,partials){var bitmask=WRAP_BIND_FLAG|WRAP_BIND_KEY_FLAG;if(partials.length){var holders=replaceHolders(partials,getHolder(bindKey));bitmask|=WRAP_PARTIAL_FLAG;}return createWrap(key,bitmask,object,partials,holders);});/**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */function curry(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curry.placeholder;return result;}/**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */function curryRight(func,arity,guard){arity=guard?undefined$1:arity;var result=createWrap(func,WRAP_CURRY_RIGHT_FLAG,undefined$1,undefined$1,undefined$1,undefined$1,undefined$1,arity);result.placeholder=curryRight.placeholder;return result;}/**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=false,maxing=false,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}wait=toNumber(wait)||0;if(isObject(options)){leading=!!options.leading;maxing='maxWait'in options;maxWait=maxing?nativeMax(toNumber(options.maxWait)||0,wait):maxWait;trailing='trailing'in options?!!options.trailing:trailing;}function invokeFunc(time){var args=lastArgs,thisArg=lastThis;lastArgs=lastThis=undefined$1;lastInvokeTime=time;result=func.apply(thisArg,args);return result;}function leadingEdge(time){// Reset any `maxWait` timer.
lastInvokeTime=time;// Start the timer for the trailing edge.
timerId=setTimeout(timerExpired,wait);// Invoke the leading edge.
return leading?invokeFunc(time):result;}function remainingWait(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime,timeWaiting=wait-timeSinceLastCall;return maxing?nativeMin(timeWaiting,maxWait-timeSinceLastInvoke):timeWaiting;}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime,timeSinceLastInvoke=time-lastInvokeTime;// Either this is the first call, activity has stopped and we're at the
// trailing edge, the system time has gone backwards and we're treating
// it as the trailing edge, or we've hit the `maxWait` limit.
return lastCallTime===undefined$1||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&timeSinceLastInvoke>=maxWait;}function timerExpired(){var time=now();if(shouldInvoke(time)){return trailingEdge(time);}// Restart the timer.
timerId=setTimeout(timerExpired,remainingWait(time));}function trailingEdge(time){timerId=undefined$1;// Only invoke if we have `lastArgs` which means `func` has been
// debounced at least once.
if(trailing&&lastArgs){return invokeFunc(time);}lastArgs=lastThis=undefined$1;return result;}function cancel(){if(timerId!==undefined$1){clearTimeout(timerId);}lastInvokeTime=0;lastArgs=lastCallTime=lastThis=timerId=undefined$1;}function flush(){return timerId===undefined$1?result:trailingEdge(now());}function debounced(){var time=now(),isInvoking=shouldInvoke(time);lastArgs=arguments;lastThis=this;lastCallTime=time;if(isInvoking){if(timerId===undefined$1){return leadingEdge(lastCallTime);}if(maxing){// Handle invocations in a tight loop.
clearTimeout(timerId);timerId=setTimeout(timerExpired,wait);return invokeFunc(lastCallTime);}}if(timerId===undefined$1){timerId=setTimeout(timerExpired,wait);}return result;}debounced.cancel=cancel;debounced.flush=flush;return debounced;}/**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */var defer=baseRest(function(func,args){return baseDelay(func,1,args);});/**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */var delay=baseRest(function(func,wait,args){return baseDelay(func,toNumber(wait)||0,args);});/**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */function flip(func){return createWrap(func,WRAP_FLIP_FLAG);}/**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */function memoize(func,resolver){if(typeof func!='function'||resolver!=null&&typeof resolver!='function'){throw new TypeError(FUNC_ERROR_TEXT);}var memoized=function(){var args=arguments,key=resolver?resolver.apply(this,args):args[0],cache=memoized.cache;if(cache.has(key)){return cache.get(key);}var result=func.apply(this,args);memoized.cache=cache.set(key,result)||cache;return result;};memoized.cache=new(memoize.Cache||MapCache)();return memoized;}// Expose `MapCache`.
memoize.Cache=MapCache;/**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */function negate(predicate){if(typeof predicate!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return function(){var args=arguments;switch(args.length){case 0:return !predicate.call(this);case 1:return !predicate.call(this,args[0]);case 2:return !predicate.call(this,args[0],args[1]);case 3:return !predicate.call(this,args[0],args[1],args[2]);}return !predicate.apply(this,args);};}/**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */function once(func){return before(2,func);}/**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */var overArgs=castRest(function(func,transforms){transforms=transforms.length==1&&isArray(transforms[0])?arrayMap(transforms[0],baseUnary(getIteratee())):arrayMap(baseFlatten(transforms,1),baseUnary(getIteratee()));var funcsLength=transforms.length;return baseRest(function(args){var index=-1,length=nativeMin(args.length,funcsLength);while(++index<length){args[index]=transforms[index].call(this,args[index]);}return apply(func,this,args);});});/**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */var partial=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partial));return createWrap(func,WRAP_PARTIAL_FLAG,undefined$1,partials,holders);});/**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */var partialRight=baseRest(function(func,partials){var holders=replaceHolders(partials,getHolder(partialRight));return createWrap(func,WRAP_PARTIAL_RIGHT_FLAG,undefined$1,partials,holders);});/**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */var rearg=flatRest(function(func,indexes){return createWrap(func,WRAP_REARG_FLAG,undefined$1,undefined$1,undefined$1,indexes);});/**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */function rest(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start===undefined$1?start:toInteger(start);return baseRest(func,start);}/**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */function spread(func,start){if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}start=start==null?0:nativeMax(toInteger(start),0);return baseRest(function(args){var array=args[start],otherArgs=castSlice(args,0,start);if(array){arrayPush(otherArgs,array);}return apply(func,this,otherArgs);});}/**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */function throttle(func,wait,options){var leading=true,trailing=true;if(typeof func!='function'){throw new TypeError(FUNC_ERROR_TEXT);}if(isObject(options)){leading='leading'in options?!!options.leading:leading;trailing='trailing'in options?!!options.trailing:trailing;}return debounce(func,wait,{'leading':leading,'maxWait':wait,'trailing':trailing});}/**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */function unary(func){return ary(func,1);}/**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */function wrap(value,wrapper){return partial(castFunction(wrapper),value);}/*------------------------------------------------------------------------*/ /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */function castArray(){if(!arguments.length){return [];}var value=arguments[0];return isArray(value)?value:[value];}/**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */function clone(value){return baseClone(value,CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */function cloneWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_SYMBOLS_FLAG,customizer);}/**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */function cloneDeep(value){return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG);}/**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */function cloneDeepWith(value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseClone(value,CLONE_DEEP_FLAG|CLONE_SYMBOLS_FLAG,customizer);}/**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */function conformsTo(object,source){return source==null||baseConformsTo(object,source,keys(source));}/**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */function eq(value,other){return value===other||value!==value&&other!==other;}/**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */var gt=createRelationalOperation(baseGt);/**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */var gte=createRelationalOperation(function(value,other){return value>=other;});/**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */var isArguments=baseIsArguments(function(){return arguments;}())?baseIsArguments:function(value){return isObjectLike(value)&&hasOwnProperty.call(value,'callee')&&!propertyIsEnumerable.call(value,'callee');};/**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */var isArray=Array.isArray;/**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */var isArrayBuffer=nodeIsArrayBuffer?baseUnary(nodeIsArrayBuffer):baseIsArrayBuffer;/**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */function isArrayLike(value){return value!=null&&isLength(value.length)&&!isFunction(value);}/**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */function isArrayLikeObject(value){return isObjectLike(value)&&isArrayLike(value);}/**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */function isBoolean(value){return value===true||value===false||isObjectLike(value)&&baseGetTag(value)==boolTag;}/**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */var isBuffer=nativeIsBuffer||stubFalse;/**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */var isDate=nodeIsDate?baseUnary(nodeIsDate):baseIsDate;/**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */function isElement(value){return isObjectLike(value)&&value.nodeType===1&&!isPlainObject(value);}/**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */function isEmpty(value){if(value==null){return true;}if(isArrayLike(value)&&(isArray(value)||typeof value=='string'||typeof value.splice=='function'||isBuffer(value)||isTypedArray(value)||isArguments(value))){return !value.length;}var tag=getTag(value);if(tag==mapTag||tag==setTag){return !value.size;}if(isPrototype(value)){return !baseKeys(value).length;}for(var key in value){if(hasOwnProperty.call(value,key)){return false;}}return true;}/**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */function isEqual(value,other){return baseIsEqual(value,other);}/**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */function isEqualWith(value,other,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;var result=customizer?customizer(value,other):undefined$1;return result===undefined$1?baseIsEqual(value,other,undefined$1,customizer):!!result;}/**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */function isError(value){if(!isObjectLike(value)){return false;}var tag=baseGetTag(value);return tag==errorTag||tag==domExcTag||typeof value.message=='string'&&typeof value.name=='string'&&!isPlainObject(value);}/**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */function isFinite(value){return typeof value=='number'&&nativeIsFinite(value);}/**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */function isFunction(value){if(!isObject(value)){return false;}// The use of `Object#toString` avoids issues with the `typeof` operator
// in Safari 9 which returns 'object' for typed arrays and other constructors.
var tag=baseGetTag(value);return tag==funcTag||tag==genTag||tag==asyncTag||tag==proxyTag;}/**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */function isInteger(value){return typeof value=='number'&&value==toInteger(value);}/**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */function isLength(value){return typeof value=='number'&&value>-1&&value%1==0&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */function isObject(value){var type=typeof value;return value!=null&&(type=='object'||type=='function');}/**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */function isObjectLike(value){return value!=null&&typeof value=='object';}/**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */var isMap=nodeIsMap?baseUnary(nodeIsMap):baseIsMap;/**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */function isMatch(object,source){return object===source||baseIsMatch(object,source,getMatchData(source));}/**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */function isMatchWith(object,source,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return baseIsMatch(object,source,getMatchData(source),customizer);}/**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */function isNaN(value){// An `NaN` primitive is the only value that is not equal to itself.
// Perform the `toStringTag` check first to avoid errors with some
// ActiveX objects in IE.
return isNumber(value)&&value!=+value;}/**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */function isNative(value){if(isMaskable(value)){throw new Error(CORE_ERROR_TEXT);}return baseIsNative(value);}/**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */function isNull(value){return value===null;}/**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */function isNil(value){return value==null;}/**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */function isNumber(value){return typeof value=='number'||isObjectLike(value)&&baseGetTag(value)==numberTag;}/**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */function isPlainObject(value){if(!isObjectLike(value)||baseGetTag(value)!=objectTag){return false;}var proto=getPrototype(value);if(proto===null){return true;}var Ctor=hasOwnProperty.call(proto,'constructor')&&proto.constructor;return typeof Ctor=='function'&&Ctor instanceof Ctor&&funcToString.call(Ctor)==objectCtorString;}/**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */var isRegExp=nodeIsRegExp?baseUnary(nodeIsRegExp):baseIsRegExp;/**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */function isSafeInteger(value){return isInteger(value)&&value>=-MAX_SAFE_INTEGER&&value<=MAX_SAFE_INTEGER;}/**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */var isSet=nodeIsSet?baseUnary(nodeIsSet):baseIsSet;/**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */function isString(value){return typeof value=='string'||!isArray(value)&&isObjectLike(value)&&baseGetTag(value)==stringTag;}/**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */function isSymbol(value){return typeof value=='symbol'||isObjectLike(value)&&baseGetTag(value)==symbolTag;}/**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */var isTypedArray=nodeIsTypedArray?baseUnary(nodeIsTypedArray):baseIsTypedArray;/**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */function isUndefined(value){return value===undefined$1;}/**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */function isWeakMap(value){return isObjectLike(value)&&getTag(value)==weakMapTag;}/**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */function isWeakSet(value){return isObjectLike(value)&&baseGetTag(value)==weakSetTag;}/**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */var lt=createRelationalOperation(baseLt);/**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */var lte=createRelationalOperation(function(value,other){return value<=other;});/**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */function toArray(value){if(!value){return [];}if(isArrayLike(value)){return isString(value)?stringToArray(value):copyArray(value);}if(symIterator&&value[symIterator]){return iteratorToArray(value[symIterator]());}var tag=getTag(value),func=tag==mapTag?mapToArray:tag==setTag?setToArray:values;return func(value);}/**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */function toFinite(value){if(!value){return value===0?value:0;}value=toNumber(value);if(value===INFINITY||value===-INFINITY){var sign=value<0?-1:1;return sign*MAX_INTEGER;}return value===value?value:0;}/**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */function toInteger(value){var result=toFinite(value),remainder=result%1;return result===result?remainder?result-remainder:result:0;}/**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */function toLength(value){return value?baseClamp(toInteger(value),0,MAX_ARRAY_LENGTH):0;}/**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */function toNumber(value){if(typeof value=='number'){return value;}if(isSymbol(value)){return NAN;}if(isObject(value)){var other=typeof value.valueOf=='function'?value.valueOf():value;value=isObject(other)?other+'':other;}if(typeof value!='string'){return value===0?value:+value;}value=value.replace(reTrim,'');var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value;}/**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */function toPlainObject(value){return copyObject(value,keysIn(value));}/**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */function toSafeInteger(value){return value?baseClamp(toInteger(value),-MAX_SAFE_INTEGER,MAX_SAFE_INTEGER):value===0?value:0;}/**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */function toString(value){return value==null?'':baseToString(value);}/*------------------------------------------------------------------------*/ /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */var assign=createAssigner(function(object,source){if(isPrototype(source)||isArrayLike(source)){copyObject(source,keys(source),object);return;}for(var key in source){if(hasOwnProperty.call(source,key)){assignValue(object,key,source[key]);}}});/**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */var assignIn=createAssigner(function(object,source){copyObject(source,keysIn(source),object);});/**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignInWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keysIn(source),object,customizer);});/**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var assignWith=createAssigner(function(object,source,srcIndex,customizer){copyObject(source,keys(source),object,customizer);});/**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */var at=flatRest(baseAt);/**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */function create(prototype,properties){var result=baseCreate(prototype);return properties==null?result:baseAssign(result,properties);}/**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */var defaults=baseRest(function(object,sources){object=Object(object);var index=-1;var length=sources.length;var guard=length>2?sources[2]:undefined$1;if(guard&&isIterateeCall(sources[0],sources[1],guard)){length=1;}while(++index<length){var source=sources[index];var props=keysIn(source);var propsIndex=-1;var propsLength=props.length;while(++propsIndex<propsLength){var key=props[propsIndex];var value=object[key];if(value===undefined$1||eq(value,objectProto[key])&&!hasOwnProperty.call(object,key)){object[key]=source[key];}}}return object;});/**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */var defaultsDeep=baseRest(function(args){args.push(undefined$1,customDefaultsMerge);return apply(mergeWith,undefined$1,args);});/**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */function findKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwn);}/**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */function findLastKey(object,predicate){return baseFindKey(object,getIteratee(predicate,3),baseForOwnRight);}/**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */function forIn(object,iteratee){return object==null?object:baseFor(object,getIteratee(iteratee,3),keysIn);}/**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */function forInRight(object,iteratee){return object==null?object:baseForRight(object,getIteratee(iteratee,3),keysIn);}/**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */function forOwn(object,iteratee){return object&&baseForOwn(object,getIteratee(iteratee,3));}/**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */function forOwnRight(object,iteratee){return object&&baseForOwnRight(object,getIteratee(iteratee,3));}/**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */function functions(object){return object==null?[]:baseFunctions(object,keys(object));}/**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */function functionsIn(object){return object==null?[]:baseFunctions(object,keysIn(object));}/**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */function get(object,path,defaultValue){var result=object==null?undefined$1:baseGet(object,path);return result===undefined$1?defaultValue:result;}/**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */function has(object,path){return object!=null&&hasPath(object,path,baseHas);}/**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */function hasIn(object,path){return object!=null&&hasPath(object,path,baseHasIn);}/**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */var invert=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}result[value]=key;},constant(identity));/**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */var invertBy=createInverter(function(result,value,key){if(value!=null&&typeof value.toString!='function'){value=nativeObjectToString.call(value);}if(hasOwnProperty.call(result,value)){result[value].push(key);}else {result[value]=[key];}},getIteratee);/**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */var invoke=baseRest(baseInvoke);/**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */function keys(object){return isArrayLike(object)?arrayLikeKeys(object):baseKeys(object);}/**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */function keysIn(object){return isArrayLike(object)?arrayLikeKeys(object,true):baseKeysIn(object);}/**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */function mapKeys(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,iteratee(value,key,object),value);});return result;}/**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */function mapValues(object,iteratee){var result={};iteratee=getIteratee(iteratee,3);baseForOwn(object,function(value,key,object){baseAssignValue(result,key,iteratee(value,key,object));});return result;}/**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */var merge=createAssigner(function(object,source,srcIndex){baseMerge(object,source,srcIndex);});/**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */var mergeWith=createAssigner(function(object,source,srcIndex,customizer){baseMerge(object,source,srcIndex,customizer);});/**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */var omit=flatRest(function(object,paths){var result={};if(object==null){return result;}var isDeep=false;paths=arrayMap(paths,function(path){path=castPath(path,object);isDeep||(isDeep=path.length>1);return path;});copyObject(object,getAllKeysIn(object),result);if(isDeep){result=baseClone(result,CLONE_DEEP_FLAG|CLONE_FLAT_FLAG|CLONE_SYMBOLS_FLAG,customOmitClone);}var length=paths.length;while(length--){baseUnset(result,paths[length]);}return result;});/**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */function omitBy(object,predicate){return pickBy(object,negate(getIteratee(predicate)));}/**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */var pick=flatRest(function(object,paths){return object==null?{}:basePick(object,paths);});/**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */function pickBy(object,predicate){if(object==null){return {};}var props=arrayMap(getAllKeysIn(object),function(prop){return [prop];});predicate=getIteratee(predicate);return basePickBy(object,props,function(value,path){return predicate(value,path[0]);});}/**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */function result(object,path,defaultValue){path=castPath(path,object);var index=-1,length=path.length;// Ensure the loop is entered when path is empty.
if(!length){length=1;object=undefined$1;}while(++index<length){var value=object==null?undefined$1:object[toKey(path[index])];if(value===undefined$1){index=length;value=defaultValue;}object=isFunction(value)?value.call(object):value;}return object;}/**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */function set(object,path,value){return object==null?object:baseSet(object,path,value);}/**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */function setWith(object,path,value,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseSet(object,path,value,customizer);}/**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */var toPairs=createToPairs(keys);/**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */var toPairsIn=createToPairs(keysIn);/**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */function transform(object,iteratee,accumulator){var isArr=isArray(object),isArrLike=isArr||isBuffer(object)||isTypedArray(object);iteratee=getIteratee(iteratee,4);if(accumulator==null){var Ctor=object&&object.constructor;if(isArrLike){accumulator=isArr?new Ctor():[];}else if(isObject(object)){accumulator=isFunction(Ctor)?baseCreate(getPrototype(object)):{};}else {accumulator={};}}(isArrLike?arrayEach:baseForOwn)(object,function(value,index,object){return iteratee(accumulator,value,index,object);});return accumulator;}/**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */function unset(object,path){return object==null?true:baseUnset(object,path);}/**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */function update(object,path,updater){return object==null?object:baseUpdate(object,path,castFunction(updater));}/**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */function updateWith(object,path,updater,customizer){customizer=typeof customizer=='function'?customizer:undefined$1;return object==null?object:baseUpdate(object,path,castFunction(updater),customizer);}/**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */function values(object){return object==null?[]:baseValues(object,keys(object));}/**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */function valuesIn(object){return object==null?[]:baseValues(object,keysIn(object));}/*------------------------------------------------------------------------*/ /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */function clamp(number,lower,upper){if(upper===undefined$1){upper=lower;lower=undefined$1;}if(upper!==undefined$1){upper=toNumber(upper);upper=upper===upper?upper:0;}if(lower!==undefined$1){lower=toNumber(lower);lower=lower===lower?lower:0;}return baseClamp(toNumber(number),lower,upper);}/**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */function inRange(number,start,end){start=toFinite(start);if(end===undefined$1){end=start;start=0;}else {end=toFinite(end);}number=toNumber(number);return baseInRange(number,start,end);}/**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */function random(lower,upper,floating){if(floating&&typeof floating!='boolean'&&isIterateeCall(lower,upper,floating)){upper=floating=undefined$1;}if(floating===undefined$1){if(typeof upper=='boolean'){floating=upper;upper=undefined$1;}else if(typeof lower=='boolean'){floating=lower;lower=undefined$1;}}if(lower===undefined$1&&upper===undefined$1){lower=0;upper=1;}else {lower=toFinite(lower);if(upper===undefined$1){upper=lower;lower=0;}else {upper=toFinite(upper);}}if(lower>upper){var temp=lower;lower=upper;upper=temp;}if(floating||lower%1||upper%1){var rand=nativeRandom();return nativeMin(lower+rand*(upper-lower+freeParseFloat('1e-'+((rand+'').length-1))),upper);}return baseRandom(lower,upper);}/*------------------------------------------------------------------------*/ /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */var camelCase=createCompounder(function(result,word,index){word=word.toLowerCase();return result+(index?capitalize(word):word);});/**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */function capitalize(string){return upperFirst(toString(string).toLowerCase());}/**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */function deburr(string){string=toString(string);return string&&string.replace(reLatin,deburrLetter).replace(reComboMark,'');}/**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */function endsWith(string,target,position){string=toString(string);target=baseToString(target);var length=string.length;position=position===undefined$1?length:baseClamp(toInteger(position),0,length);var end=position;position-=target.length;return position>=0&&string.slice(position,end)==target;}/**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */function escape(string){string=toString(string);return string&&reHasUnescapedHtml.test(string)?string.replace(reUnescapedHtml,escapeHtmlChar):string;}/**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */function escapeRegExp(string){string=toString(string);return string&&reHasRegExpChar.test(string)?string.replace(reRegExpChar,'\\$&'):string;}/**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */var kebabCase=createCompounder(function(result,word,index){return result+(index?'-':'')+word.toLowerCase();});/**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */var lowerCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toLowerCase();});/**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */var lowerFirst=createCaseFirst('toLowerCase');/**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */function pad(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;if(!length||strLength>=length){return string;}var mid=(length-strLength)/2;return createPadding(nativeFloor(mid),chars)+string+createPadding(nativeCeil(mid),chars);}/**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */function padEnd(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?string+createPadding(length-strLength,chars):string;}/**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */function padStart(string,length,chars){string=toString(string);length=toInteger(length);var strLength=length?stringSize(string):0;return length&&strLength<length?createPadding(length-strLength,chars)+string:string;}/**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */function parseInt(string,radix,guard){if(guard||radix==null){radix=0;}else if(radix){radix=+radix;}return nativeParseInt(toString(string).replace(reTrimStart,''),radix||0);}/**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */function repeat(string,n,guard){if(guard?isIterateeCall(string,n,guard):n===undefined$1){n=1;}else {n=toInteger(n);}return baseRepeat(toString(string),n);}/**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */function replace(){var args=arguments,string=toString(args[0]);return args.length<3?string:string.replace(args[1],args[2]);}/**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */var snakeCase=createCompounder(function(result,word,index){return result+(index?'_':'')+word.toLowerCase();});/**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */function split(string,separator,limit){if(limit&&typeof limit!='number'&&isIterateeCall(string,separator,limit)){separator=limit=undefined$1;}limit=limit===undefined$1?MAX_ARRAY_LENGTH:limit>>>0;if(!limit){return [];}string=toString(string);if(string&&(typeof separator=='string'||separator!=null&&!isRegExp(separator))){separator=baseToString(separator);if(!separator&&hasUnicode(string)){return castSlice(stringToArray(string),0,limit);}}return string.split(separator,limit);}/**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */var startCase=createCompounder(function(result,word,index){return result+(index?' ':'')+upperFirst(word);});/**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */function startsWith(string,target,position){string=toString(string);position=position==null?0:baseClamp(toInteger(position),0,string.length);target=baseToString(target);return string.slice(position,position+target.length)==target;}/**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */function template(string,options,guard){// Based on John Resig's `tmpl` implementation
// (http://ejohn.org/blog/javascript-micro-templating/)
// and Laura Doktorova's doT.js (https://github.com/olado/doT).
var settings=lodash.templateSettings;if(guard&&isIterateeCall(string,options,guard)){options=undefined$1;}string=toString(string);options=assignInWith({},options,settings,customDefaultsAssignIn);var imports=assignInWith({},options.imports,settings.imports,customDefaultsAssignIn),importsKeys=keys(imports),importsValues=baseValues(imports,importsKeys);var isEscaping,isEvaluating,index=0,interpolate=options.interpolate||reNoMatch,source="__p += '";// Compile the regexp to match each delimiter.
var reDelimiters=RegExp((options.escape||reNoMatch).source+'|'+interpolate.source+'|'+(interpolate===reInterpolate?reEsTemplate:reNoMatch).source+'|'+(options.evaluate||reNoMatch).source+'|$','g');// Use a sourceURL for easier debugging.
// The sourceURL gets injected into the source that's eval-ed, so be careful
// to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
// and escape the comment, thus injecting code that gets evaled.
var sourceURL='//# sourceURL='+(hasOwnProperty.call(options,'sourceURL')?(options.sourceURL+'').replace(/\s/g,' '):'lodash.templateSources['+ ++templateCounter+']')+'\n';string.replace(reDelimiters,function(match,escapeValue,interpolateValue,esTemplateValue,evaluateValue,offset){interpolateValue||(interpolateValue=esTemplateValue);// Escape characters that can't be included in string literals.
source+=string.slice(index,offset).replace(reUnescapedString,escapeStringChar);// Replace delimiters with snippets.
if(escapeValue){isEscaping=true;source+="' +\n__e("+escapeValue+") +\n'";}if(evaluateValue){isEvaluating=true;source+="';\n"+evaluateValue+";\n__p += '";}if(interpolateValue){source+="' +\n((__t = ("+interpolateValue+")) == null ? '' : __t) +\n'";}index=offset+match.length;// The JS engine embedded in Adobe products needs `match` returned in
// order to produce the correct `offset` value.
return match;});source+="';\n";// If `variable` is not specified wrap a with-statement around the generated
// code to add the data object to the top of the scope chain.
var variable=hasOwnProperty.call(options,'variable')&&options.variable;if(!variable){source='with (obj) {\n'+source+'\n}\n';}// Cleanup code by stripping empty strings.
source=(isEvaluating?source.replace(reEmptyStringLeading,''):source).replace(reEmptyStringMiddle,'$1').replace(reEmptyStringTrailing,'$1;');// Frame code as the function body.
source='function('+(variable||'obj')+') {\n'+(variable?'':'obj || (obj = {});\n')+"var __t, __p = ''"+(isEscaping?', __e = _.escape':'')+(isEvaluating?', __j = Array.prototype.join;\n'+"function print() { __p += __j.call(arguments, '') }\n":';\n')+source+'return __p\n}';var result=attempt(function(){return Function(importsKeys,sourceURL+'return '+source).apply(undefined$1,importsValues);});// Provide the compiled function's source by its `toString` method or
// the `source` property as a convenience for inlining compiled templates.
result.source=source;if(isError(result)){throw result;}return result;}/**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */function toLower(value){return toString(value).toLowerCase();}/**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */function toUpper(value){return toString(value).toUpperCase();}/**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */function trim(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrim,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),chrSymbols=stringToArray(chars),start=charsStartIndex(strSymbols,chrSymbols),end=charsEndIndex(strSymbols,chrSymbols)+1;return castSlice(strSymbols,start,end).join('');}/**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */function trimEnd(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimEnd,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),end=charsEndIndex(strSymbols,stringToArray(chars))+1;return castSlice(strSymbols,0,end).join('');}/**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */function trimStart(string,chars,guard){string=toString(string);if(string&&(guard||chars===undefined$1)){return string.replace(reTrimStart,'');}if(!string||!(chars=baseToString(chars))){return string;}var strSymbols=stringToArray(string),start=charsStartIndex(strSymbols,stringToArray(chars));return castSlice(strSymbols,start).join('');}/**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */function truncate(string,options){var length=DEFAULT_TRUNC_LENGTH,omission=DEFAULT_TRUNC_OMISSION;if(isObject(options)){var separator='separator'in options?options.separator:separator;length='length'in options?toInteger(options.length):length;omission='omission'in options?baseToString(options.omission):omission;}string=toString(string);var strLength=string.length;if(hasUnicode(string)){var strSymbols=stringToArray(string);strLength=strSymbols.length;}if(length>=strLength){return string;}var end=length-stringSize(omission);if(end<1){return omission;}var result=strSymbols?castSlice(strSymbols,0,end).join(''):string.slice(0,end);if(separator===undefined$1){return result+omission;}if(strSymbols){end+=result.length-end;}if(isRegExp(separator)){if(string.slice(end).search(separator)){var match,substring=result;if(!separator.global){separator=RegExp(separator.source,toString(reFlags.exec(separator))+'g');}separator.lastIndex=0;while(match=separator.exec(substring)){var newEnd=match.index;}result=result.slice(0,newEnd===undefined$1?end:newEnd);}}else if(string.indexOf(baseToString(separator),end)!=end){var index=result.lastIndexOf(separator);if(index>-1){result=result.slice(0,index);}}return result+omission;}/**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */function unescape(string){string=toString(string);return string&&reHasEscapedHtml.test(string)?string.replace(reEscapedHtml,unescapeHtmlChar):string;}/**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */var upperCase=createCompounder(function(result,word,index){return result+(index?' ':'')+word.toUpperCase();});/**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */var upperFirst=createCaseFirst('toUpperCase');/**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */function words(string,pattern,guard){string=toString(string);pattern=guard?undefined$1:pattern;if(pattern===undefined$1){return hasUnicodeWord(string)?unicodeWords(string):asciiWords(string);}return string.match(pattern)||[];}/*------------------------------------------------------------------------*/ /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */var attempt=baseRest(function(func,args){try{return apply(func,undefined$1,args);}catch(e){return isError(e)?e:new Error(e);}});/**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */var bindAll=flatRest(function(object,methodNames){arrayEach(methodNames,function(key){key=toKey(key);baseAssignValue(object,key,bind(object[key],object));});return object;});/**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */function cond(pairs){var length=pairs==null?0:pairs.length,toIteratee=getIteratee();pairs=!length?[]:arrayMap(pairs,function(pair){if(typeof pair[1]!='function'){throw new TypeError(FUNC_ERROR_TEXT);}return [toIteratee(pair[0]),pair[1]];});return baseRest(function(args){var index=-1;while(++index<length){var pair=pairs[index];if(apply(pair[0],this,args)){return apply(pair[1],this,args);}}});}/**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */function conforms(source){return baseConforms(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */function constant(value){return function(){return value;};}/**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */function defaultTo(value,defaultValue){return value==null||value!==value?defaultValue:value;}/**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */var flow=createFlow();/**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */var flowRight=createFlow(true);/**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */function identity(value){return value;}/**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */function iteratee(func){return baseIteratee(typeof func=='function'?func:baseClone(func,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(users, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matches(source){return baseMatches(baseClone(source,CLONE_DEEP_FLAG));}/**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(users, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */function matchesProperty(path,srcValue){return baseMatchesProperty(path,baseClone(srcValue,CLONE_DEEP_FLAG));}/**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */var method=baseRest(function(path,args){return function(object){return baseInvoke(object,path,args);};});/**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */var methodOf=baseRest(function(object,args){return function(path){return baseInvoke(object,path,args);};});/**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */function mixin(object,source,options){var props=keys(source),methodNames=baseFunctions(source,props);if(options==null&&!(isObject(source)&&(methodNames.length||!props.length))){options=source;source=object;object=this;methodNames=baseFunctions(source,keys(source));}var chain=!(isObject(options)&&'chain'in options)||!!options.chain,isFunc=isFunction(object);arrayEach(methodNames,function(methodName){var func=source[methodName];object[methodName]=func;if(isFunc){object.prototype[methodName]=function(){var chainAll=this.__chain__;if(chain||chainAll){var result=object(this.__wrapped__),actions=result.__actions__=copyArray(this.__actions__);actions.push({'func':func,'args':arguments,'thisArg':object});result.__chain__=chainAll;return result;}return func.apply(object,arrayPush([this.value()],arguments));};}});return object;}/**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */function noConflict(){if(root._===this){root._=oldDash;}return this;}/**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */function noop(){// No operation performed.
}/**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */function nthArg(n){n=toInteger(n);return baseRest(function(args){return baseNth(args,n);});}/**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */var over=createOver(arrayMap);/**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */var overEvery=createOver(arrayEvery);/**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */var overSome=createOver(arraySome);/**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */function property(path){return isKey(path)?baseProperty(toKey(path)):basePropertyDeep(path);}/**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */function propertyOf(object){return function(path){return object==null?undefined$1:baseGet(object,path);};}/**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */var range=createRange();/**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */var rangeRight=createRange(true);/**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */function stubArray(){return [];}/**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */function stubFalse(){return false;}/**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */function stubObject(){return {};}/**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */function stubString(){return '';}/**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */function stubTrue(){return true;}/**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */function times(n,iteratee){n=toInteger(n);if(n<1||n>MAX_SAFE_INTEGER){return [];}var index=MAX_ARRAY_LENGTH,length=nativeMin(n,MAX_ARRAY_LENGTH);iteratee=getIteratee(iteratee);n-=MAX_ARRAY_LENGTH;var result=baseTimes(length,iteratee);while(++index<n){iteratee(index);}return result;}/**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */function toPath(value){if(isArray(value)){return arrayMap(value,toKey);}return isSymbol(value)?[value]:copyArray(stringToPath(toString(value)));}/**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */function uniqueId(prefix){var id=++idCounter;return toString(prefix)+id;}/*------------------------------------------------------------------------*/ /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */var add=createMathOperation(function(augend,addend){return augend+addend;},0);/**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */var ceil=createRound('ceil');/**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */var divide=createMathOperation(function(dividend,divisor){return dividend/divisor;},1);/**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */var floor=createRound('floor');/**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */function max(array){return array&&array.length?baseExtremum(array,identity,baseGt):undefined$1;}/**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */function maxBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseGt):undefined$1;}/**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */function mean(array){return baseMean(array,identity);}/**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */function meanBy(array,iteratee){return baseMean(array,getIteratee(iteratee,2));}/**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */function min(array){return array&&array.length?baseExtremum(array,identity,baseLt):undefined$1;}/**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */function minBy(array,iteratee){return array&&array.length?baseExtremum(array,getIteratee(iteratee,2),baseLt):undefined$1;}/**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */var multiply=createMathOperation(function(multiplier,multiplicand){return multiplier*multiplicand;},1);/**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */var round=createRound('round');/**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */var subtract=createMathOperation(function(minuend,subtrahend){return minuend-subtrahend;},0);/**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */function sum(array){return array&&array.length?baseSum(array,identity):0;}/**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */function sumBy(array,iteratee){return array&&array.length?baseSum(array,getIteratee(iteratee,2)):0;}/*------------------------------------------------------------------------*/ // Add methods that return wrapped values in chain sequences.
lodash.after=after;lodash.ary=ary;lodash.assign=assign;lodash.assignIn=assignIn;lodash.assignInWith=assignInWith;lodash.assignWith=assignWith;lodash.at=at;lodash.before=before;lodash.bind=bind;lodash.bindAll=bindAll;lodash.bindKey=bindKey;lodash.castArray=castArray;lodash.chain=chain;lodash.chunk=chunk;lodash.compact=compact;lodash.concat=concat;lodash.cond=cond;lodash.conforms=conforms;lodash.constant=constant;lodash.countBy=countBy;lodash.create=create;lodash.curry=curry;lodash.curryRight=curryRight;lodash.debounce=debounce;lodash.defaults=defaults;lodash.defaultsDeep=defaultsDeep;lodash.defer=defer;lodash.delay=delay;lodash.difference=difference;lodash.differenceBy=differenceBy;lodash.differenceWith=differenceWith;lodash.drop=drop;lodash.dropRight=dropRight;lodash.dropRightWhile=dropRightWhile;lodash.dropWhile=dropWhile;lodash.fill=fill;lodash.filter=filter;lodash.flatMap=flatMap;lodash.flatMapDeep=flatMapDeep;lodash.flatMapDepth=flatMapDepth;lodash.flatten=flatten;lodash.flattenDeep=flattenDeep;lodash.flattenDepth=flattenDepth;lodash.flip=flip;lodash.flow=flow;lodash.flowRight=flowRight;lodash.fromPairs=fromPairs;lodash.functions=functions;lodash.functionsIn=functionsIn;lodash.groupBy=groupBy;lodash.initial=initial;lodash.intersection=intersection;lodash.intersectionBy=intersectionBy;lodash.intersectionWith=intersectionWith;lodash.invert=invert;lodash.invertBy=invertBy;lodash.invokeMap=invokeMap;lodash.iteratee=iteratee;lodash.keyBy=keyBy;lodash.keys=keys;lodash.keysIn=keysIn;lodash.map=map;lodash.mapKeys=mapKeys;lodash.mapValues=mapValues;lodash.matches=matches;lodash.matchesProperty=matchesProperty;lodash.memoize=memoize;lodash.merge=merge;lodash.mergeWith=mergeWith;lodash.method=method;lodash.methodOf=methodOf;lodash.mixin=mixin;lodash.negate=negate;lodash.nthArg=nthArg;lodash.omit=omit;lodash.omitBy=omitBy;lodash.once=once;lodash.orderBy=orderBy;lodash.over=over;lodash.overArgs=overArgs;lodash.overEvery=overEvery;lodash.overSome=overSome;lodash.partial=partial;lodash.partialRight=partialRight;lodash.partition=partition;lodash.pick=pick;lodash.pickBy=pickBy;lodash.property=property;lodash.propertyOf=propertyOf;lodash.pull=pull;lodash.pullAll=pullAll;lodash.pullAllBy=pullAllBy;lodash.pullAllWith=pullAllWith;lodash.pullAt=pullAt;lodash.range=range;lodash.rangeRight=rangeRight;lodash.rearg=rearg;lodash.reject=reject;lodash.remove=remove;lodash.rest=rest;lodash.reverse=reverse;lodash.sampleSize=sampleSize;lodash.set=set;lodash.setWith=setWith;lodash.shuffle=shuffle;lodash.slice=slice;lodash.sortBy=sortBy;lodash.sortedUniq=sortedUniq;lodash.sortedUniqBy=sortedUniqBy;lodash.split=split;lodash.spread=spread;lodash.tail=tail;lodash.take=take;lodash.takeRight=takeRight;lodash.takeRightWhile=takeRightWhile;lodash.takeWhile=takeWhile;lodash.tap=tap;lodash.throttle=throttle;lodash.thru=thru;lodash.toArray=toArray;lodash.toPairs=toPairs;lodash.toPairsIn=toPairsIn;lodash.toPath=toPath;lodash.toPlainObject=toPlainObject;lodash.transform=transform;lodash.unary=unary;lodash.union=union;lodash.unionBy=unionBy;lodash.unionWith=unionWith;lodash.uniq=uniq;lodash.uniqBy=uniqBy;lodash.uniqWith=uniqWith;lodash.unset=unset;lodash.unzip=unzip;lodash.unzipWith=unzipWith;lodash.update=update;lodash.updateWith=updateWith;lodash.values=values;lodash.valuesIn=valuesIn;lodash.without=without;lodash.words=words;lodash.wrap=wrap;lodash.xor=xor;lodash.xorBy=xorBy;lodash.xorWith=xorWith;lodash.zip=zip;lodash.zipObject=zipObject;lodash.zipObjectDeep=zipObjectDeep;lodash.zipWith=zipWith;// Add aliases.
lodash.entries=toPairs;lodash.entriesIn=toPairsIn;lodash.extend=assignIn;lodash.extendWith=assignInWith;// Add methods to `lodash.prototype`.
mixin(lodash,lodash);/*------------------------------------------------------------------------*/ // Add methods that return unwrapped values in chain sequences.
lodash.add=add;lodash.attempt=attempt;lodash.camelCase=camelCase;lodash.capitalize=capitalize;lodash.ceil=ceil;lodash.clamp=clamp;lodash.clone=clone;lodash.cloneDeep=cloneDeep;lodash.cloneDeepWith=cloneDeepWith;lodash.cloneWith=cloneWith;lodash.conformsTo=conformsTo;lodash.deburr=deburr;lodash.defaultTo=defaultTo;lodash.divide=divide;lodash.endsWith=endsWith;lodash.eq=eq;lodash.escape=escape;lodash.escapeRegExp=escapeRegExp;lodash.every=every;lodash.find=find;lodash.findIndex=findIndex;lodash.findKey=findKey;lodash.findLast=findLast;lodash.findLastIndex=findLastIndex;lodash.findLastKey=findLastKey;lodash.floor=floor;lodash.forEach=forEach;lodash.forEachRight=forEachRight;lodash.forIn=forIn;lodash.forInRight=forInRight;lodash.forOwn=forOwn;lodash.forOwnRight=forOwnRight;lodash.get=get;lodash.gt=gt;lodash.gte=gte;lodash.has=has;lodash.hasIn=hasIn;lodash.head=head;lodash.identity=identity;lodash.includes=includes;lodash.indexOf=indexOf;lodash.inRange=inRange;lodash.invoke=invoke;lodash.isArguments=isArguments;lodash.isArray=isArray;lodash.isArrayBuffer=isArrayBuffer;lodash.isArrayLike=isArrayLike;lodash.isArrayLikeObject=isArrayLikeObject;lodash.isBoolean=isBoolean;lodash.isBuffer=isBuffer;lodash.isDate=isDate;lodash.isElement=isElement;lodash.isEmpty=isEmpty;lodash.isEqual=isEqual;lodash.isEqualWith=isEqualWith;lodash.isError=isError;lodash.isFinite=isFinite;lodash.isFunction=isFunction;lodash.isInteger=isInteger;lodash.isLength=isLength;lodash.isMap=isMap;lodash.isMatch=isMatch;lodash.isMatchWith=isMatchWith;lodash.isNaN=isNaN;lodash.isNative=isNative;lodash.isNil=isNil;lodash.isNull=isNull;lodash.isNumber=isNumber;lodash.isObject=isObject;lodash.isObjectLike=isObjectLike;lodash.isPlainObject=isPlainObject;lodash.isRegExp=isRegExp;lodash.isSafeInteger=isSafeInteger;lodash.isSet=isSet;lodash.isString=isString;lodash.isSymbol=isSymbol;lodash.isTypedArray=isTypedArray;lodash.isUndefined=isUndefined;lodash.isWeakMap=isWeakMap;lodash.isWeakSet=isWeakSet;lodash.join=join;lodash.kebabCase=kebabCase;lodash.last=last;lodash.lastIndexOf=lastIndexOf;lodash.lowerCase=lowerCase;lodash.lowerFirst=lowerFirst;lodash.lt=lt;lodash.lte=lte;lodash.max=max;lodash.maxBy=maxBy;lodash.mean=mean;lodash.meanBy=meanBy;lodash.min=min;lodash.minBy=minBy;lodash.stubArray=stubArray;lodash.stubFalse=stubFalse;lodash.stubObject=stubObject;lodash.stubString=stubString;lodash.stubTrue=stubTrue;lodash.multiply=multiply;lodash.nth=nth;lodash.noConflict=noConflict;lodash.noop=noop;lodash.now=now;lodash.pad=pad;lodash.padEnd=padEnd;lodash.padStart=padStart;lodash.parseInt=parseInt;lodash.random=random;lodash.reduce=reduce;lodash.reduceRight=reduceRight;lodash.repeat=repeat;lodash.replace=replace;lodash.result=result;lodash.round=round;lodash.runInContext=runInContext;lodash.sample=sample;lodash.size=size;lodash.snakeCase=snakeCase;lodash.some=some;lodash.sortedIndex=sortedIndex;lodash.sortedIndexBy=sortedIndexBy;lodash.sortedIndexOf=sortedIndexOf;lodash.sortedLastIndex=sortedLastIndex;lodash.sortedLastIndexBy=sortedLastIndexBy;lodash.sortedLastIndexOf=sortedLastIndexOf;lodash.startCase=startCase;lodash.startsWith=startsWith;lodash.subtract=subtract;lodash.sum=sum;lodash.sumBy=sumBy;lodash.template=template;lodash.times=times;lodash.toFinite=toFinite;lodash.toInteger=toInteger;lodash.toLength=toLength;lodash.toLower=toLower;lodash.toNumber=toNumber;lodash.toSafeInteger=toSafeInteger;lodash.toString=toString;lodash.toUpper=toUpper;lodash.trim=trim;lodash.trimEnd=trimEnd;lodash.trimStart=trimStart;lodash.truncate=truncate;lodash.unescape=unescape;lodash.uniqueId=uniqueId;lodash.upperCase=upperCase;lodash.upperFirst=upperFirst;// Add aliases.
lodash.each=forEach;lodash.eachRight=forEachRight;lodash.first=head;mixin(lodash,function(){var source={};baseForOwn(lodash,function(func,methodName){if(!hasOwnProperty.call(lodash.prototype,methodName)){source[methodName]=func;}});return source;}(),{'chain':false});/*------------------------------------------------------------------------*/ /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */lodash.VERSION=VERSION;// Assign default placeholders.
arrayEach(['bind','bindKey','curry','curryRight','partial','partialRight'],function(methodName){lodash[methodName].placeholder=lodash;});// Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
arrayEach(['drop','take'],function(methodName,index){LazyWrapper.prototype[methodName]=function(n){n=n===undefined$1?1:nativeMax(toInteger(n),0);var result=this.__filtered__&&!index?new LazyWrapper(this):this.clone();if(result.__filtered__){result.__takeCount__=nativeMin(n,result.__takeCount__);}else {result.__views__.push({'size':nativeMin(n,MAX_ARRAY_LENGTH),'type':methodName+(result.__dir__<0?'Right':'')});}return result;};LazyWrapper.prototype[methodName+'Right']=function(n){return this.reverse()[methodName](n).reverse();};});// Add `LazyWrapper` methods that accept an `iteratee` value.
arrayEach(['filter','map','takeWhile'],function(methodName,index){var type=index+1,isFilter=type==LAZY_FILTER_FLAG||type==LAZY_WHILE_FLAG;LazyWrapper.prototype[methodName]=function(iteratee){var result=this.clone();result.__iteratees__.push({'iteratee':getIteratee(iteratee,3),'type':type});result.__filtered__=result.__filtered__||isFilter;return result;};});// Add `LazyWrapper` methods for `_.head` and `_.last`.
arrayEach(['head','last'],function(methodName,index){var takeName='take'+(index?'Right':'');LazyWrapper.prototype[methodName]=function(){return this[takeName](1).value()[0];};});// Add `LazyWrapper` methods for `_.initial` and `_.tail`.
arrayEach(['initial','tail'],function(methodName,index){var dropName='drop'+(index?'':'Right');LazyWrapper.prototype[methodName]=function(){return this.__filtered__?new LazyWrapper(this):this[dropName](1);};});LazyWrapper.prototype.compact=function(){return this.filter(identity);};LazyWrapper.prototype.find=function(predicate){return this.filter(predicate).head();};LazyWrapper.prototype.findLast=function(predicate){return this.reverse().find(predicate);};LazyWrapper.prototype.invokeMap=baseRest(function(path,args){if(typeof path=='function'){return new LazyWrapper(this);}return this.map(function(value){return baseInvoke(value,path,args);});});LazyWrapper.prototype.reject=function(predicate){return this.filter(negate(getIteratee(predicate)));};LazyWrapper.prototype.slice=function(start,end){start=toInteger(start);var result=this;if(result.__filtered__&&(start>0||end<0)){return new LazyWrapper(result);}if(start<0){result=result.takeRight(-start);}else if(start){result=result.drop(start);}if(end!==undefined$1){end=toInteger(end);result=end<0?result.dropRight(-end):result.take(end-start);}return result;};LazyWrapper.prototype.takeRightWhile=function(predicate){return this.reverse().takeWhile(predicate).reverse();};LazyWrapper.prototype.toArray=function(){return this.take(MAX_ARRAY_LENGTH);};// Add `LazyWrapper` methods to `lodash.prototype`.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var checkIteratee=/^(?:filter|find|map|reject)|While$/.test(methodName),isTaker=/^(?:head|last)$/.test(methodName),lodashFunc=lodash[isTaker?'take'+(methodName=='last'?'Right':''):methodName],retUnwrapped=isTaker||/^find/.test(methodName);if(!lodashFunc){return;}lodash.prototype[methodName]=function(){var value=this.__wrapped__,args=isTaker?[1]:arguments,isLazy=value instanceof LazyWrapper,iteratee=args[0],useLazy=isLazy||isArray(value);var interceptor=function(value){var result=lodashFunc.apply(lodash,arrayPush([value],args));return isTaker&&chainAll?result[0]:result;};if(useLazy&&checkIteratee&&typeof iteratee=='function'&&iteratee.length!=1){// Avoid lazy use if the iteratee has a "length" value other than `1`.
isLazy=useLazy=false;}var chainAll=this.__chain__,isHybrid=!!this.__actions__.length,isUnwrapped=retUnwrapped&&!chainAll,onlyLazy=isLazy&&!isHybrid;if(!retUnwrapped&&useLazy){value=onlyLazy?value:new LazyWrapper(this);var result=func.apply(value,args);result.__actions__.push({'func':thru,'args':[interceptor],'thisArg':undefined$1});return new LodashWrapper(result,chainAll);}if(isUnwrapped&&onlyLazy){return func.apply(this,args);}result=this.thru(interceptor);return isUnwrapped?isTaker?result.value()[0]:result.value():result;};});// Add `Array` methods to `lodash.prototype`.
arrayEach(['pop','push','shift','sort','splice','unshift'],function(methodName){var func=arrayProto[methodName],chainName=/^(?:push|sort|unshift)$/.test(methodName)?'tap':'thru',retUnwrapped=/^(?:pop|shift)$/.test(methodName);lodash.prototype[methodName]=function(){var args=arguments;if(retUnwrapped&&!this.__chain__){var value=this.value();return func.apply(isArray(value)?value:[],args);}return this[chainName](function(value){return func.apply(isArray(value)?value:[],args);});};});// Map minified method names to their real names.
baseForOwn(LazyWrapper.prototype,function(func,methodName){var lodashFunc=lodash[methodName];if(lodashFunc){var key=lodashFunc.name+'';if(!hasOwnProperty.call(realNames,key)){realNames[key]=[];}realNames[key].push({'name':methodName,'func':lodashFunc});}});realNames[createHybrid(undefined$1,WRAP_BIND_KEY_FLAG).name]=[{'name':'wrapper','func':undefined$1}];// Add methods to `LazyWrapper`.
LazyWrapper.prototype.clone=lazyClone;LazyWrapper.prototype.reverse=lazyReverse;LazyWrapper.prototype.value=lazyValue;// Add chain sequence methods to the `lodash` wrapper.
lodash.prototype.at=wrapperAt;lodash.prototype.chain=wrapperChain;lodash.prototype.commit=wrapperCommit;lodash.prototype.next=wrapperNext;lodash.prototype.plant=wrapperPlant;lodash.prototype.reverse=wrapperReverse;lodash.prototype.toJSON=lodash.prototype.valueOf=lodash.prototype.value=wrapperValue;// Add lazy aliases.
lodash.prototype.first=lodash.prototype.head;if(symIterator){lodash.prototype[symIterator]=wrapperToIterator;}return lodash;};/*--------------------------------------------------------------------------*/ // Export lodash.
var _=runInContext();// Some AMD build optimizers, like r.js, check for condition patterns like:
if(freeModule){// Export for Node.js.
(freeModule.exports=_)._=_;// Export for CommonJS support.
freeExports._=_;}else {// Export to the global object.
root._=_;}}).call(commonjsGlobal);
});

function createStore(table, initialState = {}) {
  if (!table) {
    throw new Error('Table is required.');
  }

  const store = useStore(); // fix https://github.com/ElemeFE/element/issues/14075
  // related pr https://github.com/ElemeFE/element/pull/14146

  store.toggleAllSelection = lodash.debounce(store._toggleAllSelection, 10);
  Object.keys(initialState).forEach(key => {
    store.states[key].value = initialState[key];
  });
  return store;
}

/**
 * Copyright 2004-present Facebook. All Rights Reserved.
 *
 * @providesModule UserAgent_DEPRECATED
 */

/**
 *  Provides entirely client-side User Agent and OS detection. You should prefer
 *  the non-deprecated UserAgent module when possible, which exposes our
 *  authoritative server-side PHP-based detection to the client.
 *
 *  Usage is straightforward:
 *
 *    if (UserAgent_DEPRECATED.ie()) {
 *      //  IE
 *    }
 *
 *  You can also do version checks:
 *
 *    if (UserAgent_DEPRECATED.ie() >= 7) {
 *      //  IE7 or better
 *    }
 *
 *  The browser functions will return NaN if the browser does not match, so
 *  you can also do version compares the other way:
 *
 *    if (UserAgent_DEPRECATED.ie() < 7) {
 *      //  IE6 or worse
 *    }
 *
 *  Note that the version is a float and may include a minor version number,
 *  so you should always use range operators to perform comparisons, not
 *  strict equality.
 *
 *  **Note:** You should **strongly** prefer capability detection to browser
 *  version detection where it's reasonable:
 *
 *    http://www.quirksmode.org/js/support.html
 *
 *  Further, we have a large number of mature wrapper functions and classes
 *  which abstract away many browser irregularities. Check the documentation,
 *  grep for things, or ask on javascript@lists.facebook.com before writing yet
 *  another copy of "event || window.event".
 *
 */
var _populated = false; // Browsers

var _ie, _firefox, _opera, _webkit, _chrome; // Actual IE browser for compatibility mode


var _ie_real_version; // Platforms


var _osx, _windows, _linux, _android; // Architectures


var _win64; // Devices


var _iphone, _ipad, _native;

var _mobile;

function _populate() {
  if (_populated) {
    return;
  }

  _populated = true; // To work around buggy JS libraries that can't handle multi-digit
  // version numbers, Opera 10's user agent string claims it's Opera
  // 9, then later includes a Version/X.Y field:
  //
  // Opera/9.80 (foo) Presto/2.2.15 Version/10.10

  var uas = navigator.userAgent;
  var agent = /(?:MSIE.(\d+\.\d+))|(?:(?:Firefox|GranParadiso|Iceweasel).(\d+\.\d+))|(?:Opera(?:.+Version.|.)(\d+\.\d+))|(?:AppleWebKit.(\d+(?:\.\d+)?))|(?:Trident\/\d+\.\d+.*rv:(\d+\.\d+))/.exec(uas);
  var os = /(Mac OS X)|(Windows)|(Linux)/.exec(uas);
  _iphone = /\b(iPhone|iP[ao]d)/.exec(uas);
  _ipad = /\b(iP[ao]d)/.exec(uas);
  _android = /Android/i.exec(uas);
  _native = /FBAN\/\w+;/i.exec(uas);
  _mobile = /Mobile/i.exec(uas); // Note that the IE team blog would have you believe you should be checking
  // for 'Win64; x64'.  But MSDN then reveals that you can actually be coming
  // from either x64 or ia64;  so ultimately, you should just check for Win64
  // as in indicator of whether you're in 64-bit IE.  32-bit IE on 64-bit
  // Windows will send 'WOW64' instead.

  _win64 = !!/Win64/.exec(uas);

  if (agent) {
    _ie = agent[1] ? parseFloat(agent[1]) : agent[5] ? parseFloat(agent[5]) : NaN; // IE compatibility mode

    if (_ie && document && document.documentMode) {
      _ie = document.documentMode;
    } // grab the "true" ie version from the trident token if available


    var trident = /(?:Trident\/(\d+.\d+))/.exec(uas);
    _ie_real_version = trident ? parseFloat(trident[1]) + 4 : _ie;
    _firefox = agent[2] ? parseFloat(agent[2]) : NaN;
    _opera = agent[3] ? parseFloat(agent[3]) : NaN;
    _webkit = agent[4] ? parseFloat(agent[4]) : NaN;

    if (_webkit) {
      // We do not add the regexp to the above test, because it will always
      // match 'safari' only since 'AppleWebKit' appears before 'Chrome' in
      // the userAgent string.
      agent = /(?:Chrome\/(\d+\.\d+))/.exec(uas);
      _chrome = agent && agent[1] ? parseFloat(agent[1]) : NaN;
    } else {
      _chrome = NaN;
    }
  } else {
    _ie = _firefox = _opera = _chrome = _webkit = NaN;
  }

  if (os) {
    if (os[1]) {
      // Detect OS X version.  If no version number matches, set _osx to true.
      // Version examples:  10, 10_6_1, 10.7
      // Parses version number as a float, taking only first two sets of
      // digits.  If only one set of digits is found, returns just the major
      // version number.
      var ver = /(?:Mac OS X (\d+(?:[._]\d+)?))/.exec(uas);
      _osx = ver ? parseFloat(ver[1].replace('_', '.')) : true;
    } else {
      _osx = false;
    }

    _windows = !!os[2];
    _linux = !!os[3];
  } else {
    _osx = _windows = _linux = false;
  }
}

var UserAgent_DEPRECATED = {
  /**
   *  Check if the UA is Internet Explorer.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  ie: function () {
    return _populate() || _ie;
  },

  /**
   * Check if we're in Internet Explorer compatibility mode.
   *
   * @return bool true if in compatibility mode, false if
   * not compatibility mode or not ie
   */
  ieCompatibilityMode: function () {
    return _populate() || _ie_real_version > _ie;
  },

  /**
   * Whether the browser is 64-bit IE.  Really, this is kind of weak sauce;  we
   * only need this because Skype can't handle 64-bit IE yet.  We need to remove
   * this when we don't need it -- tracked by #601957.
   */
  ie64: function () {
    return UserAgent_DEPRECATED.ie() && _win64;
  },

  /**
   *  Check if the UA is Firefox.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  firefox: function () {
    return _populate() || _firefox;
  },

  /**
   *  Check if the UA is Opera.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  opera: function () {
    return _populate() || _opera;
  },

  /**
   *  Check if the UA is WebKit.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  webkit: function () {
    return _populate() || _webkit;
  },

  /**
   *  For Push
   *  WILL BE REMOVED VERY SOON. Use UserAgent_DEPRECATED.webkit
   */
  safari: function () {
    return UserAgent_DEPRECATED.webkit();
  },

  /**
   *  Check if the UA is a Chrome browser.
   *
   *
   *  @return float|NaN Version number (if match) or NaN.
   */
  chrome: function () {
    return _populate() || _chrome;
  },

  /**
   *  Check if the user is running Windows.
   *
   *  @return bool `true' if the user's OS is Windows.
   */
  windows: function () {
    return _populate() || _windows;
  },

  /**
   *  Check if the user is running Mac OS X.
   *
   *  @return float|bool   Returns a float if a version number is detected,
   *                       otherwise true/false.
   */
  osx: function () {
    return _populate() || _osx;
  },

  /**
   * Check if the user is running Linux.
   *
   * @return bool `true' if the user's OS is some flavor of Linux.
   */
  linux: function () {
    return _populate() || _linux;
  },

  /**
   * Check if the user is running on an iPhone or iPod platform.
   *
   * @return bool `true' if the user is running some flavor of the
   *    iPhone OS.
   */
  iphone: function () {
    return _populate() || _iphone;
  },
  mobile: function () {
    return _populate() || _iphone || _ipad || _android || _mobile;
  },
  nativeApp: function () {
    // webviews inside of the native apps
    return _populate() || _native;
  },
  android: function () {
    return _populate() || _android;
  },
  ipad: function () {
    return _populate() || _ipad;
  }
};
var UserAgent_DEPRECATED_1 = UserAgent_DEPRECATED;

/**
 * Copyright (c) 2015, Facebook, Inc.
 * All rights reserved.
 *
 * This source code is licensed under the BSD-style license found in the
 * LICENSE file in the root directory of this source tree. An additional grant
 * of patent rights can be found in the PATENTS file in the same directory.
 *
 * @providesModule ExecutionEnvironment
 */

var canUseDOM = !!(typeof window !== 'undefined' && window.document && window.document.createElement);
/**
 * Simple, lightweight module assisting with the detection and context of
 * Worker. Helps avoid circular dependencies and allows code to reason about
 * whether or not they are in a Worker, even if they never include the main
 * `ReactWorker` dependency.
 */

var ExecutionEnvironment = {
  canUseDOM: canUseDOM,
  canUseWorkers: typeof Worker !== 'undefined',
  canUseEventListeners: canUseDOM && !!(window.addEventListener || window.attachEvent),
  canUseViewport: canUseDOM && !!window.screen,
  isInWorker: !canUseDOM // For now, this is true - might change in the future.

};
var ExecutionEnvironment_1 = ExecutionEnvironment;

var useHasFeature;

if (ExecutionEnvironment_1.canUseDOM) {
  useHasFeature = document.implementation && document.implementation.hasFeature && // always returns true in newer browsers as per the standard.
  // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
  document.implementation.hasFeature('', '') !== true;
}
/**
 * Checks if an event is supported in the current execution environment.
 *
 * NOTE: This will not work correctly for non-generic events such as `change`,
 * `reset`, `load`, `error`, and `select`.
 *
 * Borrows from Modernizr.
 *
 * @param {string} eventNameSuffix Event name, e.g. "click".
 * @param {?boolean} capture Check if the capture phase is supported.
 * @return {boolean} True if the event is supported.
 * @internal
 * @license Modernizr 3.0.0pre (Custom Build) | MIT
 */


function isEventSupported(eventNameSuffix, capture) {
  if (!ExecutionEnvironment_1.canUseDOM || capture && !('addEventListener' in document)) {
    return false;
  }

  var eventName = 'on' + eventNameSuffix;
  var isSupported = (eventName in document);

  if (!isSupported) {
    var element = document.createElement('div');
    element.setAttribute(eventName, 'return;');
    isSupported = typeof element[eventName] === 'function';
  }

  if (!isSupported && useHasFeature && eventNameSuffix === 'wheel') {
    // This is the only way to test support for the `wheel` event in IE9+.
    isSupported = document.implementation.hasFeature('Events.wheel', '3.0');
  }

  return isSupported;
}

var isEventSupported_1 = isEventSupported;

// Reasonable defaults


var PIXEL_STEP = 10;
var LINE_HEIGHT = 40;
var PAGE_HEIGHT = 800;
/**
 * Mouse wheel (and 2-finger trackpad) support on the web sucks.  It is
 * complicated, thus this doc is long and (hopefully) detailed enough to answer
 * your questions.
 *
 * If you need to react to the mouse wheel in a predictable way, this code is
 * like your bestest friend. * hugs *
 *
 * As of today, there are 4 DOM event types you can listen to:
 *
 *   'wheel'                -- Chrome(31+), FF(17+), IE(9+)
 *   'mousewheel'           -- Chrome, IE(6+), Opera, Safari
 *   'MozMousePixelScroll'  -- FF(3.5 only!) (2010-2013) -- don't bother!
 *   'DOMMouseScroll'       -- FF(0.9.7+) since 2003
 *
 * So what to do?  The is the best:
 *
 *   normalizeWheel.getEventType();
 *
 * In your event callback, use this code to get sane interpretation of the
 * deltas.  This code will return an object with properties:
 *
 *   spinX   -- normalized spin speed (use for zoom) - x plane
 *   spinY   -- " - y plane
 *   pixelX  -- normalized distance (to pixels) - x plane
 *   pixelY  -- " - y plane
 *
 * Wheel values are provided by the browser assuming you are using the wheel to
 * scroll a web page by a number of lines or pixels (or pages).  Values can vary
 * significantly on different platforms and browsers, forgetting that you can
 * scroll at different speeds.  Some devices (like trackpads) emit more events
 * at smaller increments with fine granularity, and some emit massive jumps with
 * linear speed or acceleration.
 *
 * This code does its best to normalize the deltas for you:
 *
 *   - spin is trying to normalize how far the wheel was spun (or trackpad
 *     dragged).  This is super useful for zoom support where you want to
 *     throw away the chunky scroll steps on the PC and make those equal to
 *     the slow and smooth tiny steps on the Mac. Key data: This code tries to
 *     resolve a single slow step on a wheel to 1.
 *
 *   - pixel is normalizing the desired scroll delta in pixel units.  You'll
 *     get the crazy differences between browsers, but at least it'll be in
 *     pixels!
 *
 *   - positive value indicates scrolling DOWN/RIGHT, negative UP/LEFT.  This
 *     should translate to positive value zooming IN, negative zooming OUT.
 *     This matches the newer 'wheel' event.
 *
 * Why are there spinX, spinY (or pixels)?
 *
 *   - spinX is a 2-finger side drag on the trackpad, and a shift + wheel turn
 *     with a mouse.  It results in side-scrolling in the browser by default.
 *
 *   - spinY is what you expect -- it's the classic axis of a mouse wheel.
 *
 *   - I dropped spinZ/pixelZ.  It is supported by the DOM 3 'wheel' event and
 *     probably is by browsers in conjunction with fancy 3D controllers .. but
 *     you know.
 *
 * Implementation info:
 *
 * Examples of 'wheel' event if you scroll slowly (down) by one step with an
 * average mouse:
 *
 *   OS X + Chrome  (mouse)     -    4   pixel delta  (wheelDelta -120)
 *   OS X + Safari  (mouse)     -  N/A   pixel delta  (wheelDelta  -12)
 *   OS X + Firefox (mouse)     -    0.1 line  delta  (wheelDelta  N/A)
 *   Win8 + Chrome  (mouse)     -  100   pixel delta  (wheelDelta -120)
 *   Win8 + Firefox (mouse)     -    3   line  delta  (wheelDelta -120)
 *
 * On the trackpad:
 *
 *   OS X + Chrome  (trackpad)  -    2   pixel delta  (wheelDelta   -6)
 *   OS X + Firefox (trackpad)  -    1   pixel delta  (wheelDelta  N/A)
 *
 * On other/older browsers.. it's more complicated as there can be multiple and
 * also missing delta values.
 *
 * The 'wheel' event is more standard:
 *
 * http://www.w3.org/TR/DOM-Level-3-Events/#events-wheelevents
 *
 * The basics is that it includes a unit, deltaMode (pixels, lines, pages), and
 * deltaX, deltaY and deltaZ.  Some browsers provide other values to maintain
 * backward compatibility with older events.  Those other values help us
 * better normalize spin speed.  Example of what the browsers provide:
 *
 *                          | event.wheelDelta | event.detail
 *        ------------------+------------------+--------------
 *          Safari v5/OS X  |       -120       |       0
 *          Safari v5/Win7  |       -120       |       0
 *         Chrome v17/OS X  |       -120       |       0
 *         Chrome v17/Win7  |       -120       |       0
 *                IE9/Win7  |       -120       |   undefined
 *         Firefox v4/OS X  |     undefined    |       1
 *         Firefox v4/Win7  |     undefined    |       3
 *
 */

function normalizeWheel(
/*object*/
event)
/*object*/
{
  var sX = 0,
      sY = 0,
      // spinX, spinY
  pX = 0,
      pY = 0; // pixelX, pixelY
  // Legacy

  if ('detail' in event) {
    sY = event.detail;
  }

  if ('wheelDelta' in event) {
    sY = -event.wheelDelta / 120;
  }

  if ('wheelDeltaY' in event) {
    sY = -event.wheelDeltaY / 120;
  }

  if ('wheelDeltaX' in event) {
    sX = -event.wheelDeltaX / 120;
  } // side scrolling on FF with DOMMouseScroll


  if ('axis' in event && event.axis === event.HORIZONTAL_AXIS) {
    sX = sY;
    sY = 0;
  }

  pX = sX * PIXEL_STEP;
  pY = sY * PIXEL_STEP;

  if ('deltaY' in event) {
    pY = event.deltaY;
  }

  if ('deltaX' in event) {
    pX = event.deltaX;
  }

  if ((pX || pY) && event.deltaMode) {
    if (event.deltaMode == 1) {
      // delta in LINE units
      pX *= LINE_HEIGHT;
      pY *= LINE_HEIGHT;
    } else {
      // delta in PAGE units
      pX *= PAGE_HEIGHT;
      pY *= PAGE_HEIGHT;
    }
  } // Fall-back if spin cannot be determined


  if (pX && !sX) {
    sX = pX < 1 ? -1 : 1;
  }

  if (pY && !sY) {
    sY = pY < 1 ? -1 : 1;
  }

  return {
    spinX: sX,
    spinY: sY,
    pixelX: pX,
    pixelY: pY
  };
}
/**
 * The best combination if you prefer spinX + spinY normalization.  It favors
 * the older DOMMouseScroll for Firefox, as FF does not include wheelDelta with
 * 'wheel' event, making spin speed determination impossible.
 */


normalizeWheel.getEventType = function ()
/*string*/
{
  return UserAgent_DEPRECATED_1.firefox() ? 'DOMMouseScroll' : isEventSupported_1('wheel') ? 'wheel' : 'mousewheel';
};

var normalizeWheel_1 = normalizeWheel;

var normalizeWheel$1 = normalizeWheel_1;

const mousewheelEventName = isFirefox() ? 'DOMMouseScroll' : 'mousewheel';

const mousewheel = function (element, callback) {
  if (element && element.addEventListener) {
    element.addEventListener(mousewheelEventName, function (event) {
      const normalized = normalizeWheel$1(event);
      callback && callback(event, normalized);
    }, {
      passive: true
    });
  }
};

var Mousewheel = {
  beforeMount(el, binding) {
    mousewheel(el, binding.value);
  }

};

class TableLayout {
  constructor(options) {
    this.observers = [];
    this.table = null;
    this.store = null;
    this.columns = [];
    this.fit = true;
    this.showHeader = true;
    this.height = ref(null);
    this.scrollX = ref(false);
    this.scrollY = ref(false);
    this.bodyWidth = ref(null);
    this.fixedWidth = ref(null);
    this.rightFixedWidth = ref(null);
    this.tableHeight = ref(null);
    this.headerHeight = ref(44);
    this.appendHeight = ref(0);
    this.footerHeight = ref(44);
    this.viewportHeight = ref(null);
    this.bodyHeight = ref(null);
    this.fixedBodyHeight = ref(null);
    this.gutterWidth = getScrollBarWidth();

    for (const name in options) {
      // eslint-disable-next-line no-prototype-builtins
      if (options.hasOwnProperty(name)) {
        if (isRef(this[name])) {
          this[name].value = options[name];
        } else {
          this[name] = options[name];
        }
      }
    }

    if (!this.table) {
      throw new Error('table is required for Table Layout');
    }

    if (!this.store) {
      throw new Error('store is required for Table Layout');
    }
  }

  updateScrollY() {
    const height = this.height.value;
    if (height === null) return false;
    const bodyWrapper = this.table.refs.bodyWrapper;

    if (this.table.vnode.el && bodyWrapper) {
      const body = bodyWrapper.querySelector('.el-table__body');
      const prevScrollY = this.scrollY.value;
      const scrollY = body.offsetHeight > this.bodyHeight.value;
      this.scrollY.value = scrollY;
      return prevScrollY !== scrollY;
    }

    return false;
  }

  setHeight(value, prop = 'height') {
    if (typeof window === undefined) return;
    const el = this.table.vnode.el;
    value = parseHeight(value);
    this.height.value = Number(value);
    if (!el && (value || value === 0)) return nextTick(() => this.setHeight(value, prop));

    if (typeof value === 'number') {
      el.style[prop] = value + 'px';
      this.updateElsHeight();
    } else if (typeof value === 'string') {
      el.style[prop] = value;
      this.updateElsHeight();
    }
  }

  setMaxHeight(value) {
    this.setHeight(value, 'max-height');
  }

  getFlattenColumns() {
    const flattenColumns = [];
    const columns = this.table.store.states.columns.value;
    columns.forEach(column => {
      if (column.isColumnGroup) {
        // eslint-disable-next-line prefer-spread
        flattenColumns.push.apply(flattenColumns, column.columns);
      } else {
        flattenColumns.push(column);
      }
    });
    return flattenColumns;
  }

  updateElsHeight() {
    if (!this.table.$ready) return nextTick(() => this.updateElsHeight());
    const {
      headerWrapper,
      appendWrapper,
      footerWrapper
    } = this.table.refs;
    this.appendHeight.value = appendWrapper ? appendWrapper.offsetHeight : 0;
    if (this.showHeader && !headerWrapper) return; // fix issue (https://github.com/ElemeFE/element/pull/16956)

    const headerTrElm = headerWrapper ? headerWrapper.querySelector('.el-table__header tr') : null;
    const noneHeader = this.headerDisplayNone(headerTrElm);
    const headerHeight = this.headerHeight.value = !this.showHeader ? 0 : headerWrapper.offsetHeight;

    if (this.showHeader && !noneHeader && headerWrapper.offsetWidth > 0 && (this.table.store.states.columns.value || []).length > 0 && headerHeight < 2) {
      return nextTick(() => this.updateElsHeight());
    }

    const tableHeight = this.tableHeight.value = this.table.vnode.el.clientHeight;
    const footerHeight = this.footerHeight.value = footerWrapper ? footerWrapper.offsetHeight : 0;

    if (this.height.value !== null) {
      this.bodyHeight.value = tableHeight - headerHeight - footerHeight + (footerWrapper ? 1 : 0);
    }

    this.fixedBodyHeight.value = this.scrollX.value ? this.bodyHeight.value - this.gutterWidth : this.bodyHeight.value;
    const noData = !(this.store.states.data.value && this.store.states.data.value.length);
    this.viewportHeight.value = this.scrollX.value ? tableHeight - (noData ? 0 : this.gutterWidth) : tableHeight;
    this.updateScrollY();
    this.notifyObservers('scrollable');
  }

  headerDisplayNone(elm) {
    if (!elm) return true;
    let headerChild = elm;

    while (headerChild.tagName !== 'DIV') {
      if (getComputedStyle(headerChild).display === 'none') {
        return true;
      }

      headerChild = headerChild.parentElement;
    }

    return false;
  }

  updateColumnsWidth() {
    if (typeof window === undefined) return;
    const fit = this.fit;
    const bodyWidth = this.table.vnode.el.clientWidth;
    let bodyMinWidth = 0;
    const flattenColumns = this.getFlattenColumns();
    const flexColumns = flattenColumns.filter(column => typeof column.width !== 'number');
    flattenColumns.forEach(column => {
      // Clean those columns whose width changed from flex to unflex
      if (typeof column.width === 'number' && column.realWidth) column.realWidth = null;
    });

    if (flexColumns.length > 0 && fit) {
      flattenColumns.forEach(column => {
        bodyMinWidth += column.width || column.minWidth || 80;
      });
      const scrollYWidth = this.scrollY.value ? this.gutterWidth : 0;

      if (bodyMinWidth <= bodyWidth - scrollYWidth) {
        // DON'T HAVE SCROLL BAR
        this.scrollX.value = false;
        const totalFlexWidth = bodyWidth - scrollYWidth - bodyMinWidth;

        if (flexColumns.length === 1) {
          flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth;
        } else {
          const allColumnsWidth = flexColumns.reduce((prev, column) => prev + (column.minWidth || 80), 0);
          const flexWidthPerPixel = totalFlexWidth / allColumnsWidth;
          let noneFirstWidth = 0;
          flexColumns.forEach((column, index) => {
            if (index === 0) return;
            const flexWidth = Math.floor((column.minWidth || 80) * flexWidthPerPixel);
            noneFirstWidth += flexWidth;
            column.realWidth = (column.minWidth || 80) + flexWidth;
          });
          flexColumns[0].realWidth = (flexColumns[0].minWidth || 80) + totalFlexWidth - noneFirstWidth;
        }
      } else {
        // HAVE HORIZONTAL SCROLL BAR
        this.scrollX.value = true;
        flexColumns.forEach(function (column) {
          column.realWidth = column.minWidth;
        });
      }

      this.bodyWidth.value = Math.max(bodyMinWidth, bodyWidth);
      this.table.state.resizeState.value.width = this.bodyWidth.value;
    } else {
      flattenColumns.forEach(column => {
        if (!column.width && !column.minWidth) {
          column.realWidth = 80;
        } else {
          column.realWidth = column.width || column.minWidth;
        }

        bodyMinWidth += column.realWidth;
      });
      this.scrollX.value = bodyMinWidth > bodyWidth;
      this.bodyWidth.value = bodyMinWidth;
    }

    const fixedColumns = this.store.states.fixedColumns.value;

    if (fixedColumns.length > 0) {
      let fixedWidth = 0;
      fixedColumns.forEach(function (column) {
        fixedWidth += column.realWidth || column.width;
      });
      this.fixedWidth.value = fixedWidth;
    }

    const rightFixedColumns = this.store.states.rightFixedColumns.value;

    if (rightFixedColumns.length > 0) {
      let rightFixedWidth = 0;
      rightFixedColumns.forEach(function (column) {
        rightFixedWidth += column.realWidth || column.width;
      });
      this.rightFixedWidth.value = rightFixedWidth;
    }

    this.notifyObservers('columns');
    this.updateElsHeight();
  }

  addObserver(observer) {
    this.observers.push(observer);
  }

  removeObserver(observer) {
    const index = this.observers.indexOf(observer);

    if (index !== -1) {
      this.observers.splice(index, 1);
    }
  }

  notifyObservers(event) {
    const observers = this.observers;
    observers.forEach(observer => {
      var _observer$state, _observer$state2;

      switch (event) {
        case 'columns':
          (_observer$state = observer.state) === null || _observer$state === void 0 ? void 0 : _observer$state.onColumnsChange(this);
          break;

        case 'scrollable':
          (_observer$state2 = observer.state) === null || _observer$state2 === void 0 ? void 0 : _observer$state2.onScrollableChange(this);
          break;

        default:
          throw new Error(`Table Layout don't have event ${event}.`);
      }
    });
  }

}

var dropdowns = [];
!(typeof window === 'undefined') && document.addEventListener('click', function (event) {
  dropdowns.forEach(function (dropdown) {
    var target = event.target;
    if (!dropdown || !dropdown.$el) return;

    if (target === dropdown.$el || dropdown.$el.contains(target)) {
      return;
    }

    dropdown.handleOutsideClick && dropdown.handleOutsideClick(event);
  });
});
var Dropdown = {
  open(instance) {
    if (instance) {
      dropdowns.push(instance);
    }
  },

  close(instance) {
    var index = dropdowns.indexOf(instance);

    if (index !== -1) {
      dropdowns.splice(instance, 1);
    }
  }

};

var script$N = {
  name: 'ElTableFilterPanel',
  mixins: [Popper$1, Locale],
  directives: {
    Clickoutside
  },
  components: {
    ElCheckbox: script$d,
    ElCheckboxGroup: script$f,
    ElScrollbar
  },
  props: {
    placement: {
      type: String,
      default: 'bottom-end'
    }
  },
  methods: {
    isActive(filter) {
      return filter.value === this.filterValue;
    },

    handleOutsideClick() {
      setTimeout(() => {
        this.showPopper = false;
      }, 16);
    },

    handleConfirm() {
      this.confirmFilter(this.filteredValue);
      this.handleOutsideClick();
    },

    handleReset() {
      this.filteredValue = [];
      this.confirmFilter(this.filteredValue);
      this.handleOutsideClick();
    },

    handleSelect(filterValue) {
      this.filterValue = filterValue;

      if (typeof filterValue !== 'undefined' && filterValue !== null) {
        this.confirmFilter(this.filteredValue);
      } else {
        this.confirmFilter([]);
      }

      this.handleOutsideClick();
    },

    confirmFilter(filteredValue) {
      this.table.store.commit('filterChange', {
        column: this.column,
        values: filteredValue
      });
      this.table.store.updateAllSelected();
    }

  },

  data() {
    return {
      table: null,
      cell: null,
      column: null
    };
  },

  computed: {
    filters() {
      return this.column && this.column.filters;
    },

    filterValue: {
      get() {
        return (this.column.filteredValue || [])[0];
      },

      set(value) {
        if (this.filteredValue) {
          if (typeof value !== 'undefined' && value !== null) {
            this.filteredValue.splice(0, 1, value);
          } else {
            this.filteredValue.splice(0, 1);
          }
        }
      }

    },
    filteredValue: {
      get() {
        if (this.column) {
          return this.column.filteredValue || [];
        }

        return [];
      },

      set(value) {
        if (this.column) {
          this.column.filteredValue = value;
        }
      }

    },

    multiple() {
      if (this.column) {
        return this.column.filterMultiple;
      }

      return true;
    }

  },

  mounted() {
    this.popperElm = this.$el;
    this.referenceElm = this.cell;
    this.table.bodyWrapper.addEventListener('scroll', () => {
      this.updatePopper();
    });
    this.$watch('showPopper', value => {
      if (this.column) this.column.filterOpened = value;

      if (value) {
        Dropdown.open(this);
      } else {
        Dropdown.close(this);
      }
    });
  },

  watch: {
    showPopper(val) {
      if (val === true && parseInt(this.popperJS._popper.style.zIndex, 10) < PopupManager.zIndex) {
        this.popperJS._popper.style.zIndex = PopupManager.nextZIndex();
      }
    }

  }
};

const _hoisted_1$o = {
  key: 0,
  class: "el-table-filter"
};
const _hoisted_2$g = { class: "el-table-filter__content" };
const _hoisted_3$c = { class: "el-table-filter__bottom" };
const _hoisted_4$6 = {
  key: 1,
  class: "el-table-filter"
};
const _hoisted_5$6 = { class: "el-table-filter__list" };

function render$J(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_checkbox_group = resolveComponent("el-checkbox-group");
  const _component_el_scrollbar = resolveComponent("el-scrollbar");
  const _directive_clickoutside = resolveDirective("clickoutside");

  return (openBlock(), createBlock(Transition, { name: "el-zoom-in-top" }, {
    default: withCtx(() => [
      ($options.multiple)
        ? withDirectives((openBlock(), createBlock("div", _hoisted_1$o, [
            createVNode("div", _hoisted_2$g, [
              createVNode(_component_el_scrollbar, { "wrap-class": "el-table-filter__wrap" }, {
                default: withCtx(() => [
                  createVNode(_component_el_checkbox_group, {
                    class: "el-table-filter__checkbox-group",
                    modelValue: $options.filteredValue,
                    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => ($options.filteredValue = $event))
                  }, {
                    default: withCtx(() => [
                      (openBlock(true), createBlock(Fragment, null, renderList($options.filters, (filter) => {
                        return (openBlock(), createBlock(_component_el_checkbox, {
                          key: filter.value,
                          label: filter.value
                        }, {
                          default: withCtx(() => [
                            createTextVNode(toDisplayString(filter.text), 1 /* TEXT */)
                          ]),
                          _: 2
                        }, 1032 /* PROPS, DYNAMIC_SLOTS */, ["label"]))
                      }), 128 /* KEYED_FRAGMENT */))
                    ]),
                    _: 1
                  }, 8 /* PROPS */, ["modelValue"])
                ]),
                _: 1
              })
            ]),
            createVNode("div", _hoisted_3$c, [
              createVNode("button", {
                onClick: _cache[2] || (_cache[2] = (...args) => ($options.handleConfirm(...args))),
                class: { 'is-disabled': $options.filteredValue.length === 0 },
                disabled: $options.filteredValue.length === 0
              }, toDisplayString(_ctx.t('el.table.confirmFilter')), 11 /* TEXT, CLASS, PROPS */, ["disabled"]),
              createVNode("button", {
                onClick: _cache[3] || (_cache[3] = (...args) => ($options.handleReset(...args)))
              }, toDisplayString(_ctx.t('el.table.resetFilter')), 1 /* TEXT */)
            ])
          ], 512 /* NEED_PATCH */)), [
            [_directive_clickoutside, $options.handleOutsideClick],
            [vShow, _ctx.showPopper]
          ])
        : withDirectives((openBlock(), createBlock("div", _hoisted_4$6, [
            createVNode("ul", _hoisted_5$6, [
              createVNode("li", {
                class: ["el-table-filter__list-item", {
            'is-active': $options.filterValue === undefined || $options.filterValue === null
          }],
                onClick: _cache[4] || (_cache[4] = $event => ($options.handleSelect(null)))
              }, toDisplayString(_ctx.t('el.table.clearFilter')), 3 /* TEXT, CLASS */),
              (openBlock(true), createBlock(Fragment, null, renderList($options.filters, (filter) => {
                return (openBlock(), createBlock("li", {
                  class: ["el-table-filter__list-item", { 'is-active': $options.isActive(filter) }],
                  label: filter.value,
                  key: filter.value,
                  onClick: $event => ($options.handleSelect(filter.value))
                }, toDisplayString(filter.text), 11 /* TEXT, CLASS, PROPS */, ["label", "onClick"]))
              }), 128 /* KEYED_FRAGMENT */))
            ])
          ], 512 /* NEED_PATCH */)), [
            [_directive_clickoutside, $options.handleOutsideClick],
            [vShow, _ctx.showPopper]
          ])
    ]),
    _: 1
  }))
}

script$N.render = render$J;
script$N.__file = "packages/table/src/filter-panel.vue";

function useLayoutObserver(root) {
  const instance = getCurrentInstance();
  onBeforeMount(() => {
    tableLayout.value.addObserver(instance);
  });
  onMounted(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  onUpdated(() => {
    onColumnsChange(tableLayout.value);
    onScrollableChange(tableLayout.value);
  });
  onUnmounted(() => {
    tableLayout.value.removeObserver(instance);
  });
  const tableLayout = computed(() => {
    const layout = root.layout;

    if (!layout) {
      throw new Error('Can not find table layout.');
    }

    return layout;
  });

  const onColumnsChange = layout => {
    nextTick(() => {
      var _root$vnode$el;

      const cols = (_root$vnode$el = root.vnode.el) === null || _root$vnode$el === void 0 ? void 0 : _root$vnode$el.querySelectorAll('colgroup > col');
      if (!cols || !cols.length) return;
      const flattenColumns = layout.getFlattenColumns();
      const columnsMap = {};
      flattenColumns.forEach(column => {
        columnsMap[column.id] = column;
      });

      for (let i = 0, j = cols.length; i < j; i++) {
        const col = cols[i];
        const name = col.getAttribute('name');
        const column = columnsMap[name];

        if (column) {
          col.setAttribute('width', column.realWidth || column.width);
        }
      }
    });
  };

  const onScrollableChange = layout => {
    nextTick(() => {
      var _root$vnode$el2;

      const cols = (_root$vnode$el2 = root.vnode.el) === null || _root$vnode$el2 === void 0 ? void 0 : _root$vnode$el2.querySelectorAll('colgroup > col[name=gutter]');

      for (let i = 0, j = cols.length; i < j; i++) {
        const col = cols[i];
        col.setAttribute('width', layout.scrollY.value ? layout.gutterWidth : '0');
      }

      const ths = root.vnode.el.querySelectorAll('th.gutter');

      for (let i = 0, j = ths.length; i < j; i++) {
        const th = ths[i];
        th.style.width = layout.scrollY.value ? layout.gutterWidth + 'px' : '0';
        th.style.display = layout.scrollY.value ? '' : 'none';
      }
    });
  };

  return {
    tableLayout: tableLayout.value,
    onColumnsChange,
    onScrollableChange
  };
}

function useEvent$1(props, emit) {
  const instance = getCurrentInstance();
  const parent = instance.parent;

  const handleFilterClick = event => {
    event.stopPropagation();
    return;
  };

  const handleHeaderClick = (event, column) => {
    if (!column.filters && column.sortable) {
      handleSortClick(event, column, false);
    } else if (column.filterable && !column.sortable) {
      handleFilterClick(event);
    }

    parent.emit('header-click', column, event);
  };

  const handleHeaderContextMenu = (event, column) => {
    parent.emit('header-contextmenu', column, event);
  };

  const draggingColumn = ref(null);
  const dragging = ref(false);
  const dragState = ref({});

  const handleMouseDown = (event, column) => {
    if (typeof window === undefined) return;
    if (column.children && column.children.length > 0) return;
    /* istanbul ignore if */

    if (draggingColumn.value && props.border) {
      dragging.value = true;
      const table = parent;
      emit('set-drag-visible', true);
      const tableEl = table.vnode.el;
      const tableLeft = tableEl.getBoundingClientRect().left;
      const columnEl = instance.vnode.el.querySelector(`th.${column.id}`);
      const columnRect = columnEl.getBoundingClientRect();
      const minLeft = columnRect.left - tableLeft + 30;
      addClass(columnEl, 'noclick');
      dragState.value = {
        startMouseLeft: event.clientX,
        startLeft: columnRect.right - tableLeft,
        startColumnLeft: columnRect.left - tableLeft,
        tableLeft
      };
      const resizeProxy = table.refs.resizeProxy;
      resizeProxy.style.left = dragState.value.startLeft + 'px';

      document.onselectstart = function () {
        return false;
      };

      document.ondragstart = function () {
        return false;
      };

      const handleMouseMove = event => {
        const deltaLeft = event.clientX - dragState.value.startMouseLeft;
        const proxyLeft = dragState.value.startLeft + deltaLeft;
        resizeProxy.style.left = Math.max(minLeft, proxyLeft) + 'px';
      };

      const handleMouseUp = () => {
        if (dragging.value) {
          const {
            startColumnLeft,
            startLeft
          } = dragState.value;
          const finalLeft = parseInt(resizeProxy.style.left, 10);
          const columnWidth = finalLeft - startColumnLeft;
          column.width = column.realWidth = columnWidth;
          table.emit('header-dragend', column.width, startLeft - startColumnLeft, column, event);
          props.store.scheduleLayout(false, true);
          document.body.style.cursor = '';
          dragging.value = false;
          draggingColumn.value = null;
          dragState.value = {};
          emit('set-drag-visible', false);
        }

        document.removeEventListener('mousemove', handleMouseMove);
        document.removeEventListener('mouseup', handleMouseUp);
        document.onselectstart = null;
        document.ondragstart = null;
        setTimeout(function () {
          removeClass(columnEl, 'noclick');
        }, 0);
      };

      document.addEventListener('mousemove', handleMouseMove);
      document.addEventListener('mouseup', handleMouseUp);
    }
  };

  const handleMouseMove = (event, column) => {
    if (column.children && column.children.length > 0) return;
    let target = event.target;

    while (target && target.tagName !== 'TH') {
      target = target.parentNode;
    }

    if (!column || !column.resizable) return;

    if (!dragging.value && props.border) {
      const rect = target.getBoundingClientRect();
      const bodyStyle = document.body.style;

      if (rect.width > 12 && rect.right - event.pageX < 8) {
        bodyStyle.cursor = 'col-resize';

        if (hasClass(target, 'is-sortable')) {
          target.style.cursor = 'col-resize';
        }

        draggingColumn.value = column;
      } else if (!dragging.value) {
        bodyStyle.cursor = '';

        if (hasClass(target, 'is-sortable')) {
          target.style.cursor = 'pointer';
        }

        draggingColumn.value = null;
      }
    }
  };

  const handleMouseOut = () => {
    if (typeof window === undefined) return;
    document.body.style.cursor = '';
  };

  const toggleOrder = ({
    order,
    sortOrders
  }) => {
    if (order === '') return sortOrders[0];
    const index = sortOrders.indexOf(order || null);
    return sortOrders[index > sortOrders.length - 2 ? 0 : index + 1];
  };

  const handleSortClick = (event, column, givenOrder) => {
    event.stopPropagation();
    const order = column.order === givenOrder ? null : givenOrder || toggleOrder(column);
    let target = event.target;

    while (target && target.tagName !== 'TH') {
      target = target.parentNode;
    }

    if (target && target.tagName === 'TH') {
      if (hasClass(target, 'noclick')) {
        removeClass(target, 'noclick');
        return;
      }
    }

    if (!column.sortable) return;
    const states = props.store.states;
    let sortProp = states.sortProp.value;
    let sortOrder;
    const sortingColumn = states.sortingColumn.value;

    if (sortingColumn !== column || sortingColumn === column && sortingColumn.order === null) {
      if (sortingColumn) {
        sortingColumn.order = null;
      }

      states.sortingColumn.value = column;
      sortProp = column.property;
    }

    if (!order) {
      sortOrder = column.order = null;
    } else {
      sortOrder = column.order = order;
    }

    states.sortProp.value = sortProp;
    states.sortOrder.value = sortOrder;
    parent.store.commit('changeSortCondition');
  };

  return {
    handleHeaderClick,
    handleHeaderContextMenu,
    handleMouseDown,
    handleMouseMove,
    handleMouseOut,
    handleSortClick,
    handleFilterClick
  };
}

function useStyle$4(props) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const storeData = parent.store.states;

  const isCellHidden = (index, columns) => {
    let start = 0;

    for (let i = 0; i < index; i++) {
      start += columns[i].colSpan;
    }

    const after = start + columns[index].colSpan - 1;

    if (props.fixed === 'left') {
      return after >= storeData.fixedLeafColumnsLength.value;
    } else if (props.fixed === 'right') {
      return start < storeData.columns.value.length - storeData.rightFixedLeafColumnsLength.value;
    } else {
      return after < storeData.fixedLeafColumnsLength.value || start >= storeData.columns.value.length - storeData.rightFixedLeafColumnsLength.value;
    }
  };

  const getHeaderRowStyle = rowIndex => {
    const headerRowStyle = parent.props.headerRowStyle;

    if (typeof headerRowStyle === 'function') {
      return headerRowStyle.call(null, {
        rowIndex
      });
    }

    return headerRowStyle;
  };

  const getHeaderRowClass = rowIndex => {
    const classes = [];
    const headerRowClassName = parent.props.headerRowClassName;

    if (typeof headerRowClassName === 'string') {
      classes.push(headerRowClassName);
    } else if (typeof headerRowClassName === 'function') {
      classes.push(headerRowClassName.call(null, {
        rowIndex
      }));
    }

    return classes.join(' ');
  };

  const getHeaderCellStyle = (rowIndex, columnIndex, row, column) => {
    const headerCellStyle = parent.props.headerCellStyle;

    if (typeof headerCellStyle === 'function') {
      return headerCellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }

    return headerCellStyle;
  };

  const getHeaderCellClass = (rowIndex, columnIndex, row, column) => {
    const classes = [column.id, column.order, column.headerAlign, column.className, column.labelClassName];

    if (rowIndex === 0 && isCellHidden(columnIndex, row)) {
      classes.push('is-hidden');
    }

    if (!column.children) {
      classes.push('is-leaf');
    }

    if (column.sortable) {
      classes.push('is-sortable');
    }

    const headerCellClassName = parent.props.headerCellClassName;

    if (typeof headerCellClassName === 'string') {
      classes.push(headerCellClassName);
    } else if (typeof headerCellClassName === 'function') {
      classes.push(headerCellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }

    return classes.join(' ');
  };

  return {
    getHeaderRowStyle,
    getHeaderRowClass,
    getHeaderCellStyle,
    getHeaderCellClass
  };
}

const getAllColumns = columns => {
  const result = [];
  columns.forEach(column => {
    if (column.children) {
      result.push(column); // eslint-disable-next-line prefer-spread

      result.push.apply(result, getAllColumns(column.children));
    } else {
      result.push(column);
    }
  });
  return result;
};

const convertToRows = originColumns => {
  let maxLevel = 1;

  const traverse = (column, parent) => {
    if (parent) {
      column.level = parent.level + 1;

      if (maxLevel < column.level) {
        maxLevel = column.level;
      }
    }

    if (column.children) {
      let colSpan = 0;
      column.children.forEach(subColumn => {
        traverse(subColumn, column);
        colSpan += subColumn.colSpan;
      });
      column.colSpan = colSpan;
    } else {
      column.colSpan = 1;
    }
  };

  originColumns.forEach(column => {
    column.level = 1;
    traverse(column, undefined);
  });
  const rows = [];

  for (let i = 0; i < maxLevel; i++) {
    rows.push([]);
  }

  const allColumns = getAllColumns(originColumns);
  allColumns.forEach(column => {
    if (!column.children) {
      column.rowSpan = maxLevel - column.level + 1;
    } else {
      column.rowSpan = 1;
    }

    rows[column.level - 1].push(column);
  });
  return rows;
};

function useUtils(props) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const columnRows = computed(() => {
    return convertToRows(props.store.states.originColumns.value);
  });
  const isGroup = computed(() => {
    const result = columnRows.value.length > 1;
    if (result) parent.state.isGroup.value = true;
    return result;
  });

  const toggleAllSelection = event => {
    event.stopPropagation();
    parent.store.commit('toggleAllSelection');
  };

  return {
    isGroup,
    toggleAllSelection,
    columnRows
  };
}

function hGutter() {
  return h('col', {
    name: 'gutter'
  });
}
function hColgroup(columns, hasGutter) {
  return h('colgroup', {}, [...columns.map(column => h('col', {
    name: column.id,
    key: column.id
  })), hasGutter && hGutter()]);
}

var TableHeader = {
  name: 'ElTableHeader',
  components: {
    ElCheckbox: script$d
  },
  props: {
    fixed: {
      type: String,
      default: ''
    },
    store: {
      required: true,
      type: Object
    },
    border: Boolean,
    defaultSort: {
      type: Object,

      default() {
        return {
          prop: '',
          order: ''
        };
      }

    }
  },

  setup(props, {
    emit
  }) {
    const instance = getCurrentInstance();
    const parent = instance.parent;
    const storeData = parent.store.states;
    const filterPanels = ref({});
    const {
      tableLayout,
      onColumnsChange,
      onScrollableChange
    } = useLayoutObserver(parent);
    const hasGutter = computed(() => {
      return !props.fixed && tableLayout.gutterWidth;
    });
    onMounted(() => {
      nextTick(() => {
        const {
          prop,
          order
        } = props.defaultSort;
        const init = true;
        parent.store.commit('sort', {
          prop,
          order,
          init
        });
      });
    });
    const {
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick
    } = useEvent$1(props, emit);
    const {
      getHeaderRowStyle,
      getHeaderRowClass,
      getHeaderCellStyle,
      getHeaderCellClass
    } = useStyle$4(props);
    const {
      isGroup,
      toggleAllSelection,
      columnRows
    } = useUtils(props);
    instance.state = {
      onColumnsChange,
      onScrollableChange
    }; // eslint-disable-next-line

    instance.filterPanels = filterPanels;
    return {
      columns: storeData.columns,
      filterPanels,
      hasGutter,
      onColumnsChange,
      onScrollableChange,
      columnRows,
      getHeaderRowClass,
      getHeaderRowStyle,
      getHeaderCellClass,
      getHeaderCellStyle,
      handleHeaderClick,
      handleHeaderContextMenu,
      handleMouseDown,
      handleMouseMove,
      handleMouseOut,
      handleSortClick,
      handleFilterClick,
      isGroup,
      toggleAllSelection
    };
  },

  render() {
    return h('table', {
      border: '0',
      cellpadding: '0',
      cellspacing: '0',
      class: 'el-table__header'
    }, [hColgroup(this.columns, this.hasGutter), h('thead', {
      class: {
        'is-group': this.isGroup,
        'has-gutter': this.hasGutter
      }
    }, this.columnRows.map((subColumns, rowIndex) => h('tr', {
      class: this.getHeaderRowClass(rowIndex),
      key: rowIndex,
      style: this.getHeaderRowStyle(rowIndex)
    }, subColumns.map((column, cellIndex) => h('th', {
      class: this.getHeaderCellClass(rowIndex, cellIndex, subColumns, column),
      colspan: column.colSpan,
      key: `${column.id}-thead`,
      rowSpan: column.rowSpan,
      style: this.getHeaderCellStyle(rowIndex, cellIndex, subColumns, column),
      onClick: $event => this.handleHeaderClick($event, column),
      onContextmenu: $event => this.handleHeaderContextMenu($event, column),
      onMousedown: $event => this.handleMouseDown($event, column),
      onMouseMove: $event => this.handleMouseMove($event, column),
      onMouseout: this.handleMouseOut
    }, [h('div', {
      class: ['cell', column.filteredValue && column.filteredValue.length > 0 ? 'highlight' : '', column.labelClassName]
    }, [column.renderHeader ? column.renderHeader({
      column,
      index_: cellIndex,
      store: this.store,
      _self: this.$parent
    }) : column.label, column.sortable && h('span', {
      onClick: $event => this.handleSortClick($event, column),
      class: 'caret-wrapper'
    }, [h('i', {
      onClick: $event => this.handleSortClick($event, column, 'ascending'),
      class: 'sort-caret ascending'
    }), h('i', {
      onClick: $event => this.handleSortClick($event, column, 'descending'),
      class: 'sort-caret descending'
    })]), column.filterable && h(script$N, {
      table: this.$parent,
      store: this.$parent.store,
      placement: column.filterPlacement || 'bottom-start',
      column: column,
      upDataColumn: (key, value) => {
        column[key] = value;
      }
    })])])))))]);
  }

};

function useEvents(props) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const tooltipVisible = ref(false);
  const tooltipContent = ref('');
  const tooltipTrigger = ref(h('div'));

  const handleEvent = (event, row, name) => {
    const table = parent;
    const cell = getCell(event);
    let column;

    if (cell) {
      column = getColumnByCell({
        columns: props.store.states.columns.value
      }, cell);

      if (column) {
        table.emit(`cell-${name}`, row, column, cell, event);
      }
    }

    table.emit(`row-${name}`, row, column, event);
  };

  const handleDoubleClick = (event, row) => {
    handleEvent(event, row, 'dblclick');
  };

  const handleClick = (event, row) => {
    props.store.commit('setCurrentRow', row);
    handleEvent(event, row, 'click');
  };

  const handleContextMenu = (event, row) => {
    handleEvent(event, row, 'contextmenu');
  };

  const handleMouseEnter = lodash.debounce(function (index) {
    props.store.commit('setHoverRow', index);
  }, 30);
  const handleMouseLeave = lodash.debounce(function () {
    props.store.commit('setHoverRow', null);
  }, 30);

  const handleCellMouseEnter = (event, row) => {
    const table = parent;
    const cell = getCell(event);

    if (cell) {
      const column = getColumnByCell({
        columns: props.store.states.columns.value
      }, cell);
      const hoverState = table.hoverState = {
        cell,
        column,
        row
      };
      table.emit('cell-mouse-enter', hoverState.row, hoverState.column, hoverState.cell, event);
    } // 判断是否text-overflow, 如果是就显示tooltip


    const cellChild = event.target.querySelector('.cell');

    if (!(hasClass(cellChild, 'el-tooltip') && cellChild.childNodes.length)) {
      return;
    } // use range width instead of scrollWidth to determine whether the text is overflowing
    // to address a potential FireFox bug: https://bugzilla.mozilla.org/show_bug.cgi?id=1074543#c3


    const range = document.createRange();
    range.setStart(cellChild, 0);
    range.setEnd(cellChild, cellChild.childNodes.length);
    const rangeWidth = range.getBoundingClientRect().width;
    const padding = (parseInt(getStyle(cellChild, 'paddingLeft'), 10) || 0) + (parseInt(getStyle(cellChild, 'paddingRight'), 10) || 0);

    if (rangeWidth + padding > cellChild.offsetWidth || cellChild.scrollWidth > cellChild.offsetWidth) {
      // TODO 会引起整个 Table 的重新渲染，需要优化
      tooltipContent.value = cell.innerText || cell.textContent;
      tooltipVisible.value = true; // TODO 动态绑定触发的元素会导致开发模式下产生警告

      tooltipTrigger.value = cell;
    }
  };

  const handleCellMouseLeave = event => {
    tooltipVisible.value = false;
    const cell = getCell(event);
    if (!cell) return;
    const oldHoverState = parent.hoverState;
    parent.emit('cell-mouse-leave', oldHoverState === null || oldHoverState === void 0 ? void 0 : oldHoverState.row, oldHoverState === null || oldHoverState === void 0 ? void 0 : oldHoverState.column, oldHoverState === null || oldHoverState === void 0 ? void 0 : oldHoverState.cell, event);
  };

  return {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipVisible,
    tooltipContent,
    tooltipTrigger
  };
}

function useStyles(props) {
  const instance = getCurrentInstance();
  const parent = instance.parent;

  const isColumnHidden = index => {
    if (props.fixed === 'left') {
      return index >= props.store.states.fixedLeafColumnsLength.value;
    } else if (props.fixed === 'right') {
      return index < props.store.states.columns.value.length - props.store.states.rightFixedLeafColumnsLength.value;
    } else {
      return index < props.store.states.fixedLeafColumnsLength.value || index >= props.store.states.columns.value.length - props.store.states.rightFixedLeafColumnsLength.value;
    }
  };

  const getRowStyle = (row, rowIndex) => {
    const rowStyle = parent.props.rowStyle;

    if (typeof rowStyle === 'function') {
      return rowStyle.call(null, {
        row,
        rowIndex
      });
    }

    return rowStyle || null;
  };

  const getRowClass = (row, rowIndex) => {
    const classes = ['el-table__row'];

    if (parent.props.highlightCurrentRow && row === props.store.states.currentRow.value) {
      classes.push('current-row');
    }

    if (props.stripe && rowIndex % 2 === 1) {
      classes.push('el-table__row--striped');
    }

    const rowClassName = parent.props.rowClassName;

    if (typeof rowClassName === 'string') {
      classes.push(rowClassName);
    } else if (typeof rowClassName === 'function') {
      classes.push(rowClassName.call(null, {
        row,
        rowIndex
      }));
    }

    if (props.store.states.expandRows.value.indexOf(row) > -1) {
      classes.push('expanded');
    }

    return classes;
  };

  const getCellStyle = (rowIndex, columnIndex, row, column) => {
    const cellStyle = parent.props.cellStyle;

    if (typeof cellStyle === 'function') {
      return cellStyle.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      });
    }

    return cellStyle;
  };

  const getCellClass = (rowIndex, columnIndex, row, column) => {
    const classes = [column.id, column.align, column.className];

    if (isColumnHidden(columnIndex)) {
      classes.push('is-hidden');
    }

    const cellClassName = parent.props.cellClassName;

    if (typeof cellClassName === 'string') {
      classes.push(cellClassName);
    } else if (typeof cellClassName === 'function') {
      classes.push(cellClassName.call(null, {
        rowIndex,
        columnIndex,
        row,
        column
      }));
    }

    return classes.join(' ');
  };

  const getSpan = (row, column, rowIndex, columnIndex) => {
    let rowspan = 1;
    let colspan = 1;
    const fn = parent.props.spanMethod;

    if (typeof fn === 'function') {
      const result = fn({
        row,
        column,
        rowIndex,
        columnIndex
      });

      if (Array.isArray(result)) {
        rowspan = result[0];
        colspan = result[1];
      } else if (typeof result === 'object') {
        rowspan = result.rowspan;
        colspan = result.colspan;
      }
    }

    return {
      rowspan,
      colspan
    };
  };

  const getColspanRealWidth = (columns, colspan, index) => {
    if (colspan < 1) {
      return columns[index].realWidth;
    }

    const widthArr = columns.map(({
      realWidth
    }) => realWidth).slice(index, index + colspan);
    return widthArr.reduce((acc, width) => acc + width, -1);
  };

  return {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth,
    isColumnHidden
  };
}

function useRender(props) {
  const instance = getCurrentInstance();
  const parent = instance.parent;
  const {
    handleDoubleClick,
    handleClick,
    handleContextMenu,
    handleMouseEnter,
    handleMouseLeave,
    handleCellMouseEnter,
    handleCellMouseLeave,
    tooltipVisible,
    tooltipContent,
    tooltipTrigger
  } = useEvents(props);
  const {
    getRowStyle,
    getRowClass,
    getCellStyle,
    getCellClass,
    getSpan,
    getColspanRealWidth
  } = useStyles(props);
  const firstDefaultColumnIndex = computed(() => {
    return arrayFindIndex(props.store.states.columns.value, ({
      type
    }) => type === 'default');
  });

  const getKeyOfRow = (row, index) => {
    const rowKey = parent.props.rowKey;

    if (rowKey) {
      return getRowIdentity(row, rowKey);
    }

    return index;
  };

  const rowRender = (row, index_, treeRowData) => {
    const {
      indent,
      columns
    } = props.store.states;
    const rowClasses = getRowClass(row, index_);
    let display = true;

    if (treeRowData) {
      rowClasses.push('el-table__row--level-' + treeRowData.level);
      display = treeRowData.display;
    }

    const displayStyle = display ? null : {
      display: 'none'
    };
    return h('tr', {
      style: [displayStyle, getRowStyle(row, index_)],
      class: rowClasses,
      key: getKeyOfRow(row, index_),
      onDblclick: $event => handleDoubleClick($event, row),
      onClick: $event => handleClick($event, row),
      onContextmenu: $event => handleContextMenu($event, row),
      onMouseenter: () => handleMouseEnter(index_),
      onMouseleave: handleMouseLeave
    }, columns.value.map((column, cellIndex) => {
      const {
        rowspan,
        colspan
      } = getSpan(row, column, index_, cellIndex);

      if (!rowspan || !colspan) {
        return null;
      }

      const columnData = { ...column
      };
      columnData.realWidth = getColspanRealWidth(columns.value, colspan, cellIndex); // debugger;

      const data = {
        store: props.store,
        _self: props.context || parent,
        column: columnData,
        row,
        index_
      };

      if (cellIndex === firstDefaultColumnIndex.value && treeRowData) {
        data.treeNode = {
          indent: treeRowData.level * indent.value,
          level: treeRowData.level
        };

        if (typeof treeRowData.expanded === 'boolean') {
          data.treeNode.expanded = treeRowData.expanded; // 表明是懒加载

          if ('loading' in treeRowData) {
            data.treeNode.loading = treeRowData.loading;
          }

          if ('noLazyChildren' in treeRowData) {
            data.treeNode.noLazyChildren = treeRowData.noLazyChildren;
          }
        }
      }

      return h('td', {
        style: getCellStyle(index_, cellIndex, row, column),
        class: getCellClass(index_, cellIndex, row, column),
        rowspan,
        colspan,
        onMouseenter: $event => handleCellMouseEnter($event, row),
        onMouseleave: handleCellMouseLeave
      }, [column.renderCell(data)]);
    }));
  };

  const wrappedRowRender = (row, index_) => {
    const store = props.store;
    const {
      isRowExpanded,
      assertRowKey
    } = store;
    const {
      treeData,
      lazyTreeNodeMap,
      childrenColumnName,
      rowKey
    } = store.states;
    const hasExpandColumn = store.states.columns.value.some(({
      type
    }) => type === 'expand');

    if (hasExpandColumn && isRowExpanded(row)) {
      const renderExpanded = parent.renderExpanded;
      const tr = rowRender(row, index_, undefined);

      if (!renderExpanded) {
        console.error('[Element Error]renderExpanded is required.');
        return tr;
      } // 使用二维数组，避免修改 index_


      return [[tr, h('tr', {
        key: 'expanded-row__' + tr.key
      }, [h('td', {
        colspan: store.states.columns.value.length,
        class: 'el-table__expanded-cell'
      }, [renderExpanded({
        row,
        index_,
        store
      })])])]];
    } else if (Object.keys(treeData.value).length) {
      assertRowKey(); // TreeTable 时，rowKey 必须由用户设定，不使用 getKeyOfRow 计算
      // 在调用 rowRender 函数时，仍然会计算 rowKey，不太好的操作

      const key = getRowIdentity(row, rowKey.value);
      let cur = treeData.value[key];
      let treeRowData = null;

      if (cur) {
        treeRowData = {
          expanded: cur.expanded,
          level: cur.level,
          display: true
        };

        if (typeof cur.lazy === 'boolean') {
          if (typeof cur.loaded === 'boolean' && cur.loaded) {
            treeRowData.noLazyChildren = !(cur.children && cur.children.length);
          }

          treeRowData.loading = cur.loading;
        }
      }

      const tmp = [rowRender(row, index_, treeRowData)]; // 渲染嵌套数据

      if (cur) {
        // currentRow 记录的是 index，所以还需主动增加 TreeTable 的 index
        let i = 0;

        const traverse = (children, parent) => {
          if (!(children && children.length && parent)) return;
          children.forEach(node => {
            // 父节点的 display 状态影响子节点的显示状态
            const innerTreeRowData = {
              display: parent.display && parent.expanded,
              level: parent.level + 1,
              expanded: false,
              noLazyChildren: false,
              loading: false
            };
            const childKey = getRowIdentity(node, rowKey.value);

            if (childKey === undefined || childKey === null) {
              throw new Error('for nested data item, row-key is required.');
            }

            cur = { ...treeData.value[childKey]
            }; // 对于当前节点，分成有无子节点两种情况。
            // 如果包含子节点的，设置 expanded 属性。
            // 对于它子节点的 display 属性由它本身的 expanded 与 display 共同决定。

            if (cur) {
              innerTreeRowData.expanded = cur.expanded; // 懒加载的某些节点，level 未知

              cur.level = cur.level || innerTreeRowData.level;
              cur.display = !!(cur.expanded && innerTreeRowData.display);

              if (typeof cur.lazy === 'boolean') {
                if (typeof cur.loaded === 'boolean' && cur.loaded) {
                  innerTreeRowData.noLazyChildren = !(cur.children && cur.children.length);
                }

                innerTreeRowData.loading = cur.loading;
              }
            }

            i++;
            tmp.push(rowRender(node, index_ + i, innerTreeRowData));

            if (cur) {
              const nodes = lazyTreeNodeMap.value[childKey] || node[childrenColumnName.value];
              traverse(nodes, cur);
            }
          });
        }; // 对于 root 节点，display 一定为 true


        cur.display = true;
        const nodes = lazyTreeNodeMap.value[key] || row[childrenColumnName.value];
        traverse(nodes, cur);
      }

      return tmp;
    } else {
      return rowRender(row, index_, undefined);
    }
  };

  return {
    wrappedRowRender,
    tooltipVisible,
    tooltipContent,
    tooltipTrigger
  };
}

var TableBody = {
  name: 'ElTableBody',
  props: {
    store: {
      required: true,
      type: Object
    },
    stripe: Boolean,
    context: {
      default: () => ({}),
      type: Object
    },
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    fixed: {
      type: String,
      default: ''
    },
    highlight: Boolean
  },

  setup(props) {
    const instance = getCurrentInstance();
    const parent = instance.parent;
    const {
      wrappedRowRender,
      tooltipVisible,
      tooltipContent,
      tooltipTrigger
    } = useRender(props);
    const {
      onColumnsChange,
      onScrollableChange
    } = useLayoutObserver(parent);
    watch(props.store.states.hoverRow, (newVal, oldVal) => {
      if (!props.store.states.isComplex.value || typeof window === 'undefined') return;
      let raf = window.requestAnimationFrame;

      if (!raf) {
        raf = fn => window.setTimeout(fn, 16);
      }

      raf(() => {
        const rows = instance.vnode.el.querySelectorAll('.el-table__row');
        const oldRow = rows[oldVal];
        const newRow = rows[newVal];

        if (oldRow) {
          removeClass(oldRow, 'hover-row');
        }

        if (newRow) {
          addClass(newRow, 'hover-row');
        }
      });
    });
    return {
      onColumnsChange,
      onScrollableChange,
      wrappedRowRender,
      tooltipVisible,
      tooltipContent,
      tooltipTrigger
    };
  },

  render() {
    const data = this.store.states.data.value || [];
    return h('table', {
      class: 'el-table__body',
      cellspacing: '0',
      cellpadding: '0',
      border: '0'
    }, [hColgroup(this.store.states.columns.value), h('tbody', {}, [data.reduce((acc, row) => {
      return acc.concat(this.wrappedRowRender(row, acc.length));
    }, []), h(ElTooltip, {
      modelValue: this.tooltipVisible,
      content: this.tooltipContent,
      manual: true,
      effect: this.$parent.tooltipEffect,
      placement: 'top'
    }, {
      default: () => this.tooltipTrigger
    })])]);
  }

};

function useMapState() {
  const instance = getCurrentInstance();
  const table = instance.parent;
  const store = table.store;
  const leftFixedLeafCount = computed(() => {
    return store.states.fixedLeafColumnsLength.value;
  });
  const rightFixedLeafCount = computed(() => {
    return store.states.rightFixedColumns.value.length;
  });
  const columnsCount = computed(() => {
    return store.states.columns.value.length;
  });
  const leftFixedCount = computed(() => {
    return store.states.fixedColumns.value.length;
  });
  const rightFixedCount = computed(() => {
    return store.states.rightFixedColumns.value.length;
  });
  return {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns: store.states.columns
  };
}

function useStyle$5(props) {
  const instance = getCurrentInstance();
  const table = instance.parent;
  const store = table.store;
  const {
    leftFixedLeafCount,
    rightFixedLeafCount,
    columnsCount,
    leftFixedCount,
    rightFixedCount,
    columns
  } = useMapState();
  const hasGutter = computed(() => {
    return !props.fixed && table.layout.gutterWidth;
  });

  const isCellHidden = (index, columns, column) => {
    if (props.fixed || props.fixed === 'left') {
      return index >= leftFixedLeafCount.value;
    } else if (props.fixed === 'right') {
      let before = 0;

      for (let i = 0; i < index; i++) {
        before += columns[i].colSpan;
      }

      return before < columnsCount.value - rightFixedLeafCount.value;
    } else if (!props.fixed && column.fixed) {
      // hide cell when footer instance is not fixed and column is fixed
      return true;
    } else {
      return index < leftFixedCount.value || index >= columnsCount.value - rightFixedCount.value;
    }
  };

  const getRowClasses = (column, cellIndex) => {
    const classes = [column.id, column.align, column.labelClassName];

    if (column.className) {
      classes.push(column.className);
    }

    if (isCellHidden(cellIndex, store.states.columns.value, column)) {
      classes.push('is-hidden');
    }

    if (!column.children) {
      classes.push('is-leaf');
    }

    return classes;
  };

  return {
    hasGutter,
    getRowClasses,
    columns
  };
}

var TableFooter = {
  name: 'ElTableFooter',
  props: {
    fixed: {
      type: String,
      default: ''
    },
    store: {
      required: true,
      type: Object
    },
    summaryMethod: Function,
    sumText: String,
    border: Boolean,
    defaultSort: {
      type: Object,

      default() {
        return {
          prop: '',
          order: ''
        };
      }

    }
  },

  setup(props) {
    const {
      hasGutter,
      getRowClasses,
      columns
    } = useStyle$5(props);
    return {
      getRowClasses,
      hasGutter,
      columns
    };
  },

  render() {
    let sums = [];

    if (this.summaryMethod) {
      sums = this.summaryMethod({
        columns: this.columns,
        data: this.store.states.data.value
      });
    } else {
      this.columns.forEach((column, index) => {
        if (index === 0) {
          sums[index] = this.sumText;
          return;
        }

        const values = this.store.states.data.value.map(item => Number(item[column.property]));
        const precisions = [];
        let notNumber = true;
        values.forEach(value => {
          if (!isNaN(value)) {
            notNumber = false;
            const decimal = ('' + value).split('.')[1];
            precisions.push(decimal ? decimal.length : 0);
          }
        });
        const precision = Math.max.apply(null, precisions);

        if (!notNumber) {
          sums[index] = values.reduce((prev, curr) => {
            const value = Number(curr);

            if (!isNaN(value)) {
              return parseFloat((prev + curr).toFixed(Math.min(precision, 20)));
            } else {
              return prev;
            }
          }, 0);
        } else {
          sums[index] = '';
        }
      });
    }

    return h('table', {
      class: 'el-table__footer',
      cellspacing: '0',
      cellpadding: '0',
      border: '0'
    }, [hColgroup(this.columns, this.hasGutter), h('tbody', {
      class: [{
        'has-gutter': this.hasGutter
      }]
    }, [h('tr', {}, [...this.columns.map((column, cellIndex) => h('td', {
      key: cellIndex,
      colspan: column.colSpan,
      rowspan: column.rowSpan,
      class: this.getRowClasses(column, cellIndex)
    }, [h('div', {
      class: ['cell', column.labelClassName]
    }, [sums[cellIndex]])])), this.hasGutter && hGutter()])])]);
  }

};

function useUtils$1(store, layout, shouldUpdateHeight) {
  const setCurrentRow = row => {
    store.commit('setCurrentRow', row);
  };

  const toggleRowSelection = (row, selected) => {
    store.toggleRowSelection(row, selected, false);
    store.updateAllSelected();
  };

  const clearSelection = () => {
    store.clearSelection();
  };

  const clearFilter = columnKeys => {
    store.clearFilter(columnKeys);
  };

  const toggleAllSelection = () => {
    store.commit('toggleAllSelection');
  };

  const toggleRowExpansion = (row, expanded) => {
    store.toggleRowExpansionAdapter(row, expanded);
  };

  const clearSort = () => {
    store.clearSort();
  };

  const doLayout = () => {
    if (shouldUpdateHeight.value) {
      layout.updateElsHeight();
    }

    layout.updateColumnsWidth();
  };

  const sort = (prop, order) => {
    store.commit('sort', {
      prop,
      order
    });
  };

  return {
    setCurrentRow,
    toggleRowSelection,
    clearSelection,
    clearFilter,
    toggleAllSelection,
    toggleRowExpansion,
    clearSort,
    doLayout,
    sort
  };
}

function useStyle$6(props, layout, store, table, doLayout) {
  const isHidden = ref(false);
  const renderExpanded = ref(null);
  const resizeProxyVisible = ref(false);

  const setDragVisible = visible => {
    resizeProxyVisible.value = visible;
  };

  const resizeState = ref({
    width: null,
    height: null
  });
  const isGroup = ref(false);
  const scrollPosition = ref('left');
  watchEffect(() => {
    layout.setHeight(props.height);
  });
  watchEffect(() => {
    layout.setMaxHeight(props.maxHeight);
  });
  watchEffect(() => {
    if (!store.states.rowKey.value) return;
    store.setCurrentRowKey(props.currentRowKey);
  });
  watch(() => props.data, () => {
    table.store.commit('setData', props.data);
  }, {
    immediate: true
  });
  watchEffect(() => {
    if (props.expandRowKeys) {
      store.setExpandRowKeysAdapter(props.expandRowKeys);
    }
  });

  const handleMouseLeave = () => {
    table.store.commit('setHoverRow', null);
    if (table.hoverState) table.hoverState = null;
  };

  const handleHeaderFooterMousewheel = (event, data) => {
    const {
      pixelX,
      pixelY
    } = data;

    if (Math.abs(pixelX) >= Math.abs(pixelY)) {
      table.refs.bodyWrapper.scrollLeft += data.pixelX / 5;
    }
  };

  const shouldUpdateHeight = computed(() => {
    return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
  });
  onMounted(() => {
    bindEvents();
    store.updateColumns();
    doLayout();
    resizeState.value = {
      width: table.vnode.el.offsetWidth,
      height: table.vnode.el.offsetHeight
    }; // init filters

    store.states.columns.value.forEach(column => {
      if (column.filteredValue && column.filteredValue.length) {
        table.store.commit('filterChange', {
          column,
          values: column.filteredValue,
          silent: true
        });
      }
    });
    table.$ready = true;
  });
  const syncPostion = lodash.throttle(function () {
    const {
      scrollLeft,
      scrollTop,
      offsetWidth,
      scrollWidth
    } = table.refs.bodyWrapper;
    const {
      headerWrapper,
      footerWrapper,
      fixedBodyWrapper,
      rightFixedBodyWrapper
    } = table.refs;
    if (headerWrapper) headerWrapper.scrollLeft = scrollLeft;
    if (footerWrapper) footerWrapper.scrollLeft = scrollLeft;
    if (fixedBodyWrapper) fixedBodyWrapper.scrollTop = scrollTop;
    if (rightFixedBodyWrapper) rightFixedBodyWrapper.scrollTop = scrollTop;
    const maxScrollLeftPosition = scrollWidth - offsetWidth - 1;

    if (scrollLeft >= maxScrollLeftPosition) {
      scrollPosition.value = 'right';
    } else if (scrollLeft === 0) {
      scrollPosition.value = 'left';
    } else {
      scrollPosition.value = 'middle';
    }
  }, 20);

  const bindEvents = () => {
    table.refs.bodyWrapper.addEventListener('scroll', syncPostion, {
      passive: true
    });

    if (props.fit) {
      addResizeListener(table.vnode.el, resizeListener);
    }
  };

  onUnmounted(() => {
    unbindEvents();
  });

  const unbindEvents = () => {
    var _table$refs$bodyWrapp;

    (_table$refs$bodyWrapp = table.refs.bodyWrapper) === null || _table$refs$bodyWrapp === void 0 ? void 0 : _table$refs$bodyWrapp.removeEventListener('scroll', syncPostion, true);

    if (props.fit) {
      removeResizeListener(table.vnode.el, resizeListener);
    }
  };

  const resizeListener = () => {
    if (!table.$ready) return;
    let shouldUpdateLayout = false;
    const el = table.vnode.el;
    const {
      width: oldWidth,
      height: oldHeight
    } = resizeState.value;
    const width = el.offsetWidth;

    if (oldWidth !== width) {
      shouldUpdateLayout = true;
    }

    const height = el.offsetHeight;

    if ((props.height || shouldUpdateHeight.value) && oldHeight !== height) {
      shouldUpdateLayout = true;
    }

    if (shouldUpdateLayout) {
      resizeState.value = {
        width,
        height
      };
      doLayout();
    }
  };

  const tableSize = computed(() => {
    return props.size;
  });
  const bodyWidth = computed(() => {
    const {
      bodyWidth: bodyWidth_,
      scrollY,
      gutterWidth
    } = layout;
    return bodyWidth_.value ? bodyWidth_.value - (scrollY.value ? gutterWidth : 0) + 'px' : '';
  });
  const bodyHeight = computed(() => {
    const headerHeight = layout.headerHeight.value || 0;
    const bodyHeight = layout.bodyHeight.value;
    const footerHeight = layout.footerHeight.value || 0;

    if (props.height) {
      return {
        height: bodyHeight ? bodyHeight + 'px' : ''
      };
    } else if (props.maxHeight) {
      const maxHeight = parseHeight(props.maxHeight);

      if (typeof maxHeight === 'number') {
        return {
          'max-height': maxHeight - footerHeight - (props.showHeader ? headerHeight : 0) + 'px'
        };
      }
    }

    return {};
  });
  const emptyBlockStyle = computed(() => {
    if (props.data && props.data.length) return null;
    let height = '100%';

    if (layout.appendHeight.value) {
      height = `calc(100% - ${layout.appendHeight.value}px)`;
    }

    return {
      width: bodyWidth.value,
      height
    };
  });
  /**
   * fix layout
   */

  const handleFixedMousewheel = (event, data) => {
    const bodyWrapper = table.refs.bodyWrapper;

    if (Math.abs(data.spinY) > 0) {
      const currentScrollTop = bodyWrapper.scrollTop;

      if (data.pixelY < 0 && currentScrollTop !== 0) {
        event.preventDefault();
      }

      if (data.pixelY > 0 && bodyWrapper.scrollHeight - bodyWrapper.clientHeight > currentScrollTop) {
        event.preventDefault();
      }

      bodyWrapper.scrollTop += Math.ceil(data.pixelY / 5);
    } else {
      bodyWrapper.scrollLeft += Math.ceil(data.pixelX / 5);
    }
  };

  const fixedHeight = computed(() => {
    if (props.maxHeight) {
      if (props.showSummary) {
        return {
          bottom: 0
        };
      }

      return {
        bottom: layout.scrollX.value && props.data.length ? layout.gutterWidth + 'px' : ''
      };
    } else {
      if (props.showSummary) {
        return {
          height: layout.tableHeight.value ? layout.tableHeight.value + 'px' : ''
        };
      }

      return {
        height: layout.viewportHeight.value ? layout.viewportHeight.value + 'px' : ''
      };
    }
  });
  const fixedBodyHeight = computed(() => {
    if (props.height) {
      return {
        height: layout.fixedBodyHeight.value ? layout.fixedBodyHeight.value + 'px' : ''
      };
    } else if (props.maxHeight) {
      let maxHeight = parseHeight(props.maxHeight);

      if (typeof maxHeight === 'number') {
        maxHeight = layout.scrollX.value ? maxHeight - layout.gutterWidth : maxHeight;

        if (props.showHeader) {
          maxHeight -= layout.headerHeight.value;
        }

        maxHeight -= layout.footerHeight.value;
        return {
          'max-height': maxHeight + 'px'
        };
      }
    }

    return {};
  });
  return {
    isHidden,
    renderExpanded,
    setDragVisible,
    isGroup,
    handleMouseLeave,
    handleHeaderFooterMousewheel,
    tableSize,
    bodyHeight,
    emptyBlockStyle,
    handleFixedMousewheel,
    fixedHeight,
    fixedBodyHeight,
    resizeProxyVisible,
    bodyWidth,
    resizeState,
    scrollPosition
  };
}

let tableIdSeed = 1;
var script$O = {
  name: 'ElTable',
  mixins: [Locale],
  directives: {
    Mousewheel
  },
  components: {
    TableHeader,
    TableBody,
    TableFooter
  },
  props: {
    data: {
      type: Array,
      default: function () {
        return [];
      }
    },
    size: String,
    width: [String, Number],
    height: [String, Number],
    maxHeight: [String, Number],
    fit: {
      type: Boolean,
      default: true
    },
    stripe: Boolean,
    border: Boolean,
    rowKey: [String, Function],
    showHeader: {
      type: Boolean,
      default: true
    },
    showSummary: Boolean,
    sumText: String,
    summaryMethod: Function,
    rowClassName: [String, Function],
    rowStyle: [Object, Function],
    cellClassName: [String, Function],
    cellStyle: [Object, Function],
    headerRowClassName: [String, Function],
    headerRowStyle: [Object, Function],
    headerCellClassName: [String, Function],
    headerCellStyle: [Object, Function],
    highlightCurrentRow: Boolean,
    currentRowKey: [String, Number],
    emptyText: String,
    expandRowKeys: Array,
    defaultExpandAll: Boolean,
    defaultSort: Object,
    tooltipEffect: String,
    spanMethod: Function,
    selectOnIndeterminate: {
      type: Boolean,
      default: true
    },
    indent: {
      type: Number,
      default: 16
    },
    treeProps: {
      type: Object,

      default() {
        return {
          hasChildren: 'hasChildren',
          children: 'children'
        };
      }

    },
    lazy: Boolean,
    load: Function
  },
  emits: ['select', 'select-all', 'selection-change', 'cell-mouse-enter', 'cell-mouse-leave', 'cell-click', 'cell-dblclick', 'row-click', 'row-contextmenu', 'row-dblclick', 'header-click', 'header-contextmenu', 'sort-change', 'filter-change', 'current-change', 'header-dragend', 'expand-change'],

  setup(props) {
    let table = getCurrentInstance();
    const store = createStore(table, {
      rowKey: props.rowKey,
      defaultExpandAll: props.defaultExpandAll,
      selectOnIndeterminate: props.selectOnIndeterminate,
      // TreeTable 的相关配置
      indent: props.indent,
      lazy: props.lazy,
      lazyColumnIdentifier: props.treeProps.hasChildren || 'hasChildren',
      childrenColumnName: props.treeProps.children || 'children',
      data: props.data
    });
    table.store = store;
    const layout = new TableLayout({
      store: table.store,
      table,
      fit: props.fit,
      showHeader: props.showHeader
    });
    table.layout = layout;
    const shouldUpdateHeight = computed(() => {
      return props.height || props.maxHeight || store.states.fixedColumns.value.length > 0 || store.states.rightFixedColumns.value.length > 0;
    });
    /**
     * open functions
     */

    const {
      setCurrentRow,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      doLayout,
      sort
    } = useUtils$1(store, layout, shouldUpdateHeight);
    const {
      isHidden,
      renderExpanded,
      setDragVisible,
      isGroup,
      handleMouseLeave,
      handleHeaderFooterMousewheel,
      tableSize,
      bodyHeight,
      emptyBlockStyle,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      resizeProxyVisible,
      bodyWidth,
      resizeState,
      scrollPosition
    } = useStyle$6(props, layout, store, table, doLayout);
    const debouncedUpdateLayout = lodash.debounce(() => doLayout(), 50);
    const tableId = 'el-table_' + tableIdSeed++;
    table.tableId = tableId;
    table.state = {
      isGroup,
      resizeState,
      doLayout,
      debouncedUpdateLayout
    };
    return {
      layout,
      store,
      handleHeaderFooterMousewheel,
      handleMouseLeave,
      tableId,
      tableSize,
      isHidden,
      renderExpanded,
      resizeProxyVisible,
      resizeState,
      isGroup,
      scrollPosition,
      bodyWidth,
      bodyHeight,
      emptyBlockStyle,
      debouncedUpdateLayout,
      handleFixedMousewheel,
      fixedHeight,
      fixedBodyHeight,
      setCurrentRow,
      toggleRowSelection,
      clearSelection,
      clearFilter,
      toggleAllSelection,
      toggleRowExpansion,
      clearSort,
      doLayout,
      sort,
      setDragVisible,
      context: table
    };
  }

};

const _hoisted_1$p = {
  ref: "hiddenColumns",
  class: "hidden-columns"
};
const _hoisted_2$h = {
  key: 0,
  ref: "headerWrapper",
  class: "el-table__header-wrapper"
};
const _hoisted_3$d = { class: "el-table__empty-text" };
const _hoisted_4$7 = {
  key: 1,
  ref: "appendWrapper",
  class: "el-table__append-wrapper"
};
const _hoisted_5$7 = {
  key: 1,
  ref: "footerWrapper",
  class: "el-table__footer-wrapper"
};
const _hoisted_6$3 = {
  key: 0,
  ref: "fixedHeaderWrapper",
  class: "el-table__fixed-header-wrapper"
};
const _hoisted_7$1 = {
  key: 1,
  ref: "fixedFooterWrapper",
  class: "el-table__fixed-footer-wrapper"
};
const _hoisted_8$1 = {
  key: 0,
  ref: "rightFixedHeaderWrapper",
  class: "el-table__fixed-header-wrapper"
};
const _hoisted_9 = {
  key: 1,
  ref: "rightFixedFooterWrapper",
  class: "el-table__fixed-footer-wrapper"
};
const _hoisted_10 = {
  ref: "resizeProxy",
  class: "el-table__column-resize-proxy"
};

function render$K(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_table_header = resolveComponent("table-header");
  const _component_table_body = resolveComponent("table-body");
  const _component_table_footer = resolveComponent("table-footer");
  const _directive_mousewheel = resolveDirective("mousewheel");

  return (openBlock(), createBlock("div", {
    class: [[
      {
        'el-table--fit': $props.fit,
        'el-table--striped': $props.stripe,
        'el-table--border': $props.border || $setup.isGroup,
        'el-table--hidden': $setup.isHidden,
        'el-table--group': $setup.isGroup,
        'el-table--fluid-height': $props.maxHeight,
        'el-table--scrollable-x': $setup.layout.scrollX.value,
        'el-table--scrollable-y': $setup.layout.scrollY.value,
        'el-table--enable-row-hover': !$setup.store.states.isComplex.value,
        'el-table--enable-row-transition':
          ($setup.store.states.data.value || []).length !== 0 &&
          ($setup.store.states.data.value || []).length < 100
      },
      $setup.tableSize ? `el-table--${$setup.tableSize}` : ''
    ], "el-table"],
    onMouseleave: _cache[1] || (_cache[1] = $event => ($setup.handleMouseLeave()))
  }, [
    createVNode("div", _hoisted_1$p, [
      renderSlot(_ctx.$slots, "default")
    ], 512 /* NEED_PATCH */),
    ($props.showHeader)
      ? withDirectives((openBlock(), createBlock("div", _hoisted_2$h, [
          createVNode(_component_table_header, {
            ref: "tableHeader",
            border: $props.border,
            "default-sort": $props.defaultSort,
            store: $setup.store,
            style: {
          width: $setup.layout.bodyWidth.value ? $setup.layout.bodyWidth.value + 'px' : ''
        },
            onSetDragVisible: $setup.setDragVisible
          }, null, 8 /* PROPS */, ["border", "default-sort", "store", "style", "onSetDragVisible"])
        ], 512 /* NEED_PATCH */)), [
          [_directive_mousewheel, $setup.handleHeaderFooterMousewheel]
        ])
      : createCommentVNode("v-if", true),
    createVNode("div", {
      ref: "bodyWrapper",
      class: [[
        $setup.layout.scrollX.value
          ? `is-scrolling-${$setup.scrollPosition}`
          : 'is-scrolling-none'
      ], "el-table__body-wrapper"],
      style: [$setup.bodyHeight]
    }, [
      createVNode(_component_table_body, {
        context: $setup.context,
        highlight: $props.highlightCurrentRow,
        "row-class-name": $props.rowClassName,
        "row-style": $props.rowStyle,
        store: $setup.store,
        stripe: $props.stripe,
        style: {
          width: $setup.bodyWidth
        }
      }, null, 8 /* PROPS */, ["context", "highlight", "row-class-name", "row-style", "store", "stripe", "style"]),
      (!$props.data || $props.data.length === 0)
        ? (openBlock(), createBlock("div", {
            key: 0,
            ref: "emptyBlock",
            style: $setup.emptyBlockStyle,
            class: "el-table__empty-block"
          }, [
            createVNode("span", _hoisted_3$d, [
              renderSlot(_ctx.$slots, "empty", {}, () => [
                createTextVNode(toDisplayString($props.emptyText || _ctx.t('el.table.emptyText')), 1 /* TEXT */)
              ])
            ])
          ], 4 /* STYLE */))
        : createCommentVNode("v-if", true),
      (_ctx.$slots.append)
        ? (openBlock(), createBlock("div", _hoisted_4$7, [
            renderSlot(_ctx.$slots, "append")
          ], 512 /* NEED_PATCH */))
        : createCommentVNode("v-if", true)
    ], 6 /* CLASS, STYLE */),
    ($props.showSummary)
      ? withDirectives((openBlock(), createBlock("div", _hoisted_5$7, [
          createVNode(_component_table_footer, {
            border: $props.border,
            "default-sort": $props.defaultSort,
            store: $setup.store,
            style: {
          width: $setup.layout.bodyWidth.value ? $setup.layout.bodyWidth.value + 'px' : ''
        },
            "sum-text": $props.sumText || _ctx.t('el.table.sumText'),
            "summary-method": $props.summaryMethod
          }, null, 8 /* PROPS */, ["border", "default-sort", "store", "style", "sum-text", "summary-method"])
        ], 512 /* NEED_PATCH */)), [
          [vShow, $props.data && $props.data.length > 0],
          [_directive_mousewheel, $setup.handleHeaderFooterMousewheel]
        ])
      : createCommentVNode("v-if", true),
    ($setup.store.states.fixedColumns.value.length > 0)
      ? withDirectives((openBlock(), createBlock("div", {
          key: 2,
          ref: "fixedWrapper",
          style: [
        {
          width: $setup.layout.fixedWidth.value ? $setup.layout.fixedWidth.value + 'px' : ''
        },
        $setup.fixedHeight
      ],
          class: "el-table__fixed"
        }, [
          ($props.showHeader)
            ? (openBlock(), createBlock("div", _hoisted_6$3, [
                createVNode(_component_table_header, {
                  ref: "fixedTableHeader",
                  border: $props.border,
                  store: $setup.store,
                  style: {
            width: $setup.bodyWidth
          },
                  fixed: "left",
                  onSetDragVisible: $setup.setDragVisible
                }, null, 8 /* PROPS */, ["border", "store", "style", "onSetDragVisible"])
              ], 512 /* NEED_PATCH */))
            : createCommentVNode("v-if", true),
          createVNode("div", {
            ref: "fixedBodyWrapper",
            style: [
          {
            top: $setup.layout.headerHeight.value + 'px'
          },
          $setup.fixedBodyHeight
        ],
            class: "el-table__fixed-body-wrapper"
          }, [
            createVNode(_component_table_body, {
              highlight: $props.highlightCurrentRow,
              "row-class-name": $props.rowClassName,
              "row-style": $props.rowStyle,
              store: $setup.store,
              stripe: $props.stripe,
              style: {
            width: $setup.bodyWidth
          },
              fixed: "left"
            }, null, 8 /* PROPS */, ["highlight", "row-class-name", "row-style", "store", "stripe", "style"]),
            (_ctx.$slots.append)
              ? (openBlock(), createBlock("div", {
                  key: 0,
                  style: { height: $setup.layout.appendHeight.value + 'px' },
                  class: "el-table__append-gutter"
                }, null, 4 /* STYLE */))
              : createCommentVNode("v-if", true)
          ], 4 /* STYLE */),
          ($props.showSummary)
            ? withDirectives((openBlock(), createBlock("div", _hoisted_7$1, [
                createVNode(_component_table_footer, {
                  border: $props.border,
                  store: $setup.store,
                  style: {
            width: $setup.bodyWidth
          },
                  "sum-text": $props.sumText || _ctx.t('el.table.sumText'),
                  "summary-method": $props.summaryMethod,
                  fixed: "left"
                }, null, 8 /* PROPS */, ["border", "store", "style", "sum-text", "summary-method"])
              ], 512 /* NEED_PATCH */)), [
                [vShow, $props.data && $props.data.length > 0]
              ])
            : createCommentVNode("v-if", true)
        ], 4 /* STYLE */)), [
          [_directive_mousewheel, $setup.handleFixedMousewheel]
        ])
      : createCommentVNode("v-if", true),
    ($setup.store.states.rightFixedColumns.value.length > 0)
      ? withDirectives((openBlock(), createBlock("div", {
          key: 3,
          ref: "rightFixedWrapper",
          style: [
        {
          width: $setup.layout.rightFixedWidth.value
            ? $setup.layout.rightFixedWidth.value + 'px'
            : '',
          right: $setup.layout.scrollY.value
            ? ($props.border ? $setup.layout.gutterWidth : $setup.layout.gutterWidth || 0) + 'px'
            : ''
        },
        $setup.fixedHeight
      ],
          class: "el-table__fixed-right"
        }, [
          ($props.showHeader)
            ? (openBlock(), createBlock("div", _hoisted_8$1, [
                createVNode(_component_table_header, {
                  ref: "rightFixedTableHeader",
                  border: $props.border,
                  store: $setup.store,
                  style: {
            width: $setup.bodyWidth
          },
                  fixed: "right",
                  onSetDragVisible: $setup.setDragVisible
                }, null, 8 /* PROPS */, ["border", "store", "style", "onSetDragVisible"])
              ], 512 /* NEED_PATCH */))
            : createCommentVNode("v-if", true),
          createVNode("div", {
            ref: "rightFixedBodyWrapper",
            style: [{ top: $setup.layout.headerHeight.value + 'px' }, $setup.fixedBodyHeight],
            class: "el-table__fixed-body-wrapper"
          }, [
            createVNode(_component_table_body, {
              highlight: $props.highlightCurrentRow,
              "row-class-name": $props.rowClassName,
              "row-style": $props.rowStyle,
              store: $setup.store,
              stripe: $props.stripe,
              style: {
            width: $setup.bodyWidth
          },
              fixed: "right"
            }, null, 8 /* PROPS */, ["highlight", "row-class-name", "row-style", "store", "stripe", "style"]),
            (_ctx.$slots.append)
              ? (openBlock(), createBlock("div", {
                  key: 0,
                  style: { height: $setup.layout.appendHeight.value + 'px' },
                  class: "el-table__append-gutter"
                }, null, 4 /* STYLE */))
              : createCommentVNode("v-if", true)
          ], 4 /* STYLE */),
          ($props.showSummary)
            ? withDirectives((openBlock(), createBlock("div", _hoisted_9, [
                createVNode(_component_table_footer, {
                  border: $props.border,
                  store: $setup.store,
                  style: {
            width: $setup.bodyWidth
          },
                  "sum-text": $props.sumText || _ctx.t('el.table.sumText'),
                  "summary-method": $props.summaryMethod,
                  fixed: "right"
                }, null, 8 /* PROPS */, ["border", "store", "style", "sum-text", "summary-method"])
              ], 512 /* NEED_PATCH */)), [
                [vShow, $props.data && $props.data.length > 0]
              ])
            : createCommentVNode("v-if", true)
        ], 4 /* STYLE */)), [
          [_directive_mousewheel, $setup.handleFixedMousewheel]
        ])
      : createCommentVNode("v-if", true),
    ($setup.store.states.rightFixedColumns.value.length > 0)
      ? (openBlock(), createBlock("div", {
          key: 4,
          ref: "rightFixedPatch",
          style: {
        width: $setup.layout.scrollY.value ? $setup.layout.gutterWidth + 'px' : '0',
        height: $setup.layout.headerHeight.value + 'px'
      },
          class: "el-table__fixed-right-patch"
        }, null, 4 /* STYLE */))
      : createCommentVNode("v-if", true),
    withDirectives(createVNode("div", _hoisted_10, null, 512 /* NEED_PATCH */), [
      [vShow, $setup.resizeProxyVisible]
    ])
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$O.render = render$K;
script$O.__file = "packages/table/src/table.vue";

script$O.install = function (app) {
  app.component(script$O.name, script$O);
};

const cellStarts = {
  default: {
    order: ''
  },
  selection: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: '',
    className: 'el-table-column--selection'
  },
  expand: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ''
  },
  index: {
    width: 48,
    minWidth: 48,
    realWidth: 48,
    order: ''
  }
}; // 这些选项不应该被覆盖

const cellForced = {
  selection: {
    renderHeader: function ({
      store
    }) {
      return h(script$d, {
        disabled: store.states.data.value && store.states.data.value.length === 0,
        indeterminate: store.states.selection.value.length > 0 && !store.states.isAllSelected.value,
        onClick: store.toggleAllSelection,
        modelValue: store.states.isAllSelected.value
      });
    },
    renderCell: function ({
      row,
      column,
      store,
      index_
    }) {
      return h(script$d, {
        disabled: column.selectable ? !column.selectable.call(null, row, index_) : false,
        onInput: () => {
          store.commit('rowSelectedChanged', row);
        },
        nativeOnClick: event => event.stopPropagation(),
        modelValue: store.isSelected(row)
      });
    },
    sortable: false,
    resizable: false
  },
  index: {
    renderHeader: function ({
      column
    }) {
      return column.label || '#';
    },
    renderCell: function ({
      index_,
      column
    }) {
      let i = index_ + 1;
      const index = column.index;

      if (typeof index === 'number') {
        i = index_ + index;
      } else if (typeof index === 'function') {
        i = index(index_);
      }

      return h('div', {}, [i]);
    },
    sortable: false
  },
  expand: {
    renderHeader: function ({
      column
    }) {
      return column.label || '';
    },
    renderCell: function ({
      row,
      store
    }) {
      const classes = ['el-table__expand-icon'];

      if (store.states.expandRows.value.indexOf(row) > -1) {
        classes.push('el-table__expand-icon--expanded');
      }

      const callback = function (e) {
        e.stopPropagation();
        store.toggleRowExpansion(row);
      };

      return h('div', {
        class: classes,
        onClick: callback
      }, [h('i', {
        class: 'el-icon el-icon-arrow-right'
      })]);
    },
    sortable: false,
    resizable: false,
    className: 'el-table__expand-column'
  }
};
function defaultRenderCell({
  row,
  column,
  index_
}) {
  const property = column.property;
  const value = property && getPropByPath(row, property, false).v;

  if (column && column.formatter) {
    return column.formatter(row, column, value, index_);
  }

  return value;
}
function treeCellPrefix({
  row,
  treeNode,
  store
}) {
  if (!treeNode) return null;
  const ele = [];

  const callback = function (e) {
    e.stopPropagation();
    store.loadOrToggle(row);
  };

  if (treeNode.indent) {
    ele.push(h('span', {
      class: 'el-table__indent',
      style: {
        'padding-left': treeNode.indent + 'px'
      }
    }));
  }

  if (typeof treeNode.expanded === 'boolean' && !treeNode.noLazyChildren) {
    const expandClasses = ['el-table__expand-icon', treeNode.expanded ? 'el-table__expand-icon--expanded' : ''];
    let iconClasses = ['el-icon-arrow-right'];

    if (treeNode.loading) {
      iconClasses = ['el-icon-loading'];
    }

    ele.push(h('div', {
      class: expandClasses,
      onClick: callback
    }, [h('i', {
      class: iconClasses
    })]));
  } else {
    ele.push(h('span', {
      class: 'el-table__placeholder'
    }));
  }

  return ele;
}

function useWatcher$1(owner, props_) {
  const instance = getCurrentInstance();

  const registerComplexWatchers = () => {
    const props = ['fixed'];
    const aliases = {
      realWidth: 'width',
      realMinWidth: 'minWidth'
    };
    const allAliases = props.reduce((prev, cur) => {
      prev[cur] = cur;
      return prev;
    }, aliases);
    Object.keys(allAliases).forEach(key => {
      const columnKey = aliases[key]; // eslint-disable-next-line no-prototype-builtins

      if (props_.hasOwnProperty(columnKey)) {
        watch(() => props_[columnKey], newVal => {
          instance.columnConfig.value[columnKey] = newVal;
          const updateColumns = columnKey === 'fixed';
          owner.value.store.scheduleLayout(updateColumns);
        });
      }
    });
  };

  const registerNormalWatchers = () => {
    const props = ['label', 'property', 'filters', 'filterMultiple', 'sortable', 'index', 'formatter', 'className', 'labelClassName', 'showOverflowTooltip']; // 一些属性具有别名

    const aliases = {
      prop: 'property',
      realAlign: 'align',
      realHeaderAlign: 'headerAlign'
    };
    const allAliases = props.reduce((prev, cur) => {
      prev[cur] = cur;
      return prev;
    }, aliases);
    Object.keys(allAliases).forEach(key => {
      const columnKey = aliases[key]; // eslint-disable-next-line no-prototype-builtins

      if (props_.hasOwnProperty(columnKey)) {
        watch(() => props_[columnKey], newVal => {
          instance.columnConfig.value[columnKey] = newVal;
        });
      }
    });
  };

  return {
    registerComplexWatchers,
    registerNormalWatchers
  };
}

function useRender$1(props, slots, owner) {
  const instance = getCurrentInstance();
  const columnId = ref('');
  const isSubColumn = ref(false);
  const realAlign = ref();
  const realHeaderAlign = ref();
  watchEffect(() => {
    realAlign.value = props.align ? 'is-' + props.align : null; // nextline help render

    realAlign.value;
  });
  watchEffect(() => {
    realHeaderAlign.value = props.headerAlign ? 'is-' + props.headerAlign : realAlign.value; // nextline help render

    realHeaderAlign.value;
  });
  const columnOrTableParent = computed(() => {
    let parent = instance.vnode.vParent || instance.parent;

    while (parent && !parent.tableId && !parent.columnId) {
      parent = parent.vnode.vParent || parent.parent;
    }

    return parent;
  });
  const realWidth = ref(parseWidth(props.width));
  const realMinWidth = ref(parseMinWidth(props.minWidth));

  const setColumnWidth = column => {
    if (realWidth.value) column.width = realWidth.value;

    if (realMinWidth.value) {
      column.minWidth = realMinWidth.value;
    }

    if (!column.minWidth) {
      column.minWidth = 80;
    }

    column.realWidth = column.width === undefined ? column.minWidth : column.width;
    return column;
  };

  const setColumnForcedProps = column => {
    // 对于特定类型的 column，某些属性不允许设置
    const type = column.type;
    const source = cellForced[type] || {};
    Object.keys(source).forEach(prop => {
      const value = source[prop];

      if (value !== undefined) {
        column[prop] = prop === 'className' ? `${column[prop]} ${value}` : value;
      }
    });
    return column;
  };

  const checkSubColumn = children => {
    if (children instanceof Array) {
      children.forEach(child => check(child));
    } else {
      check(children);
    }

    function check(item) {
      var _item$type;

      if ((item === null || item === void 0 ? void 0 : (_item$type = item.type) === null || _item$type === void 0 ? void 0 : _item$type.name) === 'ElTableColumn') {
        item.vParent = instance;
      }
    }
  };

  const setColumnRenders = column => {
    // renderHeader 属性不推荐使用。
    if (props.renderHeader) {
      console.warn('[Element Warn][TableColumn]Comparing to render-header, scoped-slot header is easier to use. We recommend users to use scoped-slot header.');
    } else if (column.type !== 'selection') {
      column.renderHeader = scope => {
        // help render
        instance.columnConfig.value['label'];
        const renderHeader = slots.header;
        return renderHeader ? renderHeader(scope) : column.label;
      };
    }

    let originRenderCell = column.renderCell; // TODO: 这里的实现调整

    if (column.type === 'expand') {
      // 对于展开行，renderCell 不允许配置的。在上一步中已经设置过，这里需要简单封装一下。
      column.renderCell = data => h('div', {
        class: 'cell'
      }, [originRenderCell(data)]);

      owner.value.renderExpanded = data => {
        return slots.default ? slots.default(data) : slots.default;
      };
    } else {
      originRenderCell = originRenderCell || defaultRenderCell; // 对 renderCell 进行包装

      column.renderCell = data => {
        let children = null;

        if (slots.default) {
          children = slots.default(data);
        } else {
          children = originRenderCell(data);
        }

        const prefix = treeCellPrefix(data);
        const props = {
          class: 'cell',
          style: {}
        };

        if (column.showOverflowTooltip) {
          props.class += ' el-tooltip';
          props.style = {
            width: (data.column.realWidth || data.column.width) - 1 + 'px'
          };
        }

        checkSubColumn(children);
        return h('div', props, [prefix, children]);
      };
    }

    return column;
  };

  const getPropsData = (...propsKey) => {
    return propsKey.reduce((prev, cur) => {
      if (Array.isArray(cur)) {
        cur.forEach(key => {
          prev[key] = props[key];
        });
      }

      return prev;
    }, {});
  };

  const getColumnElIndex = (children, child) => {
    return [].indexOf.call(children, child);
  };

  return {
    columnId,
    realAlign,
    isSubColumn,
    realHeaderAlign,
    columnOrTableParent,
    setColumnWidth,
    setColumnForcedProps,
    setColumnRenders,
    getPropsData,
    getColumnElIndex
  };
}

let columnIdSeed = 1;
var ElTableColumn = {
  name: 'ElTableColumn',
  components: {
    ElCheckbox: script$d
  },
  props: {
    type: {
      type: String,
      default: 'default'
    },
    label: String,
    className: String,
    labelClassName: String,
    property: String,
    prop: String,
    width: {
      type: [Object, Number, String],
      default: () => {
        return {};
      }
    },
    minWidth: {
      type: [Object, Number, String],
      default: () => {
        return {};
      }
    },
    renderHeader: Function,
    sortable: {
      type: [Boolean, String],
      default: false
    },
    sortMethod: Function,
    sortBy: [String, Function, Array],
    resizable: {
      type: Boolean,
      default: true
    },
    columnKey: String,
    align: String,
    headerAlign: String,
    showTooltipWhenOverflow: Boolean,
    showOverflowTooltip: Boolean,
    fixed: [Boolean, String],
    formatter: Function,
    selectable: Function,
    reserveSelection: Boolean,
    filterMethod: Function,
    filteredValue: Array,
    filters: Array,
    filterPlacement: String,
    filterMultiple: {
      type: Boolean,
      default: true
    },
    index: [Number, Function],
    sortOrders: {
      type: Array,

      default() {
        return ['ascending', 'descending', null];
      },

      validator(val) {
        return val.every(order => ['ascending', 'descending', null].indexOf(order) > -1);
      }

    }
  },

  setup(props, {
    slots
  }) {
    const instance = getCurrentInstance();
    const columnConfig = ref({});
    const row = ref({});
    const r = ref({});
    const index_ = ref(0);
    const owner = computed(() => {
      let parent = instance.parent;

      while (parent && !parent.tableId) {
        parent = parent.parent;
      }

      return parent;
    });
    const {
      registerNormalWatchers,
      registerComplexWatchers
    } = useWatcher$1(owner, props);
    const {
      columnId,
      isSubColumn,
      realHeaderAlign,
      columnOrTableParent,
      setColumnWidth,
      setColumnForcedProps,
      setColumnRenders,
      getPropsData,
      getColumnElIndex,
      realAlign
    } = useRender$1(props, slots, owner);
    const parent = columnOrTableParent.value;
    columnId.value = (parent.tableId || parent.columnId) + '_column_' + columnIdSeed++;
    onBeforeMount(() => {
      isSubColumn.value = owner.value !== parent;
      const type = props.type || 'default';
      const sortable = props.sortable === '' ? true : props.sortable;
      const defaults = { ...cellStarts[type],
        id: columnId.value,
        type: type,
        property: props.prop || props.property,
        align: realAlign,
        headerAlign: realHeaderAlign,
        showOverflowTooltip: props.showOverflowTooltip || props.showTooltipWhenOverflow,
        // filter 相关属性
        filterable: props.filters || props.filterMethod,
        filteredValue: [],
        filterPlacement: '',
        isColumnGroup: false,
        filterOpened: false,
        // sort 相关属性
        sortable: sortable,
        // index 列
        index: props.index
      };
      const basicProps = ['columnKey', 'label', 'className', 'labelClassName', 'type', 'renderHeader', 'formatter', 'fixed', 'resizable'];
      const sortProps = ['sortMethod', 'sortBy', 'sortOrders'];
      const selectProps = ['selectable', 'reserveSelection'];
      const filterProps = ['filterMethod', 'filters', 'filterMultiple', 'filterOpened', 'filteredValue', 'filterPlacement'];
      let column = getPropsData(basicProps, sortProps, selectProps, filterProps);
      column = mergeOptions(defaults, column); // 注意 compose 中函数执行的顺序是从右到左

      const chains = compose(setColumnRenders, setColumnWidth, setColumnForcedProps);
      column = chains(column);
      columnConfig.value = column; // 注册 watcher

      registerNormalWatchers();
      registerComplexWatchers();
    });
    onMounted(() => {
      var _parent$refs$hiddenCo;

      const parent = columnOrTableParent.value;
      const children = isSubColumn.value ? parent.vnode.el.children : (_parent$refs$hiddenCo = parent.refs.hiddenColumns) === null || _parent$refs$hiddenCo === void 0 ? void 0 : _parent$refs$hiddenCo.children;
      const columnIndex = getColumnElIndex(children || [], instance.vnode.el);
      owner.value.store.commit('insertColumn', columnConfig.value, columnIndex, isSubColumn.value ? parent.columnConfig.value : null);
    });
    instance.columnId = columnId.value; // eslint-disable-next-line

    instance.columnConfig = columnConfig;
    return {
      row,
      r,
      index_,
      columnId,
      columnConfig
    };
  },

  render() {
    var _this$$slots$default, _this$$slots;

    return h('div', (_this$$slots$default = (_this$$slots = this.$slots).default) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots, {
      store: {},
      _self: {},
      column: {},
      row: {},
      index_: undefined
    }));
  }

};

/* istanbul ignore next */

ElTableColumn.install = function (app) {
  app.component(ElTableColumn.name, ElTableColumn);
};

const typeFlag = Symbol('TREE_NODE');
/**
 *
 * @param {*} id
 * @param {string} label
 * @param {TreeNode[]} childNodes
 * @param {object} param3
 */

class TreeNode {
  constructor(id, label, childNodes = [], {
    /* 默认值 */
    parent = null,
    isAsync = false,
    isVisable = true,
    isChecked = false,
    isIndeterminate = false,
    isExpanded = false,
    isDisabled = false,
    isDraggable = false,
    isLeaf = false,
    data = {},
    asyncLoadFn = () => null
  } = {}, {
    /* 拦截函数 */
    insertChild = null,
    appendChild = null,
    removeChild = null
  } = {}) {
    this.id = id || label;
    this.label = label;
    this.parent = parent;
    this.childNodes = childNodes;
    this.isVisable = isVisable;
    this.isChecked = isChecked;
    this.isIndeterminate = isIndeterminate;
    this.isExpanded = isExpanded;
    this.isDisabled = isDisabled;
    this.isDraggable = isDraggable;
    this.isRendered = false;
    this.data = data; // Additional data carried by the node

    this.isLeaf = isLeaf;
    this.isAsync = isAsync; // Load child only at expand time

    this.asyncState = 'notload'; // notload || loaded || loading

    this.asyncLoadFn = asyncLoadFn; // (currentNode, resolveFn) async load child node

    this.interceptHandler = {
      insertChild,
      appendChild,
      removeChild
    }; // this.cache = {
    //   level: null
    // }
    // not use, You can cache read-only properties here

    this.updateChildParent();
    this.updateChildChecked();
    this.updateCheckedState();
    this.updateExpandedState();
  }

  get root() {
    // readonly
    let root = this;
    this.upwardEach(node => {
      root = node;
    });
    return root;
  }

  get isLeaf() {
    return this.isAsync ? this.asyncState === 'loaded' && this.childNodes.length === 0 : this.childNodes.length === 0;
  }

  set isLeaf(v) {
    if (v) this.asyncState = 'loaded';
  }

  get isRoot() {
    // readonly
    return this.root === this;
  }

  get level() {
    // readonly
    if (!this.parent) return 0;
    return this.parent.level + 1;
  }

  get type() {
    // readonly
    return typeFlag;
  }

  get index() {
    // readonly
    const parent = this.parent;
    if (!parent) return -1;
    return parent.findChildIndex(this);
  }

  get checkedNodes() {
    return this.childNodes.filter(treeNode => treeNode.isChecked);
  }

  loadAsync() {
    if (!this.isAsync || this.asyncState !== 'notload') {
      return;
    }

    const resolveFn = (childNodes = []) => {
      // this.childNodes = []
      this.append(...childNodes);
      this.asyncState = 'loaded';
    };

    this.asyncState = 'loading';
    this.asyncLoadFn(this, resolveFn);
  }

  updateChildParent() {
    this.childNodes.forEach(node => {
      node.parent = this;
    });
  }

  updateChildChecked() {
    if (this.isChecked) {
      this.setChildChecked(true);
    }
  }

  updateCheckedState() {
    if (this.isLeaf) {
      return;
    } // not leaf node exec


    const checkedNodeLen = this.getCheckedNode().length;
    const childrenNodeLen = this.childNodes.length;

    if (childrenNodeLen === 0) {
      return;
    }

    if (checkedNodeLen === childrenNodeLen) {
      // full select
      this.setCheckedState(1);
    } else if (checkedNodeLen === 0) {
      // not full select
      this.setCheckedState(0);
    } else {
      // Half select
      this.setCheckedState(2);
    }
  }

  updateExpandedState() {
    const childNodes = this.childNodes;

    for (let i = 0; i < childNodes.length; i++) {
      const node = childNodes[i];

      if (node.isExpanded) {
        this.isExpanded = true;
        return;
      }
    }
  }
  /**
   *
   * @param {TreeNode} node
   */


  appendChild(node) {
    if (this.interceptHandler.appendChild) {
      const [_node] = this.interceptHandler.appendChild.apply(this, arguments);
      if (typeof _node !== 'undefined') node = _node;
    }

    if (!TreeNode.isType(node)) {
      return false;
    }

    node.parent = this;
    this.childNodes.push(node);
    return true;
  }

  append(...nodes) {
    nodes.forEach(node => {
      this.appendChild(node);
    });
    return true;
  }
  /**
   *
   * @param {number} index
   * @param {TreeNode} node
   */


  insertChild(index, node) {
    if (this.interceptHandler.appendChild) {
      const [_index, _node] = this.interceptHandler.insertChild.apply(this, arguments);
      if (typeof _index !== 'undefined') index = _index;
      if (typeof _node !== 'undefined') node = _node;
    }

    if (!TreeNode.isType(node)) {
      return false;
    }

    node.parent = this;
    this.childNodes.splice(index, 0, node);
    return true;
  }

  insert() {
    this.insertChild.apply(this, arguments);
  }
  /**
   *
   * @param {number} index
   */


  removeChild(index) {
    if (this.interceptHandler.appendChild) {
      this.interceptHandler.removeChild.apply(this, arguments);
    }

    if (index < 0 || index >= this.childNodes.length) {
      return false;
    }

    this.childNodes.splice(index, 1);
    return true;
  }

  remove() {
    if (!this.parent) {
      return false;
    }

    return this.parent.removeChild(this.index);
  }
  /**
   *
   * @param {boolean} value
   */


  setChecked(value, strictly = false) {
    this.isIndeterminate = false;

    let _value = !this.isChecked;

    if (typeof value !== 'undefined') {
      _value = value;
    }

    this.isChecked = _value;

    if (!strictly) {
      this.upwardEach(node => {
        if (!node.isDisabled) this.updateCheckedState.call(node);
      });
      this.depthEach(node => {
        if (!node.isDisabled && node.isVisable) node.isChecked = _value;
      });
    }

    return this.isChecked;
  }

  setChildChecked(value) {
    this.childNodes.forEach(node => node.isChecked = value);
  }
  /**
   * Traverse upward
   * @param {Function} callback( node:TreeNode ) if returns true then stop each, else not stop
   */


  upwardEach(callback, {
    isSkipSelf = true
  } = {}) {
    let current = isSkipSelf ? this.parent : this;

    while (current) {
      if (callback(current)) {
        return;
      }

      current = current.parent;
    }
  }
  /**
   * from current node start, down each
   * @param {Function} callback( node:TreeNode, parentNode:TreeNode, deep: number) if returns true then stop each, else not stop
   */


  depthEach(upToDownCallBack = () => false, downToUpCallBack = () => false) {
    const dfs = (node, deep) => {
      if (!TreeNode.isType(node)) {
        return;
      }

      for (let i = 0; i < node.childNodes.length; i++) {
        const _node = node.childNodes[i];
        if (upToDownCallBack(_node, node, deep)) return;
        dfs(_node, deep + 1);
        if (downToUpCallBack(_node, node, deep)) return;
      }
    };

    upToDownCallBack(this, this.parent, 0);
    dfs(this, 1);
    downToUpCallBack(this, this.parent, 0);
  }

  getCheckedNode() {
    return this.childNodes.filter(item => item.isChecked);
  }
  /**
   *
   * @param {number} state 0:not checked, 1:checked, 2:indeterminate
   */


  setCheckedState(state) {
    const eunmState = [{
      isChecked: false,
      isIndeterminate: false
    }, {
      isChecked: true,
      isIndeterminate: false
    }, {
      isChecked: true,
      isIndeterminate: true
    }];

    if (!eunmState[state]) {
      return false;
    }

    this.isChecked = eunmState[state].isChecked;
    this.isIndeterminate = eunmState[state].isIndeterminate;
    return true;
  }
  /**
   * Look for node in the subtree
   * @param {ID|TreeNode} target
   */


  findOne(target) {
    let res = null;
    this.depthEach(node => {
      if (node.id == target || node === target) {
        res = node;
        return true;
      }
    });
    return res;
  }
  /**
   * find nodes
   * @param {Function | string} target
   */


  findMany(target) {
    const res = [];
    this.depthEach((node, parent, deep) => {
      if (typeof target === 'function' && target(node, parent, deep) || typeof target === 'string' && node.label.search(target) !== -1) {
        res.push(node);
      }
    });
    return res;
  }

  findChildIndex(target) {
    for (let i = 0; i < this.childNodes.length; i++) {
      const node = this.childNodes[i];

      if (node.id == target || node === target) {
        return i;
      }
    }

    return -1;
  }

  expand(value, ...extraNodes) {
    let _value = this.isExpanded;
    _value = typeof value === 'undefined' ? !_value : value;
    this.isExpanded = _value;
    this.upwardEach(node => {
      node.expand(true);
    });
    this.loadAsync();
    this.append(...extraNodes);
    this.isRendered = true;
  }

  filter(callback = () => true) {
    const arr = [];
    this.setSubTreeVisable(false);
    this.depthEach((node, parentNode, deep) => {
      const isShow = callback(node, parentNode, deep);

      if (isShow) {
        node.setVsiable(true);
        arr.push(node);
      }
    });
    return arr;
  }

  setSubTreeVisable(value) {
    this.depthEach(node => {
      node.isVisable = value;
    });
  }

  setVsiable(value) {
    this.isVisable = value;
    this.upwardEach(node => {
      node.isVisable = true;
    });
  }

  separation() {
    const parent = this.parent;
    if (!parent) return null;
    parent.removeChild(this.index);
    this.parent = null;
    return this;
  }
  /**
   * is allow move to target
   * @param {TreeNode} target
   * @param {string} relative top, bottom, inner
   */


  isAllowMove(target) {
    if (target === this) {
      return false;
    }

    if (this.findOne(target)) {
      return false;
    }

    return true;
  }
  /**
   * currentNode move to targetNode relative location
   * @param {TreeNode} target
   * @param {string} relative top, bottom, inner
   */


  move(target, relative) {
    if (!this.isAllowMove(target, relative)) {
      return false;
    }

    this.separation();

    switch (relative) {
      case 'top':
        // top
        target.parent.insertChild(target.index, this);
        return true;

      case 'inner':
        // inner
        target.expand(true, this);
        return true;

      case 'bottom':
        // bottom
        target.parent.insertChild(target.index + 1, this);
        return true;
    }
  }

  collapse() {
    const parent = this.parent;

    if (!parent) {
      return;
    }

    parent.childNodes.forEach(node => {
      if (node === this) {
        node.expand();
      } else {
        node.expand(false);
      }
    });
  }

  static isType(node) {
    if (typeof node !== 'object') {
      return false;
    }

    return node.type === typeFlag;
  }

  static create({
    id,
    label,
    childNodes,
    interceptHandler,
    ...otherParams
  }) {
    return new TreeNode(id, label, childNodes, otherParams, interceptHandler);
  }

}

/**
 * Deep traversal of the object
 * @param {object} target
 * @param {function} callback(cloneRawNode, rawNode, isLeaf)
 */

function nodeMap(target, callback = () => null, {
  childKey = 'children',
  mapChildKey = 'children'
} = {
  /* TreeNode */
}) {
  const dfs = node => {
    if (isObject(node) && !isArray$1(node[childKey])) {
      const _cloneNode = { ...node
      };
      return callback(_cloneNode, node, true);
    }

    const cloneNode = { ...node
    };
    const newNode = callback(cloneNode, node, false);
    if (typeof newNode[childKey] !== 'undefined') delete newNode[childKey];
    newNode[mapChildKey] = [];

    for (let i = 0; i < node[childKey].length; i++) {
      const _node = node[childKey][i];
      const ret = dfs(_node);
      ret.parent = newNode;
      newNode[mapChildKey].push(ret);
    }

    return newNode;
  };

  return dfs(target);
}
function nodeEach(target, callback = () => false, {
  childKey = 'children',
  root = null
} = {}) {
  const dfs = node => {
    if (!isObject(node) || isArray$1(node)) {
      return;
    }

    const child = node[childKey] || [];

    for (let i = 0; i < child.length; i++) {
      const _node = child[i];
      if (callback(_node
      /* Current */
      , node
      /* Parent */
      )) return;
      dfs(_node);
    }
  };

  if (callback(target
  /* Current */
  , root
  /* Parent */
  )) return;
  return dfs(target);
}
/**
 * Modify the property name of the object
 * @param {object} obj
 * @param {object} keyMap newKey mapping oldKey
 */

function transitionObjectKey(obj, keyMap = {}) {
  const transitionKeyList = Object.keys(keyMap);
  transitionKeyList.forEach(key => {
    if (key !== keyMap[key]) {
      obj[key] = obj[keyMap[key]];
      delete obj[keyMap[key]];
    }
  });
  return obj;
}
const extractMethods = (obj, methods) => {
  const methodList = {};
  methods.forEach(method => {
    methodList[method] = obj[method].bind(obj);
  });
  return methodList;
};

function createAction(tree) {
  // this.root changed update this.raw
  const appendChild = function (node) {
    if (TreeNode.isType(node)) {
      tree.appendRawNode(this, node.data.raw); // 这里的this表示当前的TreeNode

      return [node];
    }

    tree.appendRawNode(this, node);
    return [tree.rawNodeToTreeNode(node)];
  };

  const removeChild = function (index) {
    tree.removeChildRawNode(this, index); // 这里的this表示当前的TreeNode
  };

  const insertChild = function (index, node) {
    if (TreeNode.isType(node)) {
      tree.insertRawNode(this, index, node.data.raw); // 这里的this表示当前的TreeNode

      return [index, node];
    }

    tree.insertRawNode(this, index, node);
    return [index, tree.rawNodeToTreeNode(node)];
  };

  return {
    appendChild,
    removeChild,
    insertChild
  };
}

class Tree {
  /**
   *
   * @param {object[]} list
   * @param {object} defaultNodeKey The incoming Node proprtry name maps to the default name
   */
  constructor(list, defaultNodeKey = {}, defaultNodeValue = {}) {
    this.isUpdateRaw = true;
    this.raw = list;
    this.injectAction = createAction(this); // The core method is injected with interceptor functions, the insert RowNode is automatically converted to TreeNode

    this.root = new TreeNode(Date.now(), 'root', [], defaultNodeValue, this.injectAction);
    this.defaultNodeKey = Object.assign({
      id: 'id',
      label: 'label',
      childNodes: 'childNodes',
      isDisabled: 'isDisabled',
      isAsync: 'isAsync',
      isChecked: 'isChecked',
      isVisable: 'isVisable',
      isExpanded: 'isExpanded'
    }, defaultNodeKey);
    this.defaultNodeValue = Object.assign({}, defaultNodeValue); // this.checked = []
    // this.expanded = []

    this.initRoot();
  }

  get isEmpty() {
    for (let i = 0; i < this.root.childNodes.length; i++) {
      const node = this.root.childNodes[i];

      if (node.isVisable) {
        return false;
      }
    }

    return true;
  }

  get checked() {
    const t = {};
    this.root.depthEach(node => {
      node.isChecked && (t[node.id] = true);
    });
    return Object.keys(t);
  }

  set checked(v) {
    this.setCheckedByIdList(v, true);
  }

  get expanded() {
    const t = {};
    this.root.depthEach(node => {
      node.isExpanded && (t[node.id] = true);
    });
    return Object.keys(t);
  }

  set expanded(v) {
    this.setExpandedByIdList(v, true);
  }

  initRoot() {
    // rekeyname and create TreeNode
    this.isUpdateRaw = false;
    this.root.childNodes = [];
    this.root.append(...this.raw);
    this.isUpdateRaw = true;
  }

  rawNodeToTreeNode(rawNode) {
    const {
      childNodes
    } = this.defaultNodeKey;
    return nodeMap(rawNode, (_node, node) => {
      const handledNode = transitionObjectKey(_node, this.defaultNodeKey); // debugger

      const treeNode = TreeNode.create(Object.assign({}, this.defaultNodeValue, {
        data: {
          raw: node
        },
        interceptHandler: this.injectAction
      }, handledNode, {
        childNodes: []
      }));
      return treeNode;
    }, {
      childKey: childNodes,
      mapChildKey: 'childNodes'
    });
  }

  update() {
    // rebuild tree
    // TODO: 这里可以做diff优化
    this.initRoot();
  }

  removeChildRawNode(target, index) {
    const {
      childNodes
    } = this.defaultNodeKey;

    if (!this.isUpdateRaw) {
      return;
    }

    let rawChild = target.data.raw ? target.data.raw[childNodes] : this.raw;

    if (!rawChild) {
      target.data.raw[childNodes] = [];
      rawChild = target.data.raw[childNodes];
    }

    rawChild.splice(index, 1);
  }

  appendRawNode(target, rawNode) {
    const {
      childNodes
    } = this.defaultNodeKey;

    if (!this.isUpdateRaw) {
      return;
    }

    let rawChild = target.data.raw ? target.data.raw[childNodes] : this.raw;

    if (!rawChild) {
      target.data.raw[childNodes] = [];
      rawChild = target.data.raw[childNodes];
    }

    rawChild.push(rawNode);
  }

  insertRawNode(target, index, rawNode) {
    const {
      childNodes
    } = this.defaultNodeKey;

    if (!this.isUpdateRaw) {
      return;
    }

    let rawChild = target.data.raw ? target.data.raw[childNodes] : this.raw;

    if (!rawChild) {
      target.data.raw[childNodes] = [];
      rawChild = target.data.raw[childNodes];
    }

    rawChild.splice(index, 0, rawNode);
  }

  getParentRawNode(rawNode) {
    let parentNode = null;
    const {
      childNodes
    } = this.defaultNodeKey;
    nodeEach({
      [childNodes]: this.raw
    }, (current, parent) => {
      if (current === rawNode || current.id === rawNode.id) {
        parentNode = parent;
        return true;
      }
    }, {
      childKey: childNodes
    });
    return parentNode;
  }

  showAll() {
    this.root.setSubTreeVisable(true);
  }

  checkedAll() {
    this.root.setChecked(true);
  }

  expandAll() {
    this.root.depthEach(node => {
      if (node.isLeaf) {
        node.expand(true);
      }
    });
  }

  setCheckedByIdList(idList = [], value = true) {
    this.root.depthEach(node => {
      if (idList.indexOf(node.id) !== -1) {
        node.setChecked(value);
      }
    });
  }

  setExpandedByIdList(idList = [], value = true) {
    this.root.depthEach(node => {
      if (idList.indexOf(node.id) !== -1) {
        node.expand(value);
      }
    });
  }

}

var script$P = {
  name: 'ElNodeContent',
  props: {
    node: {
      required: true,
      type: TreeNode
    }
  },

  render(ctx) {
    const elTree = inject('elTree');

    if (typeof elTree.slots.default === 'function') {
      return elTree.slots.default({
        node: ctx.node,
        data: ctx.node.data.raw
      });
    } else if (typeof elTree.props.renderContent === 'function') {
      return elTree.props.renderContent({
        node: ctx.node,
        data: ctx.node.data.raw
      });
    }

    return h('span', ctx.node.label);
  }

};

script$P.__file = "packages/tree/NodeContent.vue";

var script$Q = {
  name: 'ElTreeNode',
  props: {
    node: TreeNode
  },
  components: {
    ElCollapseTransition,
    ElCheckbox: script$d,
    ElNodeContent: script$P
  },

  setup(props) {
    const elTree = inject('elTree');

    const onClickNode = e => {
      !elTree.props.expandOnClickNode || props.node.isLeaf || (elTree.props.accordion ? props.node.collapse() : props.node.expand());
      !elTree.props.checkOnClickNode || props.node.setChecked(undefined, elTree.props.checkStrictly);
      elTree.emit('node-click', props.node, e);
      elTree.emit('current-change', props.node, e);
      props.node.isExpanded ? elTree.emit('node-expand', props.node, e) : elTree.emit('node-collapse', props.node, e);
    };

    const onRightEvent = e => {
      if (!elTree.vnode.props['onNode-contextmenu']) return;
      e.preventDefault();
      elTree.emit('node-contextmenu', props.node, e);
    };

    const onChangeCheckbox = e => {
      props.node.setChecked(undefined, elTree.props.checkStrictly);
      elTree.emit('check-change', props.node, e);
    };

    return {
      elTree,
      onClickNode,
      onRightEvent,
      onChangeCheckbox
    };
  }

};

const _hoisted_1$q = {
  key: 1,
  class: "el-tree-node__loading-icon el-icon-loading"
};

function render$L(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_checkbox = resolveComponent("el-checkbox");
  const _component_el_node_content = resolveComponent("el-node-content");
  const _component_el_tree_node = resolveComponent("el-tree-node");
  const _component_el_collapse_transition = resolveComponent("el-collapse-transition");

  return withDirectives((openBlock(), createBlock("div", {
    class: ["el-tree-node", {
      'is-expanded': $props.node.isExpanded,
      'is-current': $setup.elTree.ctx.dragState.current === $props.node,
      'is-hidden': !$props.node.isVisable,
      'is-focusable': !$props.node.isDisabled,
      'is-checked': $props.node.isChecked,
      'is-drop-inner':
        $setup.elTree.ctx.dragState.drop === 'inner' &&
        $setup.elTree.ctx.dragState.current === $props.node
    }],
    role: "TreeNode",
    tabindex: "-1",
    ref: "TreeNode",
    id: 'TreeNode' + $props.node.id,
    "aria-expanded": $props.node.isExpanded,
    "aria-disabled": $props.node.isDisabled,
    "aria-checked": $props.node.isChecked,
    draggable: $setup.elTree.props.draggable || $props.node.isDraggable,
    "data-node-id": $props.node.id,
    onContextmenu: _cache[3] || (_cache[3] = withModifiers((...args) => ($setup.onRightEvent(...args)), ["right","stop"])),
    onClick: _cache[4] || (_cache[4] = withModifiers((...args) => ($setup.onClickNode(...args)), ["stop"])),
    onDragstart: _cache[5] || (_cache[5] = withModifiers($event => ($setup.elTree.ctx.handleDragStart($props.node, $event)), ["stop"])),
    onDragover: _cache[6] || (_cache[6] = withModifiers($event => ($setup.elTree.ctx.handleDragOver($props.node, $event)), ["stop"])),
    onDragend: _cache[7] || (_cache[7] = withModifiers($event => ($setup.elTree.ctx.handleDragEnd($props.node, $event)), ["stop"])),
    onDrop: _cache[8] || (_cache[8] = withModifiers($event => ($setup.elTree.ctx.handleDrop($props.node, $event)), ["stop"]))
  }, [
    createVNode("div", {
      class: "el-tree-node__content",
      style: { 'padding-left': ($props.node.level - 1) * $setup.elTree.props.indent + 'px' }
    }, [
      createVNode("span", {
        class: [
          { expanded: $props.node.isExpanded, 'is-leaf': $props.node.isLeaf },
          'el-tree-node__expand-icon',
          $setup.elTree.props.iconClass
        ],
        onClick: _cache[1] || (_cache[1] = withModifiers($event => (
          $props.node.isLeaf ||
            ($setup.elTree.props.accordion ? $props.node.collapse() : $props.node.expand())
        ), ["stop"]))
      }, null, 2 /* CLASS */),
      ($setup.elTree.props.showCheckbox)
        ? (openBlock(), createBlock(_component_el_checkbox, {
            key: 0,
            modelValue: $props.node.isChecked,
            indeterminate: $props.node.isIndeterminate,
            disabled: $props.node.isDisabled,
            "onUpdate:modelValue": $setup.onChangeCheckbox,
            onClick: _cache[2] || (_cache[2] = $event => ($setup.elTree.emit('check', $props.node, $props.node.isChecked, $event)))
          }, null, 8 /* PROPS */, ["modelValue", "indeterminate", "disabled", "onUpdate:modelValue"]))
        : createCommentVNode("v-if", true),
      ($props.node.asyncState === 'loading')
        ? (openBlock(), createBlock("span", _hoisted_1$q))
        : createCommentVNode("v-if", true),
      createVNode(_component_el_node_content, {
        class: "el-tree-node__label",
        node: $props.node
      }, null, 8 /* PROPS */, ["node"])
    ], 4 /* STYLE */),
    createVNode(_component_el_collapse_transition, null, {
      default: withCtx(() => [
        (!$setup.elTree.props.renderAfterExpand || $props.node.isRendered)
          ? withDirectives((openBlock(), createBlock("div", {
              key: 0,
              class: "el-tree-node__children",
              role: "group",
              "aria-expanded": $props.node.isExpanded
            }, [
              (openBlock(true), createBlock(Fragment, null, renderList($props.node.childNodes, (child) => {
                return (openBlock(), createBlock(_component_el_tree_node, {
                  key: child.id,
                  node: child
                }, null, 8 /* PROPS */, ["node"]))
              }), 128 /* KEYED_FRAGMENT */))
            ], 8 /* PROPS */, ["aria-expanded"])), [
              [vShow, $props.node.isExpanded]
            ])
          : createCommentVNode("v-if", true)
      ]),
      _: 1
    })
  ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["id", "aria-expanded", "aria-disabled", "aria-checked", "draggable", "data-node-id"])), [
    [vShow, $props.node.isVisable]
  ])
}

script$Q.render = render$L;
script$Q.__file = "packages/tree/TreeNode.vue";

var script$R = {
  name: 'ElTree',
  components: {
    ElTreeNode: script$Q
  },
  props: {
    data: {
      type: Array,
      default: () => []
    },
    emptyText: {
      type: String,
      default: () => t('el.tree.emptyText')
    },
    renderAfterExpand: {
      type: Boolean,
      default: true
    },
    checkStrictly: Boolean,
    defaultExpandAll: Boolean,
    expandOnClickNode: {
      type: Boolean,
      default: true
    },
    checkOnClickNode: Boolean,
    checkDescendants: {
      type: Boolean,
      default: false
    },
    checked: Array
    /* model */
    ,
    expanded: Array
    /* model */
    ,
    currentNodeKey: [String, Number],
    renderContent: Function,
    showCheckbox: {
      type: Boolean,
      default: false
    },
    draggable: {
      type: Boolean,
      default: false
    },
    allowDrag: Function,
    allowDrop: Function,
    defaultNodeKey: {
      type: Object,
      default: () => ({
        id: 'id',
        label: 'label',
        childNodes: 'childNodes',
        isDisabled: 'isDisabled',
        isAsync: 'isAsync',
        isChecked: 'isChecked',
        isVisable: 'isVisable',
        isExpanded: 'isExpanded',
        isLeaf: 'isLeaf'
      })
    },
    // {treeNodeKey : rawNodeKey}
    highlightCurrent: Boolean,
    accordion: Boolean,
    indent: {
      type: Number,
      default: 18
    },
    iconClass: {
      type: String,
      default: 'el-icon-caret-right'
    },
    async: {
      type: Boolean,
      default: false
    },
    asyncLoadFn: Function,
    showRootNode: Boolean
  },
  emits: ['node-click', 'node-contextmenu', 'check-change', 'check', 'current-change', 'node-expand', 'node-collapse', 'node-drag-start', 'node-drag-enter', 'node-drag-leave', 'node-drag-over', 'node-drag-end', 'node-drop', 'update:checked', 'update:expanded'],

  setup(props) {
    const instance = getCurrentInstance();
    const tree = new Tree(props.data, props.defaultNodeKey, {
      asyncLoadFn: props.asyncLoadFn,
      isAsync: props.async
    });
    const state = reactive({
      tree
    });
    provide('elTree', instance);
    useTab();
    useExpand$1(props, state);
    useCheckbox(props, state);
    useFocusNode(props);
    const {
      handleKeydown
    } = useKeyDown$1();
    const drag = useDrag$1(props);
    return { ...drag,
      ...toRefs(state),
      ...extractMethods(state.tree.root, ['append', 'remove', 'insert', 'removeChild', 'setChecked', 'setChildChecked', 'upwardEach', 'depthEach', 'findOne', 'findMany', 'findChildIndex', 'expand', 'setVsiable', 'move', 'filter']),
      ...extractMethods(state.tree, ['initRoot', 'getParentRawNode', 'showAll', 'checkedAll', 'expandAll']),
      tree: state.tree,
      root: state.tree.root,
      handleKeydown
    };
  }

};

function useCheckbox(props, state) {
  const instance = getCurrentInstance();
  const {
    emit
  } = instance;
  watchEffect(() => {
    emit('update:checked', state.tree.checked);
  });
  watchEffect(() => {
    state.tree.setCheckedByIdList(props.checked, true);
  });
}

function useExpand$1(props, state) {
  const instance = getCurrentInstance();
  const {
    emit
  } = instance;

  if (props.defaultExpandAll) {
    state.tree.expandAll();
  }

  watchEffect(() => {
    emit('update:expanded', state.tree.expanded);
  });
  watchEffect(() => {
    state.tree.setExpandedByIdList(props.expanded, true);
  });
  onMounted(() => {
    state.tree.root.expand(true);
  });
}

function useTab() {
  const instance = getCurrentInstance();
  const {
    ctx
  } = instance;

  const initCheckbox = () => {
    const checkboxItems = ctx.$el.querySelectorAll('input[type=checkbox]');
    Array.prototype.forEach.call(checkboxItems, checkbox => {
      checkbox.setAttribute('tabindex', -1);
    });
  };

  const initTabIndex = () => {
    const treeItems = ctx.$el.querySelectorAll('.is-focusable[role=TreeItem]');
    const checkedItem = ctx.$el.querySelectorAll('.is-checked[role=TreeItem]');

    if (checkedItem.length) {
      checkedItem[0].setAttribute('tabindex', 0);
      return;
    }

    treeItems[0] && treeItems[0].setAttribute('tabindex', 0);
  };

  onMounted(initTabIndex);
  onUpdated(initCheckbox);
}

function useKeyDown$1() {
  const instance = getCurrentInstance();
  const {
    ctx
  } = instance;

  const handleKeydown = ev => {
    const currentItem = ev.target;
    if (currentItem.className.indexOf('el-tree-node') === -1) return;
    const {
      key
    } = ev;
    const treeItems = ctx.$el.querySelectorAll('.is-focusable[role=TreeNode]');
    const treeItemArray = Array.prototype.slice.call(treeItems);
    const currentIndex = treeItemArray.indexOf(currentItem);
    let nextIndex;

    if (['ArrowUp', 'ArrowDown'].indexOf(key) > -1) {
      // up、down
      ev.preventDefault();

      if (key === 'ArrowUp') {
        // up
        nextIndex = currentIndex !== 0 ? currentIndex - 1 : 0;
      } else {
        nextIndex = currentIndex < treeItemArray.length - 1 ? currentIndex + 1 : 0;
      }

      treeItemArray[nextIndex].focus(); // 选中
    }

    if (['ArrowLeft', 'ArrowRight'].indexOf(key) > -1) {
      // left、right 展开
      currentItem.click(); // 选中

      ev.preventDefault();
    }

    const hasInput = currentItem.querySelector('[type="checkbox"]');

    if (['Enter', 'Space'].indexOf(key) > -1 && hasInput) {
      // space enter选中checkbox
      hasInput.click();
      ev.preventDefault();
    }
  };

  return {
    handleKeydown
  };
}

function useDrag$1(props) {
  const instance = getCurrentInstance();
  const {
    emit
  } = instance;
  const dropIndicator = ref();
  const dragState = reactive({
    start: null
    /* TreeNode */
    ,
    current: null
    /* TreeNode */
    ,
    last: null
    /* TreeNode */
    ,
    drop: ''
    /* String => inner | top | bottom */

  });

  const handleDragStart = (node, e) => {
    if (typeof props.allowDrag === 'function' && !props.allowDrag(node, e)) {
      e.preventDefault();
      return false;
    }

    dragState.start = node;
    emit('node-drag-start', node, e);
  };

  const handleDragOver = (node, e) => {
    dragState.current = node;
    if (dragState.start === node) return;
    const margin = 7;
    const target = e.path.find(item => item.id === 'TreeNode' + node.id);
    const currentBound = target.getBoundingClientRect();
    const mourseY = e.clientY;

    if (currentBound.top + margin > mourseY) {
      dropIndicator.value.style.top = target.offsetTop + 'px';
      dropIndicator.value.style.left = node.level * props.indent + 'px';
      dragState.drop = 'top';
    } else if (currentBound.top + currentBound.height - margin < mourseY) {
      dropIndicator.value.style.top = target.offsetTop + currentBound.height + 'px';
      dropIndicator.value.style.left = node.level * props.indent + 'px';
      dragState.drop = 'bottom';
    } else {
      dragState.drop = 'inner';
      node.expand(true);
    } // wrap in try catch to address IE's error when first param is 'text/plain'
    // setData is required for draggable to work in FireFox
    // the content has to be '' so dragging a node out of the tree won't open a new tab in FireFox


    e && e.dataTransfer && isFunction(e.dataTransfer.setData) && e.dataTransfer.setData('text/plain', '');
    e.preventDefault();
    emit('node-drag-enter', dragState.start, node, e);
    emit('node-drag-over', dragState.start, node, e);
    emit('node-drag-leave', dragState.start, dragState.last, e);
    dragState.last = node;
  };

  const handleDragEnd = (node, e) => {
    dragState.current = null;
    emit('node-drag-end', dragState.start, node, e);
  };

  const handleDrop = (node, e) => {
    if (typeof props.allowDrog === 'function' && !props.allowDrog(dragState.start, node, dragState.drop, e)) {
      e.preventDefault();
      return false;
    }

    dragState.last = node;
    dragState.start.move(node, dragState.drop);
    emit('node-drop', dragState.start, node, e);
  };

  return {
    dragState,
    dropIndicator,
    handleDragStart,
    handleDragOver,
    handleDragEnd,
    handleDrop
  };
}

function useFocusNode(props) {
  onMounted(() => {
    if (props.currentNodeKey) {
      const node = document.getElementById('TreeNode' + props.currentNodeKey);

      if (node) {
        node.focus();
      }
    }
  });
}

const _hoisted_1$r = {
  key: 2,
  class: "el-tree__empty-block"
};
const _hoisted_2$i = { class: "el-tree__empty-text" };
const _hoisted_3$e = {
  class: "el-tree__drop-indicator",
  ref: "dropIndicator"
};

function render$M(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tree_node = resolveComponent("el-tree-node");

  return (openBlock(), createBlock("div", {
    class: ["el-tree", {
      'el-tree--highlight-current': $props.highlightCurrent
    }],
    role: "Tree",
    onKeydown: _cache[1] || (_cache[1] = (...args) => ($setup.handleKeydown(...args)))
  }, [
    ($props.showRootNode)
      ? (openBlock(), createBlock(_component_el_tree_node, {
          node: $setup.tree.root,
          key: $setup.tree.root.id
        }, null, 8 /* PROPS */, ["node"]))
      : (openBlock(true), createBlock(Fragment, { key: 1 }, renderList($setup.tree.root.childNodes, (child) => {
          return (openBlock(), createBlock(_component_el_tree_node, {
            node: child,
            key: child.id
          }, null, 8 /* PROPS */, ["node"]))
        }), 128 /* KEYED_FRAGMENT */)),
    ($setup.tree.isEmpty)
      ? (openBlock(), createBlock("div", _hoisted_1$r, [
          createVNode("span", _hoisted_2$i, toDisplayString($props.emptyText), 1 /* TEXT */)
        ]))
      : createCommentVNode("v-if", true),
    withDirectives(createVNode("div", _hoisted_3$e, null, 512 /* NEED_PATCH */), [
      [vShow, 
        _ctx.dragState.current &&
        (_ctx.dragState.drop === 'top' || _ctx.dragState.drop === 'bottom')
      ]
    ])
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$R.render = render$M;
script$R.__file = "packages/tree/Tree.vue";

/* istanbul ignore next */

script$R.install = function (app) {
  app.component(script$R.name, script$R);
};

var script$S = {
  name: 'ElPager',
  props: {
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      default: 5
    },
    pagerCount: {
      type: Number,
      default: 7
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ['update:currentPage'],

  setup(props, {
    emit
  }) {
    const {
      currentPage,
      pageCount,
      pagerCount,
      disabled
    } = toRefs(props);
    const {
      quickClass,
      showMore,
      onMouseEnter
    } = useClass();
    const {
      pagers,
      onPagerClick
    } = usePager({
      currentPage,
      pageCount,
      pagerCount,
      showMore,
      disabled,
      emit
    });
    return {
      // state
      pagers,
      showMore,
      quickClass,
      // method
      onMouseEnter,
      onPagerClick
    };
  }

};

const useClass = () => {
  const showMore = reactive({
    left: false,
    right: false
  });
  const quickClass = reactive({
    left: 'el-icon-more',
    right: 'el-icon-more'
  });
  watch(showMore, v => {
    for (const vKey in v) {
      if (!v[vKey]) quickClass[vKey] = 'el-icon-more';
    }
  });

  const onMouseEnter = direction => {
    quickClass[direction] = `el-icon-d-arrow-${direction}`;
  };

  return {
    showMore,
    quickClass,
    onMouseEnter
  };
};

const usePager = ({
  currentPage,
  pageCount,
  pagerCount,
  showMore,
  disabled,
  emit
}) => {
  const pagers = computed(() => {
    const pagerValue = pagerCount.value;
    const halfPagerCount = (pagerValue - 1) / 2;
    const currentValue = Number(currentPage.value);
    const pageValue = Number(pageCount.value);
    let showPrevMore = false;
    let showNextMore = false;

    if (pageValue > pagerValue) {
      if (currentValue > pagerValue - halfPagerCount) showPrevMore = true;
      if (currentValue < pageValue - halfPagerCount) showNextMore = true;
    }

    const array = [];

    if (showPrevMore && !showNextMore) {
      const startPage = pageValue - (pagerValue - 2);

      for (let i = startPage; i < pageValue; i++) {
        array.push(i);
      }
    } else if (!showPrevMore && showNextMore) {
      for (let i = 2; i < pagerValue; i++) {
        array.push(i);
      }
    } else if (showPrevMore && showNextMore) {
      const offset = Math.floor(pagerValue / 2) - 1;

      for (let i = currentValue - offset; i <= currentValue + offset; i++) {
        array.push(i);
      }
    } else {
      for (let i = 2; i < pageValue; i++) {
        array.push(i);
      }
    }

    showMore.left = showPrevMore;
    showMore.right = showNextMore;
    return array;
  });

  const onPagerClick = event => {
    const target = event.target;

    if (target.tagName === 'UL' || disabled.value) {
      return;
    }

    let newPage = Number(event.target.textContent);
    const pagerCountOffset = pagerCount.value - 2;

    if (target.className.indexOf('more') !== -1) {
      if (target.className.indexOf('quickprev') !== -1) {
        newPage = currentPage.value - pagerCountOffset;
      } else if (target.className.indexOf('quicknext') !== -1) {
        newPage = +currentPage.value + pagerCountOffset;
      }
    }
    /* istanbul ignore if */


    if (!isNaN(newPage)) {
      if (newPage < 1) newPage = 1;
      if (newPage > pageCount.value) newPage = pageCount.value;
    }

    if (newPage !== currentPage.value) emit('update:currentPage', newPage);
  };

  return {
    pagers,
    onPagerClick
  };
};

function render$N(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("ul", {
    onClick: _cache[5] || (_cache[5] = (...args) => ($setup.onPagerClick(...args))),
    class: "el-pager"
  }, [
    ($props.pageCount > 0)
      ? (openBlock(), createBlock("li", {
          key: 0,
          class: [{ active: $props.currentPage === 1, disabled: $props.disabled }, "number"]
        }, " 1 ", 2 /* CLASS */))
      : createCommentVNode("v-if", true),
    ($setup.showMore.left)
      ? (openBlock(), createBlock("li", {
          key: 1,
          class: ["el-icon more btn-quickprev", [$setup.quickClass.left, { disabled: $props.disabled }]],
          onMouseenter: _cache[1] || (_cache[1] = $event => ($setup.onMouseEnter('left'))),
          onMouseleave: _cache[2] || (_cache[2] = $event => ($setup.quickClass.left = 'el-icon-more'))
        }, null, 34 /* CLASS, HYDRATE_EVENTS */))
      : createCommentVNode("v-if", true),
    (openBlock(true), createBlock(Fragment, null, renderList($setup.pagers, (pager) => {
      return (openBlock(), createBlock("li", {
        key: pager,
        class: [{ active: $props.currentPage === pager, disabled: $props.disabled }, "number"]
      }, toDisplayString(pager), 3 /* TEXT, CLASS */))
    }), 128 /* KEYED_FRAGMENT */)),
    ($setup.showMore.right)
      ? (openBlock(), createBlock("li", {
          key: 2,
          class: ["el-icon more btn-quicknext", [$setup.quickClass.right, { disabled: $props.disabled }]],
          onMouseenter: _cache[3] || (_cache[3] = $event => ($setup.onMouseEnter('right'))),
          onMouseleave: _cache[4] || (_cache[4] = $event => ($setup.quickClass.right = 'el-icon-more'))
        }, null, 34 /* CLASS, HYDRATE_EVENTS */))
      : createCommentVNode("v-if", true),
    ($props.pageCount > 1)
      ? (openBlock(), createBlock("li", {
          key: 3,
          class: [{ active: $props.currentPage === $props.pageCount, disabled: $props.disabled }, "number"]
        }, toDisplayString($props.pageCount), 3 /* TEXT, CLASS */))
      : createCommentVNode("v-if", true)
  ]))
}

script$S.render = render$N;
script$S.__file = "packages/pagination/components/Pager.vue";

var script$T = {
  name: 'Prev',
  props: {
    currentPage: {
      type: Number,
      default: 1
    },
    disabled: {
      type: Boolean,
      default: false
    },
    prevText: {
      type: String,
      default: ''
    },
    prev: Function
  },

  setup(props) {
    const isDisabled = computed(() => props.disabled || props.currentPage <= 1);
    return { ...toRefs(props),
      isDisabled
    };
  }

};

const _hoisted_1$s = { key: 0 };
const _hoisted_2$j = {
  key: 1,
  class: "el-icon el-icon-arrow-left"
};

function render$O(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("button", {
    type: "button",
    class: "btn-prev",
    disabled: $setup.isDisabled,
    onClick: _cache[1] || (_cache[1] = (...args) => ($props.prev(...args)))
  }, [
    ($props.prevText)
      ? (openBlock(), createBlock("span", _hoisted_1$s, toDisplayString($props.prevText), 1 /* TEXT */))
      : (openBlock(), createBlock("i", _hoisted_2$j))
  ], 8 /* PROPS */, ["disabled"]))
}

script$T.render = render$O;
script$T.__file = "packages/pagination/components/Prev.vue";

var script$U = {
  name: 'Next',
  props: {
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      default: 1
    },
    disabled: {
      type: Boolean,
      default: false
    },
    nextText: {
      type: String,
      default: ''
    },
    next: Function
  },

  setup(props) {
    const isDisabled = computed(() => props.disabled || props.currentPage === props.pageCount || props.pageCount === 0);
    return { ...toRefs(props),
      isDisabled
    };
  }

};

const _hoisted_1$t = { key: 0 };
const _hoisted_2$k = {
  key: 1,
  class: "el-icon el-icon-arrow-right"
};

function render$P(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("button", {
    type: "button",
    class: "btn-next",
    disabled: $setup.isDisabled,
    onClick: _cache[1] || (_cache[1] = (...args) => ($props.next(...args)))
  }, [
    ($props.nextText)
      ? (openBlock(), createBlock("span", _hoisted_1$t, toDisplayString($props.nextText), 1 /* TEXT */))
      : (openBlock(), createBlock("i", _hoisted_2$k))
  ], 8 /* PROPS */, ["disabled"]))
}

script$U.render = render$P;
script$U.__file = "packages/pagination/components/Next.vue";

var script$V = {
  name: 'Jumper',
  components: {
    ElInput: script$g
  },
  props: {
    currentPage: {
      type: Number,
      default: 1
    },
    pageCount: {
      type: Number,
      default: 5
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: ['change'],

  setup(props, {
    emit
  }) {
    const userInput = ref(null);
    const {
      currentPage
    } = toRefs(props);
    const t = useLocale();
    const showValue = computed(() => {
      var _userInput$value;

      return (_userInput$value = userInput.value) !== null && _userInput$value !== void 0 ? _userInput$value : currentPage.value;
    });

    const handleInput = val => {
      userInput.value = val;
    };

    const handleChange = val => {
      emit('change', val);
      userInput.value = null;
    };

    return {
      // state
      showValue,
      // method
      t,
      handleInput,
      handleChange
    };
  }

};

const _hoisted_1$u = { class: "el-pagination__jump" };

function render$Q(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");

  return (openBlock(), createBlock("span", _hoisted_1$u, [
    createTextVNode(toDisplayString($setup.t('el.pagination.goto')) + " ", 1 /* TEXT */),
    createVNode(_component_el_input, {
      class: "el-pagination__editor is-in-pagination",
      min: 1,
      max: $props.pageCount,
      modelValue: $setup.showValue,
      type: "number",
      disabled: $props.disabled,
      onInput: $setup.handleInput,
      onChange: $setup.handleChange
    }, null, 8 /* PROPS */, ["max", "modelValue", "disabled", "onInput", "onChange"]),
    createTextVNode(" " + toDisplayString($setup.t('el.pagination.pageClassifier')), 1 /* TEXT */)
  ]))
}

script$V.render = render$Q;
script$V.__file = "packages/pagination/components/Jumper.vue";

const Total = props => {
  return typeof props.total === 'number' ? h('span', {
    class: 'el-pagination__total'
  }, useLocale()('el.pagination.total', {
    total: props.total
  })) : '';
};

var script$W = {
  name: 'Sizes',
  components: {
    ElSelect: script$l,
    ElOption: script$j
  },
  props: {
    pageSizes: Array,
    pageSize: Number,
    popperClass: String,
    handleChange: Function,
    disabled: Boolean,
    watchHandler: Function
  },

  setup(props) {
    const {
      popperClass,
      pageSizes
    } = toRefs(props);
    const t = useLocale();
    const internalPopperClass = computed(() => (popperClass === null || popperClass === void 0 ? void 0 : popperClass.value) || '');
    watch(pageSizes, props.watchHandler);
    return { // state
      ...toRefs(props),
      internalPopperClass,
      // methods
      t
    };
  }

};

const _hoisted_1$v = { class: "el-pagination__sizes" };

function render$R(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_option = resolveComponent("el-option");
  const _component_el_select = resolveComponent("el-select");

  return (openBlock(), createBlock("span", _hoisted_1$v, [
    createVNode(_component_el_select, {
      modelValue: $props.pageSize,
      popperClass: $setup.internalPopperClass,
      size: "mini",
      onChange: $props.handleChange,
      disabled: $props.disabled
    }, {
      default: withCtx(() => [
        (openBlock(true), createBlock(Fragment, null, renderList($props.pageSizes, (item) => {
          return (openBlock(), createBlock(_component_el_option, {
            value: item,
            label: item + $setup.t('el.pagination.pagesize'),
            key: item
          }, null, 8 /* PROPS */, ["value", "label"]))
        }), 128 /* KEYED_FRAGMENT */))
      ]),
      _: 1
    }, 8 /* PROPS */, ["modelValue", "popperClass", "onChange", "disabled"])
  ]))
}

script$W.render = render$R;
script$W.__file = "packages/pagination/components/Sizes.vue";

const useLayout = layout => {
  const template = [];
  const rightWrapper = [];
  const components = layout.split(',').map(item => item.trim());
  const findIndex = components.findIndex(item => item === '->');

  for (let i = 0; i < components.length; i++) {
    if (findIndex >= 0) {
      if (i === findIndex) continue;

      if (i < findIndex) {
        template.push(components[i]);
      } else {
        rightWrapper.push(components[i]);
      }
    } else {
      template.push(components[i]);
    }
  }

  return {
    template,
    rightWrapper
  };
};

const getValidCurrentPage = (value, pageCount) => {
  var _resetValue;

  value = parseInt(value, 10);
  const havePageCount = typeof pageCount === 'number';
  let resetValue;

  if (!havePageCount) {
    if (isNaN(value) || value < 1) resetValue = 1;
  } else {
    if (value < 1) {
      resetValue = 1;
    } else if (value > pageCount) {
      resetValue = pageCount;
    }
  }

  if (resetValue === undefined && isNaN(value) || resetValue === 0) {
    resetValue = 1;
  }

  return (_resetValue = resetValue) !== null && _resetValue !== void 0 ? _resetValue : value;
};

const useInternalCurrentPage = ({
  currentPage,
  emit,
  emitted
}) => {
  const innerCurrentPage = ref(null);
  return computed({
    get() {
      var _ref, _innerCurrentPage$val;

      return (_ref = (_innerCurrentPage$val = innerCurrentPage.value) !== null && _innerCurrentPage$val !== void 0 ? _innerCurrentPage$val : currentPage === null || currentPage === void 0 ? void 0 : currentPage.value) !== null && _ref !== void 0 ? _ref : 1;
    },

    set(v) {
      emit('update:currentPage', v);
      emit('currentChange', v);

      if (currentPage) {
        watch(currentPage, () => {
          emitted.value = true;
        });
      }

      if (emitted.value) innerCurrentPage.value = null;else innerCurrentPage.value = v;
      emitted.value = false;
    }

  });
};

const userInternalPageSize = ({
  pageSize,
  emit,
  emitted
}) => {
  const innerPageSize = ref(null);
  return computed({
    get() {
      var _innerPageSize$value;

      return (_innerPageSize$value = innerPageSize.value) !== null && _innerPageSize$value !== void 0 ? _innerPageSize$value : pageSize.value;
    },

    set(v) {
      emit('update:pageSize', v);
      emit('sizeChange', v);
      innerPageSize.value = v;

      if (pageSize) {
        watch(pageSize, () => {
          emitted.value = true;
        });
      }

      if (emitted.value) innerPageSize.value = null;
      emitted.value = false;
    }

  });
};

const useInternalPageCount = ({
  pageCount,
  total,
  pageSize
}) => {
  const internalPageCount = computed(() => {
    if (!total && !pageCount) return 5;

    if (typeof (total === null || total === void 0 ? void 0 : total.value) === 'number') {
      return Math.max(1, Math.ceil(total.value / pageSize.value));
    } else if (typeof (pageCount === null || pageCount === void 0 ? void 0 : pageCount.value) === 'number') {
      return Math.max(1, pageCount.value);
    }
  });
  return {
    internalPageCount
  };
};

var ElPagination = {
  name: 'ElPagination',
  props: {
    pageSize: {
      type: Number,
      default: 10
    },
    small: Boolean,
    total: Number,
    pageCount: Number,
    pagerCount: {
      type: Number,

      validator(value) {
        return (value || 0) === value && value > 4 && value < 22 && value % 2 === 1;
      },

      default: 7
    },
    currentPage: {
      type: Number,
      default: 1
    },
    layout: {
      default: 'prev, pager, next, jumper, ->, total'
    },
    pageSizes: {
      type: Array,

      default() {
        return [10, 20, 30, 40, 50, 100];
      }

    },
    popperClass: String,
    prevText: String,
    nextText: String,
    background: Boolean,
    disabled: Boolean,
    hideOnSinglePage: Boolean
  },
  emits: ['update:currentPage', 'update:pageSize', 'currentChange', 'sizeChange', 'prevClick', 'nextClick'],

  setup(props, {
    emit
  }) {
    const currentPageEmitted = ref(false);
    const pageSizeEmitted = ref(false);
    const {
      currentPage,
      total,
      pageCount,
      pageSize,
      disabled,
      pageSizes
    } = toRefs(props);
    const internalCurrentPage = useInternalCurrentPage({
      currentPage,
      emit,
      emitted: currentPageEmitted
    });
    const internalPageSize = userInternalPageSize({
      pageSize,
      pageSizes,
      emit,
      emitted: pageSizeEmitted
    });
    const {
      internalPageCount
    } = useInternalPageCount({
      pageCount,
      total,
      pageSize: internalPageSize
    });
    return {
      // state
      internalCurrentPage,
      internalPageCount,
      internalPageSize,

      // methods
      prev() {
        if (disabled.value) return;
        internalCurrentPage.value = getValidCurrentPage(internalCurrentPage.value - 1, internalPageCount.value);
        emit('prevClick', internalCurrentPage.value);
      },

      next() {
        if (disabled.value) return;
        internalCurrentPage.value = getValidCurrentPage(internalCurrentPage.value + 1, internalPageCount.value);
        emit('nextClick', internalCurrentPage.value);
      },

      onUpdate(val) {
        internalCurrentPage.value = val;
      },

      handleChange(val) {
        internalCurrentPage.value = getValidCurrentPage(val, internalPageCount.value);
      },

      handleSizeChange(val) {
        if (val !== internalPageSize.value) {
          internalPageSize.value = val = parseInt(val, 10);
        }
      },

      watchHandler(newValue) {
        if (valueEquals(newValue, pageSizes.value)) return;

        if (Array.isArray(newValue)) {
          internalPageSize.value = newValue.indexOf(internalPageSize.value) > -1 ? internalPageSize.value : pageSizes.value[0];
        }
      }

    };
  },

  render() {
    var _this$$slots$default, _this$$slots;

    if (!this.layout || this.hideOnSinglePage && this.internalPageCount === 1) return '';
    const {
      template,
      rightWrapper
    } = useLayout(this.layout);
    const templateComponent = {
      prev: createVNode(script$T, {
        "currentPage": this.internalCurrentPage,
        "disabled": this.disabled,
        "prevText": this.prevText,
        "prev": this.prev
      }, null),
      jumper: createVNode(script$V, {
        "currentPage": this.internalCurrentPage,
        "pageCount": this.internalPageCount,
        "disabled": this.disabled,
        "onChange": this.handleChange
      }, null),
      pager: createVNode(script$S, {
        "currentPage": this.internalCurrentPage,
        "onUpdate:currentPage": this.onUpdate,
        "pageCount": this.internalPageCount,
        "disabled": this.disabled
      }, null),
      next: createVNode(script$U, {
        "currentPage": this.internalCurrentPage,
        "pageCount": this.internalPageCount,
        "disabled": this.disabled,
        "nextText": this.nextText,
        "next": this.next
      }, null),
      sizes: createVNode(script$W, {
        "pageSizes": this.pageSizes,
        "pageSize": this.internalPageSize,
        "popperClass": this.popperClass,
        "handleChange": this.handleSizeChange,
        "disabled": this.disabled,
        "watchHandler": this.watchHandler
      }, null),
      slot: createVNode(Fragment, null, [(_this$$slots$default = (_this$$slots = this.$slots).default) === null || _this$$slots$default === void 0 ? void 0 : _this$$slots$default.call(_this$$slots)]),
      total: createVNode(Total, {
        "total": this.total
      }, null)
    };
    return createVNode("div", {
      "class": ['el-pagination', {
        'is-background': this.background,
        'el-pagination--small': this.small
      }]
    }, [rightWrapper.length ? createVNode("div", {
      "className": "el-pagination__rightwrapper"
    }, [rightWrapper.map(item => {
      const Comp = templateComponent[item];
      return createVNode(Comp, null, null);
    })]) : '', template.map(item => {
      const Comp = templateComponent[item];
      return createVNode(Comp, null, null);
    })]);
  }

};

/* istanbul ignore next */

ElPagination.install = function (app) {
  app.component(ElPagination.name, ElPagination);
};

var script$X = {
  name: 'ElBadge',
  props: {
    value: [String, Number],
    max: Number,
    isDot: Boolean,
    hidden: Boolean,
    type: {
      type: String,

      validator(val) {
        return ['primary', 'success', 'warning', 'info', 'danger'].indexOf(val) > -1;
      }

    }
  },

  setup(props) {
    const {
      isDot,
      max,
      value
    } = toRefs(props);
    const content = useContent$1(isDot, max, value);
    return {
      content
    };
  }

};

const useContent$1 = (isDot, max, value) => {
  const content = computed(() => {
    if (isDot.value) return;

    if (max && typeof value.value === 'number' && typeof max.value === 'number') {
      return max.value < value.value ? `${max.value}+` : value.value;
    }

    return value.value;
  });
  return content;
};

const _hoisted_1$w = { class: "el-badge" };

function render$S(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$w, [
    renderSlot(_ctx.$slots, "default"),
    createVNode(Transition, { name: "el-zoom-in-center" }, {
      default: withCtx(() => [
        withDirectives(createVNode("sup", {
          textContent: toDisplayString($setup.content),
          class: ["el-badge__content", [
          'el-badge__content--' + $props.type,
          {
            'is-fixed': _ctx.$slots.default,
            'is-dot': $props.isDot
          }
        ]]
        }, null, 10 /* CLASS, PROPS */, ["textContent"]), [
          [vShow, !$props.hidden && ($setup.content || $setup.content === 0 || $props.isDot)]
        ])
      ]),
      _: 1
    })
  ]))
}

script$X.render = render$S;
script$X.__file = "packages/badge/Badge.vue";

/* istanbul ignore next */

script$X.install = function (app) {
  app.component(script$X.name, script$X);
};

var script$Y = {
  name: 'ElAvatar',
  props: {
    size: {
      type: [Number, String],
      default: 'large',

      validator(val) {
        if (typeof val === 'string') {
          return ['large', 'medium', 'small'].includes(val);
        }

        return typeof val === 'number';
      }

    },
    shape: {
      type: String,
      default: 'circle',

      validator(val) {
        return ['circle', 'square'].includes(val);
      }

    },
    icon: String,
    src: String,
    alt: String,
    srcSet: String,
    error: Function,
    fit: {
      type: String,
      default: 'cover'
    }
  },

  setup(props) {
    const {
      error,
      size,
      icon,
      shape
    } = toRefs(props);
    const isImageExist = ref(true);

    const handleError = e => {
      const errorFlag = error === null || error === void 0 ? void 0 : error.value(e);

      if (!!errorFlag !== false) {
        isImageExist.value = false;
      }
    };

    const sizeStyle = useSizeStyle(size);
    const avatarClass = useAvatarClass(size, icon, shape);
    return {
      isImageExist,
      handleError,
      sizeStyle,
      avatarClass
    };
  }

};

const useSizeStyle = size => {
  return computed(() => {
    return size && typeof size.value === 'number' ? {
      height: `${size.value}px`,
      width: `${size.value}px`,
      lineHeight: `${size.value}px`
    } : {};
  });
};

const useAvatarClass = (size, icon, shape) => {
  return computed(() => {
    const classList = ['el-avatar'];

    if (size && typeof size.value === 'string') {
      classList.push(`el-avatar--${size.value}`);
    }

    if (icon) {
      classList.push('el-avatar--icon');
    }

    if (shape) {
      classList.push(`el-avatar--${shape.value}`);
    }

    return classList.join(' ');
  });
};

function render$T(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("span", {
    class: $setup.avatarClass,
    style: $setup.sizeStyle
  }, [
    ($setup.isImageExist && $props.src)
      ? (openBlock(), createBlock("img", {
          key: 0,
          src: $props.src,
          onError: _cache[1] || (_cache[1] = (...args) => ($setup.handleError(...args))),
          alt: $props.alt,
          srcSet: $props.srcSet,
          style: { 'object-fit': $props.fit }
        }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, ["src", "alt", "srcSet"]))
      : ($props.icon)
        ? (openBlock(), createBlock("i", {
            key: 1,
            class: $props.icon
          }, null, 2 /* CLASS */))
        : renderSlot(_ctx.$slots, "default", { key: 2 })
  ], 6 /* CLASS, STYLE */))
}

script$Y.render = render$T;
script$Y.__file = "packages/avatar/Avatar.vue";

/* istanbul ignore next */

script$Y.install = function (app) {
  app.component(script$Y.name, script$Y);
};

const TYPE_CLASSES_MAP = {
  success: 'el-icon-success',
  warning: 'el-icon-warning',
  error: 'el-icon-error'
};
var script$Z = {
  name: 'ElAlert',
  props: {
    title: {
      type: String,
      default: ''
    },
    description: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      default: 'info'
    },
    closable: {
      type: Boolean,
      default: true
    },
    closeText: {
      type: String,
      default: ''
    },
    showIcon: Boolean,
    center: Boolean,
    effect: {
      type: String,
      default: 'light',
      validator: function (value) {
        return ['light', 'dark'].indexOf(value) !== -1;
      }
    }
  },
  emits: ['close'],

  setup(props, {
    emit,
    slots
  }) {
    const {
      description,
      type
    } = toRefs(props);
    const visible = ref(true);

    const close = () => {
      visible.value = false;
      emit('close');
    };

    const typeClass = computed(() => {
      return `el-alert--${type.value}`;
    });
    const iconClass = computed(() => {
      return TYPE_CLASSES_MAP[type.value] || 'el-icon-info';
    });
    const isBigIcon = computed(() => {
      return description.value || slots.default ? 'is-big' : '';
    });
    const isBoldTitle = computed(() => {
      return description.value || slots.default ? 'is-bold' : '';
    });
    return {
      visible,
      typeClass,
      iconClass,
      isBigIcon,
      isBoldTitle,
      close
    };
  }

};

const _hoisted_1$x = { class: "el-alert__content" };
const _hoisted_2$l = {
  key: 1,
  class: "el-alert__description"
};
const _hoisted_3$f = {
  key: 2,
  class: "el-alert__description"
};

function render$U(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, { name: "el-alert-fade" }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        class: ["el-alert", [$setup.typeClass, $props.center ? 'is-center' : '', 'is-' + $props.effect]],
        role: "alert"
      }, [
        ($props.showIcon)
          ? (openBlock(), createBlock("i", {
              key: 0,
              class: ["el-alert__icon", [$setup.iconClass, $setup.isBigIcon]]
            }, null, 2 /* CLASS */))
          : createCommentVNode("v-if", true),
        createVNode("div", _hoisted_1$x, [
          ($props.title || _ctx.$slots.title)
            ? (openBlock(), createBlock("span", {
                key: 0,
                class: ["el-alert__title", [$setup.isBoldTitle]]
              }, [
                renderSlot(_ctx.$slots, "title", {}, () => [
                  createTextVNode(toDisplayString($props.title), 1 /* TEXT */)
                ])
              ], 2 /* CLASS */))
            : createCommentVNode("v-if", true),
          (_ctx.$slots.default && !$props.description)
            ? (openBlock(), createBlock("p", _hoisted_2$l, [
                renderSlot(_ctx.$slots, "default")
              ]))
            : createCommentVNode("v-if", true),
          ($props.description && !_ctx.$slots.default)
            ? (openBlock(), createBlock("p", _hoisted_3$f, toDisplayString($props.description), 1 /* TEXT */))
            : createCommentVNode("v-if", true),
          withDirectives(createVNode("i", {
            class: ["el-alert__closebtn", {
            'is-customed': $props.closeText !== '',
            'el-icon-close': $props.closeText === ''
          }],
            onClick: _cache[1] || (_cache[1] = (...args) => ($setup.close(...args)))
          }, toDisplayString($props.closeText), 3 /* TEXT, CLASS */), [
            [vShow, $props.closable]
          ])
        ])
      ], 2 /* CLASS */), [
        [vShow, $setup.visible]
      ])
    ]),
    _: 1
  }))
}

script$Z.render = render$U;
script$Z.__file = "packages/alert/Alert.vue";

/* istanbul ignore next */

script$Z.install = function (app) {
  app.component(script$Z.name, script$Z);
};

var script$_ = {
  inheritAttrs: false,
  props: {
    text: {
      type: String,
      default: null
    },
    spinner: {
      type: String,
      default: null
    },
    background: {
      type: String,
      default: null
    },
    fullscreen: {
      type: Boolean,
      default: true
    },
    visible: {
      type: Boolean,
      default: false
    },
    customClass: {
      type: String,
      default: ''
    }
  },

  setup(props, {
    emit
  }) {
    const $data = reactive({ ...props
    });

    const handleAfterLeave = () => {
      // TODO 这里的 emit 修改会造成对 api 的更改
      // eslint-disable-next-line vue/custom-event-name-casing
      emit('afterLeave');
    };

    const show = () => {
      $data.visible = true;
    };

    const close = () => {
      $data.visible = false;
    };

    const setText = text => {
      $data.text = text;
    };

    return { ...toRefs($data),
      handleAfterLeave,
      show,
      close,
      setText
    };
  }

};

const _hoisted_1$y = { class: "el-loading-spinner" };
const _hoisted_2$m = {
  key: 0,
  class: "circular",
  viewBox: "25 25 50 50"
};
const _hoisted_3$g = /*#__PURE__*/createVNode("circle", {
  class: "path",
  cx: "50",
  cy: "50",
  r: "20",
  fill: "none"
}, null, -1 /* HOISTED */);
const _hoisted_4$8 = {
  key: 2,
  class: "el-loading-text"
};

function render$V(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    name: "el-loading-fade",
    onAfterLeave: $setup.handleAfterLeave
  }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        class: ["el-loading-mask", [$props.customClass, { 'is-fullscreen': $props.fullscreen }]],
        style: { backgroundColor: $props.background || '' }
      }, [
        createVNode("div", _hoisted_1$y, [
          (!$props.spinner)
            ? (openBlock(), createBlock("svg", _hoisted_2$m, [
                _hoisted_3$g
              ]))
            : (openBlock(), createBlock("i", {
                key: 1,
                class: $props.spinner
              }, null, 2 /* CLASS */)),
          ($props.text)
            ? (openBlock(), createBlock("p", _hoisted_4$8, toDisplayString($props.text), 1 /* TEXT */))
            : createCommentVNode("v-if", true)
        ])
      ], 6 /* CLASS, STYLE */), [
        [vShow, $props.visible]
      ])
    ]),
    _: 1
  }, 8 /* PROPS */, ["onAfterLeave"]))
}

script$_.render = render$V;
script$_.__file = "packages/loading/Loading.vue";

const MOUNT_COMPONENT_REF = 'el_component';
const COMPONENT_CONTAINER_SYMBOL = Symbol('el_component_container');
/**
 * 创建组件实例对象
 * 返回的实例和调用 getCurrentComponent() 返回的一致
 * @param {*} Component
 */

function createComponent(Component, props, children) {
  const vnode = h(Component, { ...props,
    ref: MOUNT_COMPONENT_REF
  }, children);
  const container = document.createElement('div');
  vnode[COMPONENT_CONTAINER_SYMBOL] = container;
  render$1p(vnode, container);
  return vnode.component;
}
/**
 * 销毁组件实例对象
 * @param {*} ComponnetInstance 通过createComponent方法得到的组件实例对象
 */

function unmountComponent(ComponnetInstance) {
  render$1p(undefined, ComponnetInstance.vnode[COMPONENT_CONTAINER_SYMBOL]);
}

const addStyle = (options, parent, ctx) => {
  const maskStyle = {};

  if (options.fullscreen) {
    addClass(ctx.$el, 'is-fullscreen');
    ctx.originalPosition = getStyle(document.body, 'position');
    ctx.originalOverflow = getStyle(document.body, 'overflow');
    maskStyle.zIndex = PopupManager.nextZIndex();
  } else if (options.body) {
    removeClass(ctx.$el, 'is-fullscreen');
    ctx.originalPosition = getStyle(document.body, 'position');
    ['top', 'left'].forEach(property => {
      const scroll = property === 'top' ? 'scrollTop' : 'scrollLeft';
      maskStyle[property] = options.target.getBoundingClientRect()[property] + //         document.body[scroll] +
      document.documentElement[scroll] + 'px';
    });
    ['height', 'width'].forEach(property => {
      maskStyle[property] = options.target.getBoundingClientRect()[property] + 'px';
    });
  } else {
    ctx.originalPosition = getStyle(parent, 'position');
  }

  Object.keys(maskStyle).forEach(property => {
    ctx.$el.style[property] = maskStyle[property];
  });

  if (ctx.originalPosition !== 'absolute' && ctx.originalPosition !== 'fixed') {
    addClass(parent, 'el-loading-parent--relative');
  }

  if (options.fullscreen && options.lock) {
    addClass(parent, 'el-loading-parent--hidden');
  }
};

const defaults = {
  target: null,
  body: false,
  fullscreen: true,
  lock: false,
  text: null,
  spinner: null,
  background: null,
  customClass: ''
};

const toggleLoading = (el, binding) => {
  if (binding.value) {
    nextTick(() => {
      let parentEl = document.body;

      if (!binding.modifiers.fullscreen) {
        parentEl = el;
      }

      addStyle(el.options, parentEl, el.instance);
      el.instance.show();
      parentEl.appendChild(el.mask);
    });
  } else {
    el.instance.close();
  }
};

const loadingDirective = {
  mounted: function (el, binding, vnode) {
    const textExr = el.getAttribute('element-loading-text');
    const spinnerExr = el.getAttribute('element-loading-spinner');
    const backgroundExr = el.getAttribute('element-loading-background');
    const customClassExr = el.getAttribute('element-loading-custom-class');
    const vm = vnode.context;
    const options = merge({}, defaults, {
      text: vm && vm[textExr] || textExr,
      spinner: vm && vm[spinnerExr] || spinnerExr,
      background: vm && vm[backgroundExr] || backgroundExr,
      customClass: vm && vm[customClassExr] || customClassExr,
      fullscreen: !!binding.modifiers.fullscreen
    });
    const mask = createComponent(script$_, { ...options,

      onAfterLeave() {
        el.domVisible = false;
        const target = binding.modifiers.fullscreen || binding.modifiers.body ? document.body : el;
        removeClass(target, 'el-loading-parent--relative');
        removeClass(target, 'el-loading-parent--hidden');
      }

    });
    el.options = options;
    el.instance = mask.ctx;
    el.mask = mask.ctx.$el;
    el.maskStyle = {};
    binding.value && toggleLoading(el, binding);
  },
  updated: function (el, binding) {
    el.instance.setText(el.getAttribute('element-loading-text'));

    if (binding.oldValue !== binding.value) {
      toggleLoading(el, binding);
    }
  },
  unmounted: function () {// if (el.domInserted) {
    //   el.mask && el.mask.parentNode && el.mask.parentNode.removeChild(el.mask)
    //   toggleLoading(el, { value: false, modifiers: binding.modifiers })
    // }
    // el.instance && el.instance.close()
  }
};
var directive = {
  install(app) {
    // if (Vue.prototype.$isServer) return
    app.directive('loading', loadingDirective);
  }

};

const defaults$1 = {
  target: null,
  body: false,
  fullscreen: true,
  lock: false,
  text: null,
  spinner: null,
  background: null,
  customClass: ''
};
let fullscreenLoading;

const Loading = (options = {}) => {
  // if (Vue.prototype.$isServer) return
  options = merge({}, defaults$1, options);

  if (typeof options.target === 'string') {
    options.target = document.querySelector(options.target);
  }

  options.target = options.target || document.body;

  if (options.target !== document.body) {
    options.fullscreen = false;
  } else {
    options.body = true;
  }

  if (options.fullscreen && fullscreenLoading) {
    return fullscreenLoading;
  }

  const parent = options.body ? document.body : options.target;
  const instance = createComponent(script$_, { ...options,
    visible: true,

    onAfterLeave() {
      if (options.fullscreen) {
        fullscreenLoading = undefined;
      }

      const target = options.fullscreen || options.body ? document.body : options.target;
      removeClass(target, 'el-loading-parent--relative');
      removeClass(target, 'el-loading-parent--hidden');
      unmountComponent(instance);
    }

  });
  addStyle(options, parent, instance.ctx);
  parent.appendChild(instance.ctx.$el);

  if (options.fullscreen) {
    fullscreenLoading = instance;
  }

  instance.close = close;
  return instance;
};

const close = function () {
  this.ctx.close();
};

function useLoading() {
  return Loading;
}
var ElLoading = {
  install(app) {
    app.use(directive);
  },

  service: Loading,
  directive
};

const typeMap = {
  success: 'success',
  info: 'info',
  warning: 'warning',
  error: 'error'
};
var script$$ = {
  props: {
    id: {
      type: String,
      default: ''
    },
    message: {
      type: [String, Object],
      default: ''
    },
    duration: {
      type: Number,
      default: 3000
    },
    type: {
      type: String,
      default: 'info',

      validator(val) {
        return ['success', 'warning', 'info', 'error'].indexOf(val) > -1;
      }

    },
    iconClass: {
      type: String,
      default: ''
    },
    customClass: {
      type: String,
      default: ''
    },
    showClose: {
      type: Boolean,
      default: false
    },
    verticalOffset: {
      type: Number,
      default: 20
    },
    dangerouslyUseHTMLString: {
      type: Boolean,
      default: false
    },
    center: {
      type: Boolean,
      default: false
    },
    onClose: {
      type: Function,
      required: true
    }
  },

  setup(props) {
    const state = reactive({
      visible: true,
      closed: false,
      timer: null
    });
    const typeClass = computed(() => {
      return props.type && !props.iconClass ? `el-message__icon el-icon-${typeMap[props.type]}` : '';
    });
    const positionStyle = computed(() => ({
      top: `${props.verticalOffset}px`
    }));

    const close = () => {
      state.closed = true;

      if (typeof props.onClose === 'function') {
        props.onClose(this);
      }
    };

    const clearTimer = () => {
      clearTimeout(state.timer);
    };

    const startTimer = () => {
      if (props.duration > 0) {
        state.timer = setTimeout(() => {
          if (!state.closed) {
            close();
          }
        }, props.duration);
      }
    };

    const keydown = e => {
      if (e.keyCode === 27) {
        // esc关闭消息
        if (!state.closed) {
          props.onClose(this);
        }
      }
    };

    const handleAfterLeave = currentElement => {
      if (currentElement && currentElement.parentNode) {
        currentElement.parentNode.removeChild(currentElement);
      }
    };

    watch(() => state.closed, newVal => {
      if (newVal) {
        state.visible = false;
      }
    });
    onMounted(() => {
      startTimer();
      document.addEventListener('keydown', keydown);
    });
    onUnmounted(() => {
      document.removeEventListener('keydown', keydown);
    });
    return {
      typeClass,
      positionStyle,
      close,
      clearTimer,
      startTimer,
      handleAfterLeave,
      ...toRefs(state)
    };
  }

};

const _hoisted_1$z = {
  key: 0,
  class: "el-message__content"
};

function render$W(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    name: "el-message-fade",
    onAfterLeave: $setup.handleAfterLeave,
    appear: ""
  }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        class: [
        'el-message',
        $props.type && !$props.iconClass ? `el-message--${$props.type}` : '',
        $props.center ? 'is-center' : '',
        $props.showClose ? 'is-closable' : '',
        $props.customClass
      ],
        style: $setup.positionStyle,
        onMouseenter: _cache[2] || (_cache[2] = (...args) => ($setup.clearTimer(...args))),
        onMouseleave: _cache[3] || (_cache[3] = (...args) => ($setup.startTimer(...args))),
        role: "alert"
      }, [
        ($props.iconClass)
          ? (openBlock(), createBlock("i", {
              key: 0,
              class: $props.iconClass
            }, null, 2 /* CLASS */))
          : (openBlock(), createBlock("i", {
              key: 1,
              class: $setup.typeClass
            }, null, 2 /* CLASS */)),
        renderSlot(_ctx.$slots, "default", {}, () => [
          (!$props.dangerouslyUseHTMLString)
            ? (openBlock(), createBlock("p", _hoisted_1$z, toDisplayString($props.message), 1 /* TEXT */))
            : (openBlock(), createBlock("p", {
                key: 1,
                innerHTML: $props.message,
                class: "el-message__content"
              }, null, 8 /* PROPS */, ["innerHTML"]))
        ]),
        ($props.showClose)
          ? (openBlock(), createBlock("i", {
              key: 2,
              class: "el-message__closeBtn el-icon-close",
              onClick: _cache[1] || (_cache[1] = (...args) => ($setup.close(...args)))
            }))
          : createCommentVNode("v-if", true)
      ], 38 /* CLASS, STYLE, HYDRATE_EVENTS */), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }, 8 /* PROPS */, ["onAfterLeave"]))
}

script$$.render = render$W;
script$$.__file = "packages/message/Message.vue";

const MessageConstructor = defineComponent(script$$);
let instance;
const instances$1 = [];
let seed$1 = 1;

const Message = function (options) {
  // if (Vue.prototype.$isServer) return
  // check ssr
  if (window === undefined) return;
  options = options || {};

  if (typeof options === 'string' || isVNode(options)) {
    options = {
      message: options
    };
  }

  const userOnClose = options.onClose;
  const id = 'message_' + seed$1++;

  options.onClose = function () {
    Message.close(id, userOnClose);
  };

  let verticalOffset = options.offset || 20;
  instances$1.forEach(item => {
    verticalOffset += item.el.offsetHeight + 16;
  });
  const nextZIndex = PopupManager.nextZIndex();
  options = merge({
    id,
    verticalOffset,
    zIndex: nextZIndex
  }, options);
  instance = createVNode(MessageConstructor, options, isVNode(options.message) ? {
    default: () => options.message
  } : null);
  const container = document.createElement('div');
  render$1p(instance, container);
  instance.el.style.zIndex = nextZIndex;
  document.body.appendChild(instance.el);
  instances$1.push(instance);
  return instance;
};

['success', 'warning', 'info', 'error'].forEach(type => {
  Message[type] = options => {
    if (typeof options === 'string' || isVNode(options)) {
      options = {
        message: options
      };
    }

    options.type = type;
    return Message(options);
  };
});

Message.close = function (id, userOnClose) {
  const len = instances$1.length;
  let index = -1;
  let removedHeight;

  for (let i = 0; i < len; i++) {
    if (id === instances$1[i].component.props.id) {
      removedHeight = instances$1[i].el.offsetHeight;
      index = i;

      if (typeof userOnClose === 'function') {
        userOnClose(instances$1[i]);
      }

      instances$1.splice(i, 1);
      break;
    }
  }

  if (len <= 1 || index === -1 || index > instances$1.length - 1) return;

  for (let i = index; i < len - 1; i++) {
    const dom = instances$1[i].el;
    dom.style.top = parseInt(dom.style.top, 10) - removedHeight - 16 + 'px';
  }
};

Message.closeAll = function () {
  for (let i = instances$1.length - 1; i >= 0; i--) {
    instances$1[i].component.ctx.close();
  }
};

function useMessage() {
  return Message;
}
var ElMessage = {
  service: Message
};

let idSeed = 1;
let scrollBarWidth$1;
const popupProps = {
  visible: {
    type: Boolean,
    default: false
  },
  openDelay: {},
  closeDelay: {},
  zIndex: {},
  modal: {
    type: Boolean,
    default: false
  },
  modalFade: {
    type: Boolean,
    default: true
  },
  modalClass: {},
  modalAppendToBody: {
    type: Boolean,
    default: false
  },
  lockScroll: {
    type: Boolean,
    default: true
  },
  closeOnPressEscape: {
    type: Boolean,
    default: false
  },
  closeOnClickModal: {
    type: Boolean,
    default: false
  }
};

function usePopup(props) {
  const {
    visible,
    modal,
    modalAppendToBody,
    lockScroll,
    closeDelay
  } = toRefs(props);
  const opened = ref(false);
  const bodyPaddingRight = ref(null);
  const computedBodyPaddingRight = ref(0);
  const withoutHiddenClass = ref(true);
  const rendered = ref(false);
  const instance = getCurrentInstance();
  let _popupId = 0;
  let _closeTimer = 0;
  let _openTimer = 0;
  let _opening = false;
  let _closing = false;

  const open = options => {
    if (!rendered.value) {
      rendered.value = true;
    }

    const props = merge({}, instance.ctx, options);

    if (_closeTimer) {
      clearTimeout(_closeTimer);
      _closeTimer = 0;
    }

    clearTimeout(_openTimer);
    const delay = Number(props.openDelay) || 0;

    if (delay > 0) {
      _openTimer = setTimeout(() => {
        _openTimer = 0;
        doOpen(props);
      }, delay);
    } else {
      doOpen(props);
    }
  };

  const doOpen = props => {
    if (instance.ctx.$isServer) return;
    if (_opening) return;
    if (opened.value) return;
    _opening = true;
    const dom = instance.ctx.$el;
    const modal = props.modal;
    const zIndex = props.zIndex;

    if (zIndex) {
      PopupManager.zIndex = zIndex.value;
    }

    if (modal) {
      if (_closing) {
        PopupManager.closeModal(_popupId);
        _closing = false;
      }

      PopupManager.openModal(_popupId, PopupManager.nextZIndex(), modalAppendToBody.value ? undefined : dom, props.modalClass, props.modalFade);

      if (props.lockScroll) {
        withoutHiddenClass.value = !hasClass(document.body, 'el-popup-parent--hidden');

        if (withoutHiddenClass.value) {
          bodyPaddingRight.value = document.body.style.paddingRight;
          computedBodyPaddingRight.value = parseInt(getStyle(document.body, 'paddingRight'), 10);
        }

        scrollBarWidth$1 = getScrollBarWidth();
        const bodyHasOverflow = document.documentElement.clientHeight < document.body.scrollHeight;
        const bodyOverflowY = getStyle(document.body, 'overflowY');

        if (scrollBarWidth$1 > 0 && (bodyHasOverflow || bodyOverflowY === 'scroll') && withoutHiddenClass.value) {
          document.body.style.paddingRight = computedBodyPaddingRight.value + scrollBarWidth$1 + 'px';
        }

        addClass(document.body, 'el-popup-parent--hidden');
      }
    }

    if (getComputedStyle(dom).position === 'static') {
      dom.style.position = 'absolute';
    }

    dom.style.zIndex = PopupManager.nextZIndex();
    opened.value = true;
    instance.onOpen && instance.onOpen();
    doAfterOpen();
  };

  const doAfterOpen = () => {
    _opening = false;
  };

  const close = () => {
    if (_closing) return;

    if (_openTimer) {
      clearTimeout(_openTimer);
      _openTimer = 0;
    }

    clearTimeout(_closeTimer);
    const delay = Number(closeDelay && closeDelay.value);

    if (delay > 0) {
      _closeTimer = setTimeout(() => {
        _closeTimer = 0;
        doClose();
      }, delay);
    } else {
      doClose();
    }
  };

  const doClose = () => {
    _closing = true;
    instance.onClose && instance.onClose();

    if (lockScroll.value) {
      setTimeout(restoreBodyStyle, 200);
    }

    opened.value = false;
    doAfterClose();
  };

  const doAfterClose = () => {
    PopupManager.closeModal(_popupId);
    _closing = false;
  };

  const restoreBodyStyle = () => {
    if (modal.value && withoutHiddenClass.value) {
      document.body.style.paddingRight = bodyPaddingRight.value;
      removeClass(document.body, 'el-popup-parent--hidden');
    }

    withoutHiddenClass.value = true;
  };

  watch(visible, val => {
    if (val) {
      if (_opening) return;

      if (!rendered.value) {
        rendered.value = true;
        nextTick(() => {
          open();
        });
      } else {
        open();
      }
    } else {
      close();
    }
  });
  onBeforeMount(() => {
    _popupId = 'popup-' + idSeed++;
    PopupManager.register(_popupId, instance);
  });
  onBeforeUnmount(() => {
    PopupManager.deregister(_popupId);
    PopupManager.closeModal(_popupId);
    restoreBodyStyle();
  });
  return {
    opened,
    visible,
    open,
    rendered,
    close
  };
}

/* eslint-disable no-use-before-define */
/**
 * @constructor
 * @desc Dialog object providing modal focus management.
 *
 * Assumptions: The element serving as the dialog container is present in the
 * DOM and hidden. The dialog container has role='dialog'.
 *
 * @param dialogId
 *          The ID of the element serving as the dialog container.
 * @param focusAfterClosed
 *          Either the DOM node or the ID of the DOM node to focus when the
 *          dialog closes.
 * @param focusFirst
 *          Optional parameter containing either the DOM node or the ID of the
 *          DOM node to focus when the dialog opens. If not specified, the
 *          first focusable element in the dialog will receive focus.
 */

var aria$1 = aria$1 || {};
var tabEvent;

aria$1.Dialog = function (dialog, focusAfterClosed, focusFirst) {
  this.dialogNode = dialog;

  if (this.dialogNode === null || this.dialogNode.getAttribute('role') !== 'dialog') {
    throw new Error('Dialog() requires a DOM element with ARIA role of dialog.');
  }

  if (typeof focusAfterClosed === 'string') {
    this.focusAfterClosed = document.getElementById(focusAfterClosed);
  } else if (typeof focusAfterClosed === 'object') {
    this.focusAfterClosed = focusAfterClosed;
  } else {
    this.focusAfterClosed = null;
  }

  if (typeof focusFirst === 'string') {
    this.focusFirst = document.getElementById(focusFirst);
  } else if (typeof focusFirst === 'object') {
    this.focusFirst = focusFirst;
  } else {
    this.focusFirst = null;
  }

  if (this.focusFirst) {
    this.focusFirst.focus();
  } else {
    Utils.focusFirstDescendant(this.dialogNode);
  }

  this.lastFocus = document.activeElement;

  tabEvent = e => {
    this.trapFocus(e);
  };

  this.addListeners();
};

aria$1.Dialog.prototype.addListeners = function () {
  document.addEventListener('focus', tabEvent, true);
};

aria$1.Dialog.prototype.removeListeners = function () {
  document.removeEventListener('focus', tabEvent, true);
};

aria$1.Dialog.prototype.closeDialog = function () {
  this.removeListeners();

  if (this.focusAfterClosed) {
    setTimeout(() => {
      this.focusAfterClosed.focus();
    });
  }
};

aria$1.Dialog.prototype.trapFocus = function (event) {
  if (Utils.IgnoreUtilFocusChanges) {
    return;
  }

  if (this.dialogNode.contains(event.target)) {
    this.lastFocus = event.target;
  } else {
    Utils.focusFirstDescendant(this.dialogNode);

    if (this.lastFocus === document.activeElement) {
      Utils.focusLastDescendant(this.dialogNode);
    }

    this.lastFocus = document.activeElement;
  }
};

var Dialog = aria$1.Dialog;

const typeMap$1 = {
  success: 'success',
  info: 'info',
  warning: 'warning',
  error: 'error'
};
var script$10 = {
  mixins: [Locale],
  props: { ...popupProps,
    modal: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: null
    },
    message: {
      type: [Object, String],

      default() {
        return {};
      }

    },
    dangerouslyUseHTMLString: {
      type: Boolean,
      default: false
    },
    type: {
      type: String,
      default: 'info',

      validator(val) {
        return ['success', 'warning', 'info', 'error'].indexOf(val);
      }

    },
    iconClass: {
      type: String,
      default: null
    },
    customClass: {
      type: String,
      default: null
    },
    callback: {
      type: Function,
      default: () => {}
    },
    showClose: {
      type: Boolean,
      default: true
    },
    beforeClose: {
      type: Function,
      default: () => {}
    },
    distinguishCancelAndClose: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    showCancelButton: {
      type: Boolean,
      default: false
    },
    showConfirmButton: {
      type: Boolean,
      default: true
    },
    cancelButtonClass: {
      type: String,
      default: null
    },
    confirmButtonClass: {
      type: String,
      default: null
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    closeOnHashChange: {
      type: Boolean,
      default: true
    },
    showInput: {
      type: Boolean,
      default: false
    },
    inputPlaceholder: {
      type: String,
      default: ''
    },
    inputType: {
      type: String,
      default: 'text'
    },
    inputValue: {
      type: String,
      default: ''
    },
    inputPattern: {
      type: RegExp,
      default: null
    },
    inputValidator: {
      type: Function,
      default: () => {}
    },
    inputErrorMessage: {
      type: String,
      default: ''
    },
    center: {
      type: Boolean,
      default: false
    },
    roundButton: {
      type: Boolean,
      default: false
    },
    _type: {
      type: String,
      default: ''
    },
    cancelButtonLoading: {
      type: Boolean,
      default: false
    }
  },
  components: {
    ElInput: script$g,
    ElButton: script$7
  },

  setup(props, {
    attrs
  }) {
    const confirmButtonText = ref(attrs.confirmButtonText || '确认');
    const cancelButtonText = ref(attrs.cancelButtonText || '取消');
    let messageBox = '';
    const instance = getCurrentInstance();
    const {
      closeOnClickModal,
      distinguishCancelAndClose,
      _type,
      beforeClose,
      callback,
      type,
      iconClass,
      message,
      inputType,
      cancelButtonClass,
      confirmButtonClass,
      closeOnHashChange,
      lockScroll,
      inputPattern,
      inputValidator,
      inputValue
    } = toRefs(props);
    const state = reactive({
      visible: false,
      action: null,
      editorErrorMessage: null,
      uid: 0,
      inputValue: unref(inputValue),
      isVnode: false
    });
    const {
      rendered,
      open,
      close,
      restoreBodyStyle
    } = usePopup({ ...toRefs(props),
      visible: state.visible
    });

    const validate = () => {
      if (unref(_type) === 'prompt') {
        const _inputPattern = unref(inputPattern);

        if (_inputPattern && !_inputPattern.test(state.inputValue || '')) {
          state.editorErrorMessage = state.inputErrorMessage || t('el.messagebox.error');
          addClass(getInputElement(), 'invalid');
          return false;
        }

        const _inputValidator = unref(inputValidator);

        if (typeof _inputValidator === 'function') {
          const validateResult = _inputValidator(state.inputValue);

          if (validateResult === false) {
            state.editorErrorMessage = state.inputErrorMessage || t('el.messagebox.error');
            addClass(getInputElement(), 'invalid');
            return false;
          }

          if (typeof validateResult === 'string') {
            state.editorErrorMessage = validateResult;
            addClass(getInputElement(), 'invalid');
            return false;
          }
        }
      }

      state.editorErrorMessage = '';
      removeClass(getInputElement(), 'invalid');
      return true;
    };

    const doClose = () => {
      if (!state.visible) return;
      state.visible = false;
      rendered.value = false;
      close();
      messageBox.closeDialog(); // 解绑

      if (lockScroll) {
        setTimeout(restoreBodyStyle, 200);
      }

      nextTick(() => {
        if (state.action) {
          unref(callback)(state.action, instance.vnode);
        }
      });
    };

    const getSafeClose = () => {
      const currentId = state.uid;
      return () => {
        nextTick(() => {
          if (currentId === state.uid) doClose();
        });
      };
    };

    const confirmButtonLoading = ref(false);

    const handleAction = action => {
      if (unref(_type) === 'prompt' && action === 'confirm' && !validate()) {
        return;
      }

      state.action = action;

      if (typeof unref(beforeClose) === 'function') {
        const close = getSafeClose();
        unref(beforeClose)(action, instance.vnode, close);
      } else {
        doClose();
      }
    };

    const handleWrapperClick = () => {
      if (unref(closeOnClickModal)) {
        handleAction(unref(distinguishCancelAndClose) ? 'close' : 'cancel');
      }
    };

    const handleKeyup = (element = {}) => {
      if (element.code !== 'Escape') return;

      if (unref(props.closeOnPressEscape)) {
        handleAction(unref(distinguishCancelAndClose) ? 'close' : 'cancel');
      }
    };

    const handleInputEnter = () => {
      if (unref(inputType) !== 'textarea') {
        return handleAction('confirm');
      }
    };

    const icon = computed(() => {
      return unref(iconClass) || (unref(type) && typeMap$1[unref(type)] ? `el-icon-${typeMap$1[unref(type)]}` : '');
    });
    const cancelButtonClasses = computed(() => {
      return `el-button--primary ${unref(cancelButtonClass)}`;
    });
    const confirmButtonClasses = computed(() => {
      return `el-button--primary ${unref(confirmButtonClass)}`;
    });

    const getFirstFocus = () => {
      const btn = instance.vnode.el.querySelector('.el-message-box__btns .el-button');
      const title = instance.vnode.el.querySelector('.el-message-box__btns .el-message-box__title');
      return btn || title;
    };

    const getInputElement = () => {
      const inputRefs = instance.refs.input.$refs;
      return inputRefs.input || inputRefs.textarea;
    };

    onMounted(() => {
      state.visible = true;
      nextTick(() => {
        state.uid++;
        rendered.value = true;
        open();
      });

      if (unref(_type) === 'alert' || unref(_type) === 'confirm') {
        nextTick(() => {
          instance.refs.confirm.$el.focus();
        });
      }

      const focusAfterClosed = document.activeElement;
      messageBox = new Dialog(instance.vnode.el, focusAfterClosed, getFirstFocus());

      if (unref(closeOnHashChange)) {
        window.addEventListener('hashchange', doClose);
      }

      window.addEventListener('keyup', handleKeyup);
      if (unref(_type) !== 'prompt') return;
      setTimeout(() => {
        if (instance.refs.input && instance.refs.input.$el) {
          getInputElement().focus();
        }
      }, 500);
    });
    onUnmounted(() => {
      if (unref(closeOnHashChange)) {
        window.removeEventListener('hashchange', doClose);
      }

      window.removeEventListener('keyup', handleKeyup);
      setTimeout(() => {
        messageBox.closeDialog();
      });
    });

    const MessageToVNode = message => {
      let v = '';

      if (isVNode(unref(message))) {
        v = unref(message);
        render$1p(v, document.createElement('div'));
        state.isVnode = true;
        return v.el.innerHTML;
      } else {
        state.isVnode = false;
        return message;
      }
    };

    watch(() => state.inputValue, val => {
      nextTick(() => {
        if (unref(_type) === 'prompt' && val !== null) {
          validate();
        }
      });
    });
    return { ...toRefs(props),
      changedMessage: MessageToVNode(message),
      handleInputEnter,
      handleAction,
      state,
      handleWrapperClick,
      icon,
      cancelButtonClasses,
      cancelButtonText,
      t,
      confirmButtonLoading,
      confirmButtonClasses,
      confirmButtonText
    };
  }

};

const _hoisted_1$A = {
  key: 0,
  class: "el-message-box__header"
};
const _hoisted_2$n = { class: "el-message-box__title" };
const _hoisted_3$h = /*#__PURE__*/createVNode("i", { class: "el-message-box__close el-icon-close" }, null, -1 /* HOISTED */);
const _hoisted_4$9 = { class: "el-message-box__content" };
const _hoisted_5$8 = { class: "el-message-box__container" };
const _hoisted_6$4 = {
  key: 1,
  class: "el-message-box__message"
};
const _hoisted_7$2 = { key: 0 };
const _hoisted_8$2 = { class: "el-message-box__input" };
const _hoisted_9$1 = { class: "el-message-box__btns" };

function render$X(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_button = resolveComponent("el-button");

  return (openBlock(), createBlock(Transition, { name: "msgbox-fade" }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        class: "el-message-box__wrapper",
        tabindex: "-1",
        role: "dialog",
        "aria-modal": "true",
        onClick: _cache[8] || (_cache[8] = withModifiers((...args) => ($setup.handleWrapperClick(...args)), ["self"])),
        "aria-label": $props.title || 'dialog'
      }, [
        createVNode("div", {
          class: ["el-message-box", [$props.customClass, $props.center && 'el-message-box--center']]
        }, [
          ($props.title !== null)
            ? (openBlock(), createBlock("div", _hoisted_1$A, [
                createVNode("div", _hoisted_2$n, [
                  ($setup.icon && $props.center)
                    ? (openBlock(), createBlock("div", {
                        key: 0,
                        class: ['el-message-box__status', $setup.icon]
                      }, null, 2 /* CLASS */))
                    : createCommentVNode("v-if", true),
                  createVNode("span", null, toDisplayString($props.title), 1 /* TEXT */)
                ]),
                ($props.showClose)
                  ? (openBlock(), createBlock("button", {
                      key: 0,
                      type: "button",
                      class: "el-message-box__headerbtn",
                      "aria-label": "Close",
                      onClick: _cache[1] || (_cache[1] = $event => (
              $setup.handleAction($props.distinguishCancelAndClose ? 'close' : 'cancel')
            )),
                      onKeydown: _cache[2] || (_cache[2] = withKeys($event => (
              $setup.handleAction($props.distinguishCancelAndClose ? 'close' : 'cancel')
            ), ["enter"]))
                    }, [
                      _hoisted_3$h
                    ], 32 /* HYDRATE_EVENTS */))
                  : createCommentVNode("v-if", true)
              ]))
            : createCommentVNode("v-if", true),
          createVNode("div", _hoisted_4$9, [
            createVNode("div", _hoisted_5$8, [
              ($setup.icon && !$props.center && $setup.changedMessage !== '')
                ? (openBlock(), createBlock("div", {
                    key: 0,
                    class: ['el-message-box__status', $setup.icon]
                  }, null, 2 /* CLASS */))
                : createCommentVNode("v-if", true),
              ($setup.changedMessage !== '')
                ? (openBlock(), createBlock("div", _hoisted_6$4, [
                    renderSlot(_ctx.$slots, "default", {}, () => [
                      (!$props.dangerouslyUseHTMLString && $setup.state.isVnode !== true)
                        ? (openBlock(), createBlock("p", _hoisted_7$2, toDisplayString($setup.changedMessage), 1 /* TEXT */))
                        : (openBlock(), createBlock("p", {
                            key: 1,
                            innerHTML: $setup.changedMessage
                          }, null, 8 /* PROPS */, ["innerHTML"]))
                    ])
                  ]))
                : createCommentVNode("v-if", true)
            ]),
            withDirectives(createVNode("div", _hoisted_8$2, [
              createVNode(_component_el_input, {
                onKeydown: withKeys($setup.handleInputEnter, ["enter"]),
                type: $props.inputType,
                modelValue: $setup.state.inputValue,
                "onUpdate:modelValue": _cache[3] || (_cache[3] = $event => ($setup.state.inputValue = $event)),
                placeholder: $props.inputPlaceholder,
                ref: "input"
              }, null, 8 /* PROPS */, ["onKeydown", "type", "modelValue", "placeholder"]),
              createVNode("div", {
                class: "el-message-box__errormsg",
                style: {
                visibility: !!$setup.state.editorErrorMessage ? 'visible' : 'hidden'
              }
              }, toDisplayString($setup.state.editorErrorMessage), 5 /* TEXT, STYLE */)
            ], 512 /* NEED_PATCH */), [
              [vShow, $props.showInput]
            ])
          ]),
          createVNode("div", _hoisted_9$1, [
            ($props.showCancelButton)
              ? (openBlock(), createBlock(_component_el_button, {
                  key: 0,
                  loading: $props.cancelButtonLoading,
                  class: [$setup.cancelButtonClasses],
                  round: $props.roundButton,
                  size: "small",
                  onClick: _cache[4] || (_cache[4] = $event => ($setup.handleAction('cancel'))),
                  onKeydown: _cache[5] || (_cache[5] = withKeys($event => ($setup.handleAction('cancel')), ["enter"]))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($setup.cancelButtonText || $setup.t('el.messagebox.cancel')), 1 /* TEXT */)
                  ]),
                  _: 1
                }, 8 /* PROPS */, ["loading", "class", "round"]))
              : createCommentVNode("v-if", true),
            withDirectives(createVNode(_component_el_button, {
              loading: $setup.confirmButtonLoading,
              ref: "confirm",
              class: [$setup.confirmButtonClasses],
              round: $props.roundButton,
              size: "small",
              onClick: _cache[6] || (_cache[6] = $event => ($setup.handleAction('confirm'))),
              onKeydown: _cache[7] || (_cache[7] = withKeys($event => ($setup.handleAction('confirm')), ["enter"]))
            }, {
              default: withCtx(() => [
                createTextVNode(toDisplayString($setup.confirmButtonText || $setup.t('el.messagebox.confirm')), 1 /* TEXT */)
              ]),
              _: 1
            }, 8 /* PROPS */, ["loading", "class", "round"]), [
              [vShow, $props.showConfirmButton]
            ])
          ])
        ], 2 /* CLASS */)
      ], 8 /* PROPS */, ["aria-label"]), [
        [vShow, $setup.state.visible]
      ])
    ]),
    _: 1
  }))
}

script$10.render = render$X;
script$10.__file = "packages/message-box/src/MessageBox.vue";

// #todo
const messageBoxConstructor = defineComponent(script$10);
const defaults$2 = {
  title: null,
  message: '',
  type: '',
  iconClass: '',
  showInput: false,
  showClose: true,
  modalFade: true,
  lockScroll: true,
  closeOnClickModal: true,
  closeOnPressEscape: true,
  closeOnHashChange: true,
  inputValue: null,
  inputPlaceholder: '',
  inputType: 'text',
  inputPattern: null,
  inputValidator: null,
  inputErrorMessage: '',
  showConfirmButton: true,
  showCancelButton: false,
  confirmButtonPosition: 'right',
  confirmButtonHighlight: false,
  cancelButtonHighlight: false,
  confirmButtonText: '',
  cancelButtonText: '',
  confirmButtonClass: '',
  cancelButtonClass: '',
  customClass: '',
  beforeClose: null,
  dangerouslyUseHTMLString: false,
  center: false,
  roundButton: false,
  distinguishCancelAndClose: false
}; // const MessageBoxConstructor = {
//   extends: msgboxVue
// }

let currentMsg, instance$1;
let msgQueue = [];

const defaultCallback = action => {
  if (currentMsg) {
    if (currentMsg.resolve) {
      if (action === 'confirm') {
        if (instance$1.vnode.props.showInput) {
          currentMsg.resolve({
            value: instance$1.setupState.state.inputValue,
            action
          });
        } else {
          currentMsg.resolve(action);
        }
      } else if (currentMsg.reject && (action === 'cancel' || action === 'close')) {
        currentMsg.reject(action);
      }
    }
  }
};

const initInstance = (currentMsg, VNode = null) => {
  defaults$2.callback = defaultCallback;
  instance$1 = createComponent(messageBoxConstructor, currentMsg.options, VNode);
};

const showNextMsg = () => {
  if (msgQueue.length > 0) {
    currentMsg = msgQueue.shift();
    const options = currentMsg.options;

    if (options.callback === undefined) {
      options.callback = defaultCallback;
    }

    const oldCb = options.callback;

    options.callback = (action, instance) => {
      oldCb(action, instance);
    };

    if (isVNode(currentMsg.message)) {
      initInstance(currentMsg, {
        default: () => currentMsg.message
      });
    }

    initInstance(currentMsg);
    ['modal', 'showClose', 'closeOnClickModal', 'closeOnPressEscape', 'closeOnHashChange'].forEach(prop => {
      if (options[prop] === undefined) {
        options[prop] = true;
      }
    });
    document.body.appendChild(instance$1.vnode.el);
  } // }

};

const MessageBox = function (options, callback) {
  // if (Vue.prototype.$isServer) return
  if (typeof options === 'string' || isVNode(options)) {
    options = {
      message: options
    };

    if (typeof arguments[1] === 'string') {
      options.title = arguments[1];
    }
  } else if (options.callback && !callback) {
    callback = options.callback;
  }

  if (typeof Promise !== 'undefined') {
    return new Promise((resolve, reject) => {
      // eslint-disable-line
      msgQueue.push({
        options: merge({}, defaults$2, MessageBox.defaults, options),
        callback: callback,
        resolve: resolve,
        reject: reject
      });
      showNextMsg();
    });
  } else {
    msgQueue.push({
      options: merge({}, defaults$2, MessageBox.defaults, options),
      callback: callback
    });
    showNextMsg();
  }
};

MessageBox.setDefaults = defaults => {
  MessageBox.defaults = defaults;
};

MessageBox.alert = (message, title, options) => {
  if (typeof title === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }

  return MessageBox(merge({
    title: title,
    message: message,
    _type: 'alert',
    closeOnPressEscape: false,
    closeOnClickModal: false
  }, options));
};

MessageBox.confirm = (message, title, options) => {
  if (typeof title === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }

  return MessageBox(merge({
    title: title,
    message: message,
    _type: 'confirm',
    showCancelButton: true
  }, options));
};

MessageBox.prompt = (message, title, options) => {
  if (typeof title === 'object') {
    options = title;
    title = '';
  } else if (title === undefined) {
    title = '';
  }

  return MessageBox(merge({
    title: title,
    message: message,
    showCancelButton: true,
    showInput: true,
    _type: 'prompt'
  }, options));
};

MessageBox.close = () => {
  instance$1.doClose();
  msgQueue = [];
  currentMsg = null;
};

function useMsgbox() {
  return MessageBox;
}
var ElMessageBox = {
  service: MessageBox
};

const typeMap$2 = {
  success: 'success',
  info: 'info',
  warning: 'warning',
  error: 'error'
};
var script$11 = {
  name: 'ElNotification',
  props: {
    customClass: {
      type: String,
      default: ''
    },
    dangerouslyUseHTMLString: {
      type: Boolean,
      default: false
    },
    duration: {
      type: Number,
      default: 4500
    },
    iconClass: {
      type: String,
      default: ''
    },
    id: {
      type: String,
      default: ''
    },
    verticalOffset: {
      type: Number,
      default: 0
    },
    message: [String, Object],
    position: {
      type: String,
      default: 'top-right'
    },
    onClose: null,
    onClick: null,
    showClose: {
      type: Boolean,
      default: true
    },
    title: {
      type: String,
      default: ''
    },
    type: {
      type: String,
      default: ''
    }
  },
  emits: ['close'],

  setup(props) {
    // eslint-disable-next-line vue/no-setup-props-destructure
    const {
      duration,
      onClose,
      onClick
    } = props;
    const typeClass = computed(() => {
      return props.type && typeMap$2[props.type] ? `el-icon-${typeMap$2[props.type]}` : '';
    });
    const horizontalClass = computed(() => {
      return props.position.indexOf('right') > -1 ? 'right' : 'left';
    });
    const verticalProperty = computed(() => {
      return props.position.startsWith('top') ? 'top' : 'bottom';
    });
    const positionStyle = computed(() => {
      return {
        [verticalProperty.value]: `${props.verticalOffset}px` // zIndex,

      };
    });
    const instance = getCurrentInstance();
    const visible = ref(true);
    const closed = ref(false);
    const timer = ref(0);

    const destroyElement = () => {
      instance.ctx.$el.parentNode && instance.ctx.$el.parentNode.removeChild(instance.ctx.$el);
    };

    const clearTimer = () => {
      clearTimeout(timer.value);
    };

    const close = () => {
      closed.value = true;

      if (typeof onClose === 'function') {
        onClose();
      }
    };

    const startTimer = () => {
      if (duration > 0) {
        timer.value = setTimeout(() => {
          if (!closed.value) {
            close();
          }
        }, duration);
      }
    };

    const keydown = e => {
      if (e.keyCode === 46 || e.keyCode === 8) {
        clearTimer(); // detele 取消倒计时
      } else if (e.keyCode === 27) {
        // esc关闭消息
        if (!closed.value) {
          close();
        }
      } else {
        startTimer(); // 恢复倒计时
      }
    };

    const click = () => {
      if (typeof onClick === 'function') {
        onClick();
      }
    };

    watch(closed, newVal => {
      if (newVal) {
        visible.value = false;
        instance.ctx.$el.addEventListener('transitionend', destroyElement);
      }
    });
    onMounted(() => {
      if (duration > 0) {
        timer.value = setTimeout(() => {
          if (!closed.value) {
            close();
          }
        }, duration);
      }

      visible.value = true;
      document.addEventListener('keydown', keydown);
    });
    onBeforeUnmount(() => {
      document.removeEventListener('keydown', keydown);
    });
    return {
      typeClass,
      horizontalClass,
      verticalProperty,
      positionStyle,
      visible,
      closed,
      timer,
      click,
      clearTimer,
      startTimer,
      close
    };
  }

};

const _hoisted_1$B = { class: "el-notification__content" };
const _hoisted_2$o = { key: 0 };

function render$Y(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    name: "el-notification-fade",
    appear: ""
  }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        class: ['el-notification', $props.customClass, $setup.horizontalClass],
        style: $setup.positionStyle,
        onMouseenter: _cache[2] || (_cache[2] = $event => ($setup.clearTimer())),
        onMouseleave: _cache[3] || (_cache[3] = $event => ($setup.startTimer())),
        onClick: _cache[4] || (_cache[4] = (...args) => ($setup.click(...args))),
        role: "alert"
      }, [
        ($props.type || $props.iconClass)
          ? (openBlock(), createBlock("i", {
              key: 0,
              class: ["el-notification__icon", [$setup.typeClass, $props.iconClass]]
            }, null, 2 /* CLASS */))
          : createCommentVNode("v-if", true),
        createVNode("div", {
          class: ["el-notification__group", { 'is-with-icon': $setup.typeClass || $props.iconClass }]
        }, [
          createVNode("h2", {
            class: "el-notification__title",
            textContent: toDisplayString($props.title)
          }, null, 8 /* PROPS */, ["textContent"]),
          withDirectives(createVNode("div", _hoisted_1$B, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              (!$props.dangerouslyUseHTMLString)
                ? (openBlock(), createBlock("p", _hoisted_2$o, toDisplayString($props.message), 1 /* TEXT */))
                : (openBlock(), createBlock("p", {
                    key: 1,
                    innerHTML: $props.message
                  }, null, 8 /* PROPS */, ["innerHTML"]))
            ])
          ], 512 /* NEED_PATCH */), [
            [vShow, $props.message]
          ]),
          ($props.showClose)
            ? (openBlock(), createBlock("div", {
                key: 0,
                class: "el-notification__closeBtn el-icon-close",
                onClick: _cache[1] || (_cache[1] = withModifiers((...args) => ($setup.close(...args)), ["stop"]))
              }))
            : createCommentVNode("v-if", true)
        ], 2 /* CLASS */)
      ], 38 /* CLASS, STYLE, HYDRATE_EVENTS */), [
        [vShow, $setup.visible]
      ])
    ]),
    _: 3
  }))
}

script$11.render = render$Y;
script$11.__file = "packages/notification/Notification.vue";

const NotificationConstructor = defineComponent(script$11);
let instance$2;
const instances$2 = [];
let seed$2 = 1;

const Notification = function (options) {
  // check ssr
  if (window === undefined) return;
  const userOnClose = options.onClose;
  const id = 'notification_' + seed$2++;
  const position = options.position || 'top-right';
  let verticalOffset = options.offset || 0;
  instances$2.filter(instance => instance.component.props.position === position).forEach(instance => {
    verticalOffset += (instance.el.offsetHeight || 0) + 16;
  });
  verticalOffset += 16;
  const nextZIndex = PopupManager.nextZIndex();
  options = merge({
    id,
    position,
    verticalOffset,
    zIndex: nextZIndex,

    onClose() {
      Notification.close(id, userOnClose);
    }

  }, options);
  instance$2 = createVNode(NotificationConstructor, options, isVNode(options.message) ? {
    default: () => options.message
  } : null); // 防止render直接到body上导致覆盖原来的

  const container = document.createElement('div');
  render$1p(instance$2, container);
  instance$2.el.style.zIndex = nextZIndex;
  instances$2.push(instance$2);
  document.body.appendChild(instance$2.el);
  return {
    close() {
      Notification.close(id, userOnClose);
    }

  };
};

['success', 'warning', 'info', 'error'].forEach(type => {
  Notification[type] = options => {
    if (typeof options === 'string' || isVNode(options)) {
      options = {
        message: options
      };
    }

    options.type = type;
    return Notification(options);
  };
});

Notification.close = function (id, userOnClose) {
  const index = instances$2.findIndex(instance => {
    return instance.component.props.id === id;
  });

  if (index === -1) {
    return;
  }

  const instance = instances$2[index];

  if (typeof userOnClose === 'function') {
    userOnClose(instance);
  }

  const len = instances$2.length;
  instances$2.splice(index, 1);
  if (len <= 1) return;
  const position = instance.component.props.position;
  const removedHeight = instance.el.offsetHeight;

  for (let i = index; i < len - 1; i++) {
    if (instances$2[i].component.props.position === position) {
      instances$2[i].el.style[instance.component.props.position.startsWith('top') ? 'top' : 'bottom'] = parseInt(instances$2[i].el.style[instance.component.props.position.startsWith('top') ? 'top' : 'bottom'], 10) - removedHeight - 16 + 'px';
    }
  }
};

Notification.closeAll = function () {
  for (let i = instances$2.length - 1; i >= 0; i--) {
    instances$2[i].component.ctx.close();
  }
};

function useNotify() {
  return Notification;
}
var ElNotification = {
  service: Notification
};

const SubMenu = function (parent, domNode) {
  this.domNode = domNode;
  this.parent = parent;
  this.subMenuItems = [];
  this.subIndex = 0;
  this.init();
};

SubMenu.prototype.init = function () {
  this.subMenuItems = this.domNode.querySelectorAll('li');
  this.addListeners();
};

SubMenu.prototype.gotoSubIndex = function (idx) {
  if (idx === this.subMenuItems.length) {
    idx = 0;
  } else if (idx < 0) {
    idx = this.subMenuItems.length - 1;
  }

  this.subMenuItems[idx].focus();
  this.subIndex = idx;
};

SubMenu.prototype.addListeners = function () {
  const keys = Utils.keys;
  const parentNode = this.parent.domNode;
  Array.prototype.forEach.call(this.subMenuItems, el => {
    el.addEventListener('keydown', event => {
      let prevDef = false;

      switch (event.keyCode) {
        case keys.down:
          this.gotoSubIndex(this.subIndex + 1);
          prevDef = true;
          break;

        case keys.up:
          this.gotoSubIndex(this.subIndex - 1);
          prevDef = true;
          break;

        case keys.tab:
          Utils.triggerEvent(parentNode, 'mouseleave');
          break;

        case keys.enter:
        case keys.space:
          prevDef = true;
          event.currentTarget.click();
          break;
      }

      if (prevDef) {
        event.preventDefault();
        event.stopPropagation();
      }

      return false;
    });
  });
};

const MenuItem = function (domNode) {
  this.domNode = domNode;
  this.submenu = null;
  this.init();
};

MenuItem.prototype.init = function () {
  this.domNode.setAttribute('tabindex', '0');
  const menuChild = this.domNode.querySelector('.el-menu');

  if (menuChild) {
    this.submenu = new SubMenu(this, menuChild);
  }

  this.addListeners();
};

MenuItem.prototype.addListeners = function () {
  const keys = Utils.keys;
  this.domNode.addEventListener('keydown', event => {
    let prevDef = false;

    switch (event.keyCode) {
      case keys.down:
        Utils.triggerEvent(event.currentTarget, 'mouseenter');
        this.submenu && this.submenu.gotoSubIndex(0);
        prevDef = true;
        break;

      case keys.up:
        Utils.triggerEvent(event.currentTarget, 'mouseenter');
        this.submenu && this.submenu.gotoSubIndex(this.submenu.subMenuItems.length - 1);
        prevDef = true;
        break;

      case keys.tab:
        Utils.triggerEvent(event.currentTarget, 'mouseleave');
        break;

      case keys.enter:
      case keys.space:
        prevDef = true;
        event.currentTarget.click();
        break;
    }

    if (prevDef) {
      event.preventDefault();
    }
  });
};

const Menu = function (domNode) {
  this.domNode = domNode;
  this.init();
};

Menu.prototype.init = function () {
  const menuChildren = this.domNode.childNodes;
  [].filter.call(menuChildren, child => child.nodeType === 1).forEach(child => {
    new MenuItem(child); // eslint-disable-line
  });
};

function useMenu(index) {
  const Instance = getCurrentInstance();
  const rootMenu = inject('rootMenu');
  const parent = Instance.parent;
  const indexPath = computed(() => {
    const path = [index];
    let p = parent;

    while (p.type.name !== 'ElMenu') {
      if (p.ctx.index) {
        path.unshift(p.ctx.index);
      }

      p = p.parent;
    }

    return path;
  });
  const parentMenu = computed(() => {
    let p = parent;

    while (p && ['ElMenu', 'ElSubmenu'].indexOf(p.type.name) === -1) {
      p = p.parent;
    }

    return p;
  });
  const paddingStyle = computed(() => {
    if (rootMenu.ctx.mode !== 'vertical') return {};
    let padding = 20;
    let p = parent;

    if (rootMenu.ctx.collapse) {
      padding = 20;
    } else {
      while (p && p.type.name !== 'ElMenu') {
        if (p.type.name === 'ElSubmenu') {
          padding += 20;
        }

        p = p.parent;
      }
    }

    return {
      paddingLeft: padding + 'px'
    };
  });
  return {
    indexPath,
    parentMenu,
    paddingStyle,
    rootMenu
  };
}

function useItems() {
  const items = reactive({});
  const itemsInstance = {};
  const submenus = reactive({});
  const submenusInstance = {};

  const addItem = item => {
    let index = item.ctx.index;
    items[index] = index;
    itemsInstance[index] = item;
  };

  const removeItem = item => {
    let index = item.ctx.index;
    delete items[index];
    delete itemsInstance[index];
  };

  const addSubmenu = item => {
    let index = item.ctx.index;
    submenus[index] = index;
    submenusInstance[index] = item;
  };

  const removeSubmenu = item => {
    let index = item.ctx.index;
    delete submenus[index];
    delete submenusInstance[index];
  };

  return {
    items,
    itemsInstance,
    submenus,
    submenusInstance,
    addItem,
    removeItem,
    addSubmenu,
    removeSubmenu
  };
}

var script$12 = {
  render(ctx) {
    const data = {
      mode: 'out-in',

      onBeforeEnter(el) {
        el.style.opacity = 0.2;
      },

      onEnter(el) {
        addClass(el, 'el-opacity-transition');
        el.style.opacity = 1;
      },

      onAfterEnter(el) {
        removeClass(el, 'el-opacity-transition');
        el.style.opacity = '';
      },

      onBeforeLeave(el) {
        if (!el.dataset) el.dataset = {};

        if (hasClass(el, 'el-menu--collapse')) {
          removeClass(el, 'el-menu--collapse');
          el.dataset.oldOverflow = el.style.overflow;
          el.dataset.scrollWidth = el.clientWidth;
          addClass(el, 'el-menu--collapse');
        } else {
          addClass(el, 'el-menu--collapse');
          el.dataset.oldOverflow = el.style.overflow;
          el.dataset.scrollWidth = el.clientWidth;
          removeClass(el, 'el-menu--collapse');
        }

        el.style.width = el.scrollWidth + 'px';
        el.style.overflow = 'hidden';
      },

      onLeave(el) {
        addClass(el, 'horizontal-collapse-transition');
        el.style.width = el.dataset.scrollWidth + 'px';
      }

    };
    return h(Transition, data, ctx.$slots);
  }

};

script$12.__file = "packages/menu/MenuCollapseTransition.vue";

var script$13 = {
  name: 'ElMenu',
  componentName: 'ElMenu',

  render() {
    const component = createVNode("ul", {
      "role": "menubar",
      "key": +this.collapse,
      "style": {
        backgroundColor: this.backgroundColor || ''
      },
      "class": {
        'el-menu--horizontal': this.mode === 'horizontal',
        'el-menu--collapse': this.collapse,
        'el-menu': true
      }
    }, [this.$slots.default()]);

    if (this.collapseTransition) {
      return createVNode(resolveComponent("el-menu-collapse-transition"), null, {
        default: () => [component]
      });
    } else {
      return component;
    }
  },

  components: {
    'el-menu-collapse-transition': script$12
  },
  props: {
    mode: {
      type: String,
      default: 'vertical'
    },
    defaultActive: {
      type: String,
      default: ''
    },
    defaultOpeneds: {
      type: Array,
      default: null
    },
    uniqueOpened: Boolean,
    router: Boolean,
    menuTrigger: {
      type: String,
      default: 'hover'
    },
    collapse: {
      type: Boolean,
      default: false
    },
    backgroundColor: {
      type: String,
      default: ''
    },
    textColor: String,
    activeTextColor: String,
    collapseTransition: {
      type: Boolean,
      default: true
    }
  },
  emits: ['close', 'open', 'select', 'on'],

  setup(props, {
    emit
  }) {
    const {
      defaultActive,
      defaultOpeneds,
      collapse,
      uniqueOpened,
      backgroundColor,
      mode,
      router
    } = toRefs(props);
    const instance = getCurrentInstance();
    const {
      broadcast,
      on
    } = useEmitter();
    const activeIndex = ref(defaultActive.value);
    const openedMenus = ref(defaultOpeneds.value && !collapse.value ? defaultOpeneds.value.slice(0) : []);
    const {
      items,
      itemsInstance,
      submenusInstance,
      addItem,
      removeItem,
      addSubmenu,
      removeSubmenu
    } = useItems();

    const updateActiveIndex = val => {
      let item = items[val] || items[activeIndex.value] || items[defaultActive.value];
      item = itemsInstance[item];

      if (item) {
        activeIndex.value = item.ctx.index;
        initOpenedMenu();
      } else {
        activeIndex.value = null;
      }
    };

    const getColorChannels = color => {
      color = color.replace('#', '');

      if (/^[0-9a-fA-F]{3}$/.test(color)) {
        color = color.split('');

        for (let i = 2; i >= 0; i--) {
          color.splice(i, 0, color[i]);
        }

        color = color.join('');
      }

      if (/^[0-9a-fA-F]{6}$/.test(color)) {
        return {
          red: parseInt(color.slice(0, 2), 16),
          green: parseInt(color.slice(2, 4), 16),
          blue: parseInt(color.slice(4, 6), 16)
        };
      } else {
        return {
          red: 255,
          green: 255,
          blue: 255
        };
      }
    };

    const mixColor = (color, percent) => {
      let {
        red,
        green,
        blue
      } = getColorChannels(color);

      if (percent > 0) {
        // shade given color
        red *= 1 - percent;
        green *= 1 - percent;
        blue *= 1 - percent;
      } else {
        // tint given color
        red += (255 - red) * percent;
        green += (255 - green) * percent;
        blue += (255 - blue) * percent;
      }

      return `rgb(${Math.round(red)}, ${Math.round(green)}, ${Math.round(blue)})`;
    };

    const openMenu = (index, indexPath) => {
      if (openedMenus.value.indexOf(index) !== -1) return; // 将不在该菜单路径下的其余菜单收起
      // collapse all menu that are not under current menu item

      if (uniqueOpened.value) {
        openedMenus.value = openedMenus.value.filter(index => {
          return indexPath.indexOf(index) !== -1;
        });
      }

      openedMenus.value.push(index);
    };

    const closeMenu = index => {
      const i = openedMenus.value.indexOf(index);

      if (i !== -1) {
        openedMenus.value.splice(i, 1);
      }
    };

    const handleSubmenuClick = submenu => {
      const {
        index,
        indexPath
      } = submenu.ctx;
      const isOpened = openedMenus.value.indexOf(index) !== -1;

      if (isOpened) {
        closeMenu(index);
        emit('close', index, indexPath);
      } else {
        openMenu(index, indexPath);
        emit('open', index, indexPath);
      }
    };

    const handleItemClick = item => {
      const {
        index,
        indexPath
      } = item.ctx;
      const oldActiveIndex = activeIndex.value;
      const hasIndex = index !== null;

      if (hasIndex) {
        activeIndex.value = index;
      }

      emit('select', index, indexPath, item);

      if (mode.value === 'horizontal' || collapse.value) {
        openedMenus.value.length = 0;
      }

      if (router.value && hasIndex) {
        routeToItem(item, error => {
          activeIndex.value = oldActiveIndex;

          if (error) {
            // vue-router 3.1.0+ push/replace cause NavigationDuplicated error
            // https://github.com/ElemeFE/element/issues/17044
            if (error.name === 'NavigationDuplicated') return;
            console.error(error);
          }
        });
      }
    };

    const initOpenedMenu = () => {
      const index = activeIndex.value;
      const activeItem = itemsInstance[index];
      if (!activeItem || mode.value === 'horizontal' || collapse.value) return;
      const indexPath = activeItem.ctx.indexPath; // 展开该菜单项的路径上所有子菜单
      // expand all submenus of the menu item

      indexPath.forEach(index => {
        const submenu = submenusInstance[index];
        submenu && openMenu(index, submenu.ctx.indexPath);
      });
    };

    const routeToItem = (item, onError) => {
      const route = item.ctx.route || item.ctx.index;

      try {
        instance.ctx.$router.push(route, () => {}, onError);
      } catch (e) {
        console.error(e);
      }
    };

    const open = index => {
      const {
        indexPath
      } = submenusInstance[index.toString()];
      indexPath.forEach(i => openMenu(i, indexPath));
    };

    const close = index => {
      closeMenu(index);
    };

    const hoverBackground = computed(() => {
      return backgroundColor.value ? mixColor(backgroundColor.value, 0.2) : '';
    });
    const isMenuPopup = computed(() => {
      return mode.value === 'horizontal' || mode.value === 'vertical' && collapse.value;
    });
    watch(defaultActive, value => {
      if (!items[value]) {
        activeIndex.value = null;
      }

      updateActiveIndex(value);
    });
    watch(defaultOpeneds, value => {
      if (!collapse.value) {
        openedMenus.value = value;
      }
    });
    watch(collapse, value => {
      if (value) openedMenus.value = [];
      broadcast('toggle-collapse', value);
    });
    onMounted(() => {
      initOpenedMenu();
      on('item-click', handleItemClick);
      on('submenu-click', handleSubmenuClick);

      if (mode.value === 'horizontal') {
        new Menu(instance.ctx.$el);
      }

      watch(items, updateActiveIndex);
    });
    provide('rootMenu', instance);
    return {
      addItem,
      removeItem,
      addSubmenu,
      removeSubmenu,
      openedMenus,
      activeIndex,
      hoverBackground,
      isMenuPopup,
      openMenu,
      closeMenu,
      open,
      close
    };
  }

};

script$13.__file = "packages/menu/Menu.vue";

/* istanbul ignore next */

script$13.install = function (app) {
  app.component(script$13.name, script$13);
};

var script$14 = {
  name: 'ElMenuItem',
  componentName: 'ElMenuItem',
  components: {
    ElTooltip
  },
  props: {
    index: {
      default: null,
      validator: val => typeof val === 'string' || val === null
    },
    route: [String, Object],
    disabled: Boolean
  },
  emits: ['click'],

  setup(props, {
    emit
  }) {
    const {
      index,
      disabled
    } = toRefs(props);
    const {
      parentMenu,
      paddingStyle,
      rootMenu,
      indexPath
    } = useMenu(index.value);
    const instance = getCurrentInstance();
    const {
      dispatch
    } = useEmitter();
    const active = computed(() => {
      return index.value === rootMenu.ctx.activeIndex;
    });
    const hoverBackground = computed(() => {
      return rootMenu.ctx.hoverBackground;
    });
    const backgroundColor = computed(() => {
      return rootMenu.ctx.backgroundColor || '';
    });
    const itemBackgroundColor = ref(backgroundColor.value);
    const activeTextColor = computed(() => {
      return rootMenu.ctx.activeTextColor || '';
    });
    const textColor = computed(() => {
      return rootMenu.ctx.textColor || '';
    });
    const mode = computed(() => {
      return rootMenu.ctx.mode;
    });
    const isNested = computed(() => {
      return parentMenu !== rootMenu;
    });
    const itemStyle = computed(() => {
      const style = {
        color: active.value ? activeTextColor.value : textColor.value
      };

      if (mode.value === 'horizontal' && !isNested.value) {
        style.borderBottomColor = active.value ? rootMenu.activeTextColor.value ? activeTextColor.value : '' : 'transparent';
      }

      return style;
    });

    const onMouseEnter = () => {
      hoverBackground.value && (itemBackgroundColor.value = hoverBackground.value);
    };

    const onMouseLeave = () => {
      itemBackgroundColor.value = backgroundColor.value;
    };

    const handleClick = () => {
      if (!disabled.value) {
        dispatch('item-click', instance);
        emit('click', instance);
      }
    };

    onMounted(() => {
      parentMenu.value.ctx.addItem(instance);
      rootMenu.ctx.addItem(instance);
    });
    onBeforeUnmount(() => {
      parentMenu.value.ctx.removeItem(instance);
      rootMenu.ctx.removeItem(instance);
    });
    return {
      paddingStyle,
      itemStyle,
      active,
      handleClick,
      onMouseEnter,
      onMouseLeave,
      rootMenu,
      parentMenu,
      indexPath,
      itemBackgroundColor
    };
  }

};

const _hoisted_1$C = { style: {"position":"absolute","left":"0","top":"0","height":"100%","width":"100%","display":"inline-block","box-sizing":"border-box","padding":"0 20px"} };

function render$Z(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_tooltip = resolveComponent("el-tooltip");

  return (openBlock(), createBlock("li", {
    class: ["el-menu-item", {
      'is-active': $setup.active,
      'is-disabled': $props.disabled
    }],
    role: "menuitem",
    tabindex: "-1",
    style: [$setup.paddingStyle, $setup.itemStyle, { backgroundColor: $setup.itemBackgroundColor }],
    onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleClick(...args))),
    onMouseenter: _cache[2] || (_cache[2] = (...args) => ($setup.onMouseEnter(...args))),
    onFocus: _cache[3] || (_cache[3] = (...args) => ($setup.onMouseEnter(...args))),
    onBlur: _cache[4] || (_cache[4] = (...args) => ($setup.onMouseLeave(...args))),
    onMouseleave: _cache[5] || (_cache[5] = (...args) => ($setup.onMouseLeave(...args)))
  }, [
    (
        $setup.parentMenu.type.name === 'ElMenu' && $setup.rootMenu.collapse && _ctx.$slots.title
      )
      ? (openBlock(), createBlock(_component_el_tooltip, {
          key: 0,
          effect: "dark",
          placement: "right"
        }, {
          content: withCtx(() => [
            createVNode("div", null, [
              renderSlot(_ctx.$slots, "title")
            ])
          ]),
          default: withCtx(() => [
            createVNode("div", _hoisted_1$C, [
              renderSlot(_ctx.$slots, "default")
            ])
          ]),
          _: 3
        }))
      : (openBlock(), createBlock(Fragment, { key: 1 }, [
          renderSlot(_ctx.$slots, "default"),
          renderSlot(_ctx.$slots, "title")
        ], 64 /* STABLE_FRAGMENT */))
  ], 38 /* CLASS, STYLE, HYDRATE_EVENTS */))
}

script$14.render = render$Z;
script$14.__file = "packages/menu/MenuItem.vue";

/* istanbul ignore next */

script$14.install = function (app) {
  app.component(script$14.name, script$14);
};

var script$15 = {
  name: 'ElSubmenu',
  componentName: 'ElSubmenu',
  components: {
    ElCollapseTransition
  },
  props: { ...popperProps,
    transformOrigin: {
      type: [Boolean, String],
      default: false
    },
    index: {
      type: String,
      required: true
    },
    showTimeout: {
      type: Number,
      default: 300
    },
    hideTimeout: {
      type: Number,
      default: 300
    },
    popperClass: String,
    disabled: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: undefined
    }
  },
  emits: ['updatePopper', 'visible', 'update:modelValue', 'created'],

  setup(props, {
    emit,
    slots
  }) {
    const {
      index,
      disabled,
      showTimeout,
      hideTimeout,
      popperAppendToBody
    } = toRefs(props);
    const popperElm = ref(null);
    const referenceElm = ref(null);
    const menu = ref(null);
    const {
      doDestroy,
      showPopper,
      currentPlacement,
      updatePopper
    } = usePopper(props, {
      emit,
      slots
    }, {
      popperElm,
      referenceElm
    });
    const {
      parentMenu,
      paddingStyle,
      rootMenu,
      indexPath
    } = useMenu(index.value);
    const timeout = ref(null);
    const {
      items,
      itemsInstance,
      submenus,
      submenusInstance,
      addItem,
      removeItem,
      addSubmenu,
      removeSubmenu
    } = useItems();
    const mouseInChild = ref(false);
    const instance = getCurrentInstance();
    const {
      dispatch,
      on
    } = useEmitter();

    const handleCollapseToggle = value => {
      if (value) {
        initPopper();
      } else {
        doDestroy();
      }
    };

    const handleClick = () => {
      if (rootMenu.ctx.menuTrigger === 'hover' && rootMenu.ctx.mode === 'horizontal' || rootMenu.ctx.collapse && rootMenu.ctx.mode === 'vertical' || disabled.value) {
        return;
      }

      dispatch('submenu-click', instance);
    };

    const handleMouseenter = (event, delay = showTimeout.value) => {
      if (!('ActiveXObject' in window) && event.type === 'focus' && !event.relatedTarget) {
        return;
      }

      if (rootMenu.ctx.menuTrigger === 'click' && rootMenu.ctx.mode === 'horizontal' || !rootMenu.ctx.collapse && rootMenu.ctx.mode === 'vertical' || disabled.value) {
        return;
      }

      dispatch('mouse-enter-child');
      clearTimeout(timeout.value);
      timeout.value = setTimeout(() => {
        rootMenu.ctx.openMenu(index.value, indexPath);
      }, delay);

      if (appendToBody.value) {
        instance.parent.ctx.$el.dispatchEvent(new MouseEvent('mouseenter'));
      }
    };

    const handleMouseleave = (deepDispatch = false) => {
      if (rootMenu.ctx.menuTrigger === 'click' && rootMenu.ctx.mode === 'horizontal' || !rootMenu.ctx.collapse && rootMenu.ctx.mode === 'vertical') {
        return;
      }

      dispatch('mouse-leave-child');
      clearTimeout(timeout.value);
      timeout.value = setTimeout(() => {
        !mouseInChild.value && rootMenu.ctx.closeMenu(index.value);
      }, hideTimeout.value);

      if (appendToBody.value && deepDispatch) {
        if (parentMenu.value && parentMenu.value.type.name === 'ElSubmenu') {
          parentMenu.value.ctx.handleMouseleave(true);
        }
      }
    };

    const handleTitleMouseenter = () => {
      hoverBackground.value && (titleBackground.value = hoverBackground.value);
    };

    const handleTitleMouseleave = () => {
      titleBackground.value = backgroundColor.value;
    };

    const isFirstLevel = computed(() => {
      let isFirstLevel = true;
      let parent = instance.parent;

      while (parent && parent !== rootMenu) {
        if (['ElSubmenu', 'ElMenuItemGroup'].indexOf(parent.type.name) > -1) {
          isFirstLevel = false;
          break;
        } else {
          parent = parent.parent;
        }
      }

      return isFirstLevel;
    });

    const updatePlacement = () => {
      currentPlacement.value = mode.value === 'horizontal' && isFirstLevel.value ? 'bottom-start' : 'right-start';
    };

    const initPopper = () => {
      referenceElm.value = instance.ctx.$el;
      popperElm.value = menu.value;
      updatePlacement();
    };

    const appendToBody = computed(() => {
      return popperAppendToBody.value === undefined ? isFirstLevel : popperAppendToBody.value;
    });
    const menuTransitionName = computed(() => {
      return rootMenu.ctx.collapse ? 'el-zoom-in-left' : 'el-zoom-in-top';
    });
    watch(rootMenu.ctx.openedMenus, val => {
      showPopper.value = val.indexOf(index.value) > -1;
    });
    const active = computed(() => {
      let isActive = false;
      Object.keys(items).forEach(index => {
        if (itemsInstance[index].ctx.active) {
          isActive = true;
        }
      });
      Object.keys(submenus).forEach(index => {
        if (submenusInstance[index].ctx.active) {
          isActive = true;
        }
      });
      return isActive;
    });
    const hoverBackground = computed(() => {
      return rootMenu.ctx.hoverBackground;
    });
    const backgroundColor = computed(() => {
      return rootMenu.ctx.backgroundColor || '';
    });
    const titleBackground = ref(backgroundColor.value);
    const activeTextColor = computed(() => {
      return rootMenu.ctx.activeTextColor || '';
    });
    const textColor = computed(() => {
      return rootMenu.ctx.textColor || '';
    });
    const mode = computed(() => {
      return rootMenu.ctx.mode;
    });
    const isMenuPopup = computed(() => {
      return rootMenu.ctx.isMenuPopup;
    });
    const titleStyle = computed(() => {
      if (mode.value !== 'horizontal') {
        return {
          color: textColor.value
        };
      }

      return {
        borderBottomColor: active.value ? activeTextColor.value ? activeTextColor.value : '' : 'transparent',
        color: active.value ? activeTextColor.value : textColor.value
      };
    });
    watch(showPopper, () => {
      if (isMenuPopup.value) {
        nextTick(() => {
          updatePopper();
        });
      }
    });
    on('toggle-collapse', handleCollapseToggle);
    on('mouse-enter-child', () => {
      mouseInChild.value = true;
      clearTimeout(timeout.value);
    });
    on('mouse-leave-child', () => {
      mouseInChild.value = false;
      clearTimeout(timeout.value);
    });
    onMounted(() => {
      parentMenu.value.ctx.addSubmenu(instance);
      rootMenu.ctx.addSubmenu(instance);
      initPopper();
      showPopper.value = rootMenu.ctx.openedMenus.indexOf(index.value) > -1;
    });
    onBeforeUnmount(() => {
      parentMenu.value.ctx.removeSubmenu(instance);
      rootMenu.ctx.removeSubmenu(instance);
    });
    return {
      active,
      paddingStyle,
      titleStyle,
      backgroundColor,
      rootMenu,
      currentPlacement,
      menuTransitionName,
      mode,
      isFirstLevel,
      isMenuPopup,
      handleTitleMouseleave,
      handleTitleMouseenter,
      handleClick,
      handleMouseenter,
      addItem,
      removeItem,
      addSubmenu,
      removeSubmenu,
      showPopper,
      handleMouseleave,
      menu,
      titleBackground,
      indexPath
    };
  },

  render() {
    const {
      active,
      showPopper,
      paddingStyle,
      titleStyle,
      backgroundColor,
      rootMenu,
      currentPlacement,
      menuTransitionName,
      mode,
      disabled,
      popperClass,
      $slots,
      isFirstLevel,
      isMenuPopup,
      handleMouseenter,
      handleMouseleave,
      handleClick,
      handleTitleMouseleave,
      handleTitleMouseenter,
      titleBackground
    } = this;
    const popupMenu = createVNode(Transition, {
      "name": menuTransitionName
    }, {
      default: () => [withDirectives(createVNode("div", {
        "ref": "menu",
        "class": [`el-menu--${mode}`, popperClass],
        "onMouseenter": $event => handleMouseenter($event, 100),
        "onMouseleave": () => handleMouseleave(true),
        "onFocus": $event => handleMouseenter($event, 100)
      }, [createVNode("ul", {
        "role": "menu",
        "class": ['el-menu el-menu--popup', `el-menu--popup-${currentPlacement}`],
        "style": {
          backgroundColor
        }
      }, [$slots.default()])]), [[vShow, showPopper]])]
    });
    const inlineMenu = createVNode(resolveComponent("el-collapse-transition"), null, {
      default: () => [withDirectives(createVNode("ul", {
        "role": "menu",
        "class": "el-menu el-menu--inline",
        "style": {
          backgroundColor
        }
      }, [$slots.default()]), [[vShow, showPopper]])]
    });
    const submenuTitleIcon = rootMenu.ctx.mode === 'horizontal' && isFirstLevel || rootMenu.ctx.mode === 'vertical' && !rootMenu.ctx.collapse ? 'el-icon-arrow-down' : 'el-icon-arrow-right';
    return createVNode("li", {
      "class": {
        'el-submenu': true,
        'is-active': active,
        'is-opened': showPopper,
        'is-disabled': disabled
      },
      "role": "menuitem",
      "aria-haspopup": "true",
      "aria-expanded": showPopper,
      "onMouseenter": handleMouseenter,
      "onMouseleave": () => {
        handleMouseleave(false);
      },
      "onFocus": handleMouseenter
    }, [createVNode("div", {
      "class": "el-submenu__title",
      "onClick": handleClick,
      "onMouseenter": handleTitleMouseenter,
      "onMouseleave": handleTitleMouseleave,
      "style": [paddingStyle, titleStyle, {
        backgroundColor: titleBackground
      }]
    }, [$slots.title && $slots.title(), createVNode("i", {
      "class": ['el-submenu__icon-arrow', submenuTitleIcon]
    }, null)]), isMenuPopup ? popupMenu : inlineMenu]);
  }

};

script$15.__file = "packages/menu/Submenu.vue";

/* istanbul ignore next */

script$15.install = function (app) {
  app.component(script$15.name, script$15);
};

var script$16 = {
  name: 'ElMenuItemGroup',
  componentName: 'ElMenuItemGroup',
  props: {
    title: {
      type: String
    }
  },

  setup() {
    const instance = getCurrentInstance();
    const rootMenu = inject('rootMenu');
    const levelPadding = computed(() => {
      let padding = 20;
      let parent = instance.parent;
      if (rootMenu.ctx.collapse) return 20;

      while (parent && parent.type.name !== 'ElMenu') {
        if (parent.type.name === 'ElSubmenu') {
          padding += 20;
        }

        parent = parent.parent;
      }

      return padding;
    });
    return {
      levelPadding
    };
  }

};

const _hoisted_1$D = { class: "el-menu-item-group" };

function render$_(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("li", _hoisted_1$D, [
    createVNode("div", {
      class: "el-menu-item-group__title",
      style: { paddingLeft: $setup.levelPadding + 'px' }
    }, [
      (!_ctx.$slots.title)
        ? (openBlock(), createBlock(Fragment, { key: 0 }, [
            createTextVNode(toDisplayString($props.title), 1 /* TEXT */)
          ], 64 /* STABLE_FRAGMENT */))
        : renderSlot(_ctx.$slots, "title", { key: 1 })
    ], 4 /* STYLE */),
    createVNode("ul", null, [
      renderSlot(_ctx.$slots, "default")
    ])
  ]))
}

script$16.render = render$_;
script$16.__file = "packages/menu/MenuItemGroup.vue";

/* istanbul ignore next */

script$16.install = function (app) {
  app.component(script$16.name, script$16);
};

var script$17 = {
  name: 'ElTabs',
  props: {
    modelValue: [String, Number],
    type: {
      type: String,
      default: ''
    },
    closable: Boolean,
    addable: Boolean,
    editable: Boolean,
    tabPosition: {
      type: String,
      default: 'top'
    },
    stretch: Boolean,
    beforeLeave: {
      type: Function,
      default: () => () => true
    }
  },
  emits: ['update:modelValue', 'tab-click', 'tab-remove', 'tab-add', 'edit'],
  setup: function (props) {
    const tabList = reactive([]);
    const tabElList = reactive([]);
    const {
      scrollable,
      tabs,
      tabScroll,
      tabNav,
      direction,
      scrollToActive,
      handleClickLeft,
      handleClickRight
    } = useTabScroll({
      tabElList
    });
    const {
      state,
      handleClick,
      handleClose
    } = useTabNav({
      tabElList,
      tabList,
      scrollToActive
    });
    const {
      activeBarStyle
    } = useTabBarStyle({
      tabList,
      state,
      direction
    });
    provide('elTabsInfo', {
      tabList,
      props,
      state
    });
    return {
      activeBarStyle,
      state,
      tabList,
      tabElList,
      scrollable,
      tabScroll,
      tabNav,
      tabs,
      handleClick,
      handleClose,
      handleClickLeft,
      handleClickRight
    };
  }
};

function useTabBarStyle({
  tabList,
  state,
  direction
}) {
  const activeBarStyle = computed(() => {
    const {
      sizeName,
      textSizeName,
      posName,
      dirFlag
    } = direction.value;
    return [`${sizeName}: ${tabList[state.activeIndex] && tabList[state.activeIndex][textSizeName]}px`, `transform: translate${dirFlag}(${tabList[state.activeIndex] && tabList[state.activeIndex][posName]}px)`];
  });
  return {
    activeBarStyle
  };
}

function useTabNav({
  tabList,
  tabElList,
  scrollToActive
}) {
  const instance = getCurrentInstance();
  const state = reactive({
    activeName: '',
    activeIndex: -1
  });
  watch(toRefs(instance.props).modelValue || ref(null), v => {
    const tabIndex = tabList.findIndex(item => item.name === v);
    if (tabIndex === -1) return;
    switchTab(tabList[tabIndex], tabIndex);
  });
  onMounted(async () => {
    await nextTick();
    if (!tabList.length) return;
    await handleClick(tabList[0], 0);
  });
  onUpdated(async () => {
    await nextTick();
    tabElList.forEach((el, index) => {
      const style = window.getComputedStyle(el);
      tabList[index].width = parseFloat(style.width);
      tabList[index].textWidth = parseFloat(style.width) - (parseFloat(style.paddingLeft) + parseFloat(style.paddingRight));
      tabList[index].height = parseFloat(style.height);
      tabList[index].textHeight = parseFloat(style.height) - (parseFloat(style.paddingTop) + parseFloat(style.paddingBottom));
      tabList[index].x = parseFloat(style.paddingLeft) + parseFloat(el.offsetLeft);
      tabList[index].y = parseFloat(style.paddingTop) + parseFloat(el.offsetTop);
    });
  });

  const switchTab = async (item, index) => {
    if (index === state.activeIndex) {
      return false;
    }

    if (item.disabled) {
      return false;
    }

    const isLeave = await instance.props.beforeLeave(item.name, state.activeName);

    if (!isLeave) {
      return false;
    }

    item.rendered = true;
    state.activeName = item.name;
    state.activeIndex = index;
    scrollToActive(item);
    return true;
  };

  const handleClick = async (item, index, e) => {
    await switchTab(item, index);
    instance.emit('update:modelValue', state.activeName);
    instance.emit('tab-click', tabList[index], e);
  };

  const handleClose = (item, index, e) => {
    tabList.splice(index, 1);
    nextTick(() => {
      tabElList.splice(index, 1);
    });
    instance.emit('tab-remove', item.name, index, item, e);
    instance.emit('edit', item.name, 'remove');
  };

  return {
    state,
    handleClick,
    handleClose
  };
}

function useTabScroll({
  tabElList
}) {
  const instance = getCurrentInstance();
  const tabs = ref(null);
  const tabScroll = ref(null);
  const tabNav = ref(null);
  const scrollable = ref(false);
  const scrollSize = ref(0);
  const direction = computed(() => {
    const dirFlag = {
      bottom: true,
      top: true
    }[instance.props.tabPosition] ? 'X' : 'Y';
    const sizeName = {
      X: 'width',
      Y: 'height'
    }[dirFlag];
    const textSizeName = {
      X: 'textWidth',
      Y: 'textHeight'
    }[dirFlag];
    const offsetName = {
      X: 'offsetWidth',
      Y: 'offsetHeight'
    }[dirFlag];
    const scrollName = {
      X: 'scrollWidth',
      Y: 'scrollHeight'
    }[dirFlag];
    const posName = dirFlag.toLocaleLowerCase();
    scrollSize.value = 0;
    dirFlag === 'X' ? instance.refs.hander && instance.refs.hander.before(instance.refs.content) : instance.refs.content && instance.refs.content.before(instance.refs.hander);
    return {
      dirFlag,
      sizeName,
      textSizeName,
      posName,
      offsetName,
      scrollName
    };
  });
  const viewArea = computed(() => {
    const {
      offsetName
    } = direction.value;
    return {
      start: Math.abs(scrollSize.value),
      end: Math.abs(scrollSize.value) + tabScroll.value[offsetName]
    };
  });
  onUpdated(async () => {
    await nextTick();
    const {
      sizeName,
      offsetName
    } = direction.value;
    let sizeSum = 0;
    tabElList.forEach(el => {
      const style = window.getComputedStyle(el);
      sizeSum += parseFloat(style[sizeName]);
    });
    scrollable.value = sizeSum > tabScroll.value[offsetName];
  });
  watch(scrollSize, () => {
    const {
      dirFlag,
      offsetName
    } = direction.value;
    scrollSize.value = Math.min(scrollSize.value, 0);
    scrollSize.value = Math.max(scrollSize.value, tabScroll.value[offsetName] - tabNav.value[offsetName]);
    tabNav.value.style.transform = `translate${dirFlag}(${scrollSize.value}px)`;
  });

  const scrollToActive = item => {
    if (!scrollable.value) {
      return;
    }

    const {
      sizeName,
      posName,
      offsetName
    } = direction.value;
    scrollSize.value = (item[posName] + item[sizeName] / 2) * -1 + tabScroll.value[offsetName] / 2;
  };

  const handleClickLeft = () => {
    const {
      offsetName
    } = direction.value;
    scrollSize.value += tabScroll.value[offsetName];
  };

  const handleClickRight = () => {
    const {
      offsetName
    } = direction.value;
    scrollSize.value -= tabScroll.value[offsetName];
  };

  return {
    viewArea,
    scrollable,
    tabs,
    tabNav,
    tabScroll,
    direction,
    scrollToActive,
    handleClickLeft,
    handleClickRight
  };
}

const _hoisted_1$E = /*#__PURE__*/createVNode("i", { class: "el-icon-plus" }, null, -1 /* HOISTED */);
const _hoisted_2$p = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-left" }, null, -1 /* HOISTED */);
const _hoisted_3$i = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-right" }, null, -1 /* HOISTED */);
const _hoisted_4$a = {
  class: "el-tabs__nav-scroll",
  ref: "tabScroll"
};
const _hoisted_5$9 = {
  ref: "content",
  class: "el-tabs__content"
};

function render$$(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-tabs", [
      'el-tabs--' + $props.tabPosition,
      {
        'el-tabs--card': $props.type === 'card',
        'el-tabs--border-card': $props.type === 'border-card'
      }
    ]],
    ref: "tabs"
  }, [
    createVNode("div", {
      ref: "hander",
      class: ["el-tabs__header", ['is-' + $props.tabPosition]]
    }, [
      ($props.addable || $props.editable)
        ? (openBlock(), createBlock("span", {
            key: 0,
            tabindex: "0",
            class: "el-tabs__new-tab",
            onClick: _cache[1] || (_cache[1] = $event => (_ctx.$emit('edit', null, 'add')))
          }, [
            _hoisted_1$E
          ]))
        : createCommentVNode("v-if", true),
      createVNode("div", {
        class: ["el-tabs__nav-wrap", ['is-' + $props.tabPosition, { 'is-scrollable': _ctx.scrollable }]]
      }, [
        (_ctx.scrollable)
          ? (openBlock(), createBlock("span", {
              key: 0,
              class: "el-tabs__nav-prev",
              onClick: _cache[2] || (_cache[2] = (...args) => (_ctx.handleClickLeft(...args)))
            }, [
              _hoisted_2$p
            ]))
          : createCommentVNode("v-if", true),
        (_ctx.scrollable)
          ? (openBlock(), createBlock("span", {
              key: 1,
              class: "el-tabs__nav-next",
              onClick: _cache[3] || (_cache[3] = (...args) => (_ctx.handleClickRight(...args)))
            }, [
              _hoisted_3$i
            ]))
          : createCommentVNode("v-if", true),
        createVNode("div", _hoisted_4$a, [
          createVNode("div", {
            class: ["el-tabs__nav", [
              'is-' + $props.tabPosition,
              {
                'is-stretch':
                  $props.stretch && { top: true, bottom: true }[$props.tabPosition]
              }
            ]],
            ref: "tabNav"
          }, [
            createVNode("div", {
              class: ["el-tabs__active-bar", ['is-' + $props.tabPosition]],
              style: _ctx.activeBarStyle
            }, null, 6 /* CLASS, STYLE */),
            (openBlock(true), createBlock(Fragment, null, renderList(_ctx.tabList, (item, index) => {
              return (openBlock(), createBlock("div", {
                class: ["el-tabs__item is-closable", [
                'is-' + $props.tabPosition,
                {
                  'is-active': index === _ctx.state.activeIndex,
                  'is-closable': $props.closable || $props.editable || item.closable,
                  'is-disabled': item.disabled
                }
              ]],
                role: "tab",
                tabindex: "-1",
                ref: (el) => (_ctx.tabElList[index] = el),
                key: item.name,
                onClick: $event => (_ctx.handleClick(item, index, $event))
              }, [
                (openBlock(), createBlock(resolveDynamicComponent({
                  render: () => item.pane.slots.label && item.pane.slots.label()
                }))),
                createTextVNode(" " + toDisplayString(item.label) + " ", 1 /* TEXT */),
                ($props.closable || $props.editable || item.closable)
                  ? (openBlock(), createBlock("span", {
                      key: 0,
                      class: "el-icon-close",
                      onClick: withModifiers($event => (_ctx.handleClose(item, index, $event)), ["stop"])
                    }, null, 8 /* PROPS */, ["onClick"]))
                  : createCommentVNode("v-if", true)
              ], 10 /* CLASS, PROPS */, ["onClick"]))
            }), 128 /* KEYED_FRAGMENT */))
          ], 2 /* CLASS */)
        ], 512 /* NEED_PATCH */)
      ], 2 /* CLASS */)
    ], 2 /* CLASS */),
    createVNode("div", _hoisted_5$9, [
      renderSlot(_ctx.$slots, "default")
    ], 512 /* NEED_PATCH */)
  ], 2 /* CLASS */))
}

script$17.render = render$$;
script$17.__file = "packages/tabs/Tabs.vue";

/* istanbul ignore next */

script$17.install = function (app) {
  app.component(script$17.name, script$17);
};

var script$18 = {
  name: 'ElTabPane',
  props: {
    label: [String, Number],
    name: [String, Number],
    disabled: Boolean,
    closable: Boolean,
    lazy: Boolean
  },

  setup(props) {
    const index = ref(0);
    const instance = getCurrentInstance();
    const elTabsInfo = inject('elTabsInfo', null);
    const tab = reactive({
      label: props.label,
      name: props.name,
      disabled: props.disabled,
      closable: props.closable,
      rendered: false,
      pane: instance
    });

    if (!elTabsInfo) {
      console.error('Element: not find parent ETabs');
      return;
    }

    index.value = elTabsInfo.tabList.length;
    elTabsInfo.tabList[index.value] = tab;
    return {
      elTabsInfo,
      tab,
      index
    };
  }

};

const _hoisted_1$F = { key: 0 };

function render$10(_ctx, _cache, $props, $setup, $data, $options) {
  return ($props.lazy ? $setup.tab.rendered : true)
    ? withDirectives((openBlock(), createBlock("div", _hoisted_1$F, [
        renderSlot(_ctx.$slots, "default")
      ], 512 /* NEED_PATCH */)), [
        [vShow, 
      typeof $setup.elTabsInfo.props.modelValue !== 'undefined'
        ? $setup.elTabsInfo.state.activeName === $props.name
        : $setup.elTabsInfo.state.activeIndex === $setup.index
    ]
      ])
    : createCommentVNode("v-if", true)
}

script$18.render = render$10;
script$18.__file = "packages/tab-pane/TabPane.vue";

/* istanbul ignore next */

script$18.install = function (app) {
  app.component(script$18.name, script$18);
};

var script$19 = {
  name: 'ElBreadcrumb',
  props: {
    separator: {
      type: String,
      default: '/'
    },
    separatorClass: {
      type: String,
      default: ''
    }
  },

  setup(props) {
    const {
      separator,
      separatorClass
    } = toRefs(props);
    const root = ref(null);
    provide('separator', separator);
    provide('separatorClass', separatorClass);
    onMounted(() => {
      const items = root.value.querySelectorAll('.el-breadcrumb__item');

      if (items.length) {
        items[items.length - 1].setAttribute('aria-current', 'page');
      }
    });
    return {
      root
    };
  }

};

const _hoisted_1$G = {
  ref: "root",
  class: "el-breadcrumb",
  "aria-label": "Breadcrumb",
  role: "navigation"
};

function render$11(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$G, [
    renderSlot(_ctx.$slots, "default")
  ], 512 /* NEED_PATCH */))
}

script$19.render = render$11;
script$19.__file = "packages/breadcrumb/Breadcrumb.vue";

/* istanbul ignore next */

script$19.install = function (app) {
  app.component(script$19.name, script$19);
};

var script$1a = {
  name: 'ElBreadcrumbItem',
  props: {
    to: {},
    replace: Boolean
  },

  setup(props) {
    const {
      replace
    } = toRefs(props);
    const separator = inject('separator');
    const separatorClass = inject('separatorClass');
    const link = ref(null);
    const {
      ctx
    } = getCurrentInstance();
    onMounted(() => {
      link.value.setAttribute('role', 'link');
      link.value.addEventListener('click', () => {
        if (!props.to || !ctx.$router) return;
        replace ? ctx.$router.replace(props.to) : ctx.$router.push(props.to);
      });
    });
    return {
      separator,
      separatorClass,
      link
    };
  }

};

const _hoisted_1$H = { class: "el-breadcrumb__item" };
const _hoisted_2$q = {
  key: 1,
  class: "el-breadcrumb__separator",
  role: "presentation"
};

function render$12(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("span", _hoisted_1$H, [
    createVNode("span", {
      class: ['el-breadcrumb__inner', $props.to ? 'is-link' : ''],
      ref: "link",
      role: "link"
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 2 /* CLASS */),
    ($setup.separatorClass)
      ? (openBlock(), createBlock("i", {
          key: 0,
          class: ["el-breadcrumb__separator", $setup.separatorClass]
        }, null, 2 /* CLASS */))
      : (openBlock(), createBlock("span", _hoisted_2$q, toDisplayString($setup.separator), 1 /* TEXT */))
  ]))
}

script$1a.render = render$12;
script$1a.__file = "packages/breadcrumb/BreadcrumbItem.vue";

/* istanbul ignore next */

script$1a.install = function (app) {
  app.component(script$1a.name, script$1a);
};

var script$1b = {
  name: 'ElPageHeader',
  props: {
    title: {
      type: String,

      default() {
        return t('el.pageHeader.title');
      }

    },
    content: String
  },
  emits: ['back'],

  setup(props, ctx) {
    const handleClick = evt => {
      ctx.emit('back', evt);
    };

    return {
      handleClick
    };
  }

};

const _hoisted_1$I = { class: "el-page-header" };
const _hoisted_2$r = /*#__PURE__*/createVNode("i", { class: "el-icon-back" }, null, -1 /* HOISTED */);
const _hoisted_3$j = { class: "el-page-header__title" };
const _hoisted_4$b = { class: "el-page-header__content" };

function render$13(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$I, [
    createVNode("div", {
      class: "el-page-header__left",
      onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleClick(...args)))
    }, [
      _hoisted_2$r,
      createVNode("div", _hoisted_3$j, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString($props.title), 1 /* TEXT */)
        ])
      ])
    ]),
    createVNode("div", _hoisted_4$b, [
      renderSlot(_ctx.$slots, "content", {}, () => [
        createTextVNode(toDisplayString($props.content), 1 /* TEXT */)
      ])
    ])
  ]))
}

script$1b.render = render$13;
script$1b.__file = "packages/page-header/PageHeader.vue";

/* istanbul ignore next */

script$1b.install = function (app) {
  app.component(script$1b.name, script$1b);
};

var script$1c = {
  name: 'ElDropdown',
  componentName: 'ElDropdown',
  directives: {
    Clickoutside
  },
  emits: ['menu-item-click', 'visible-change', 'command'],
  components: {
    ElButton: script$7,
    ElButtonGroup: script$8
  },

  provide() {
    return {
      dropdown: this
    };
  },

  props: {
    trigger: {
      type: String,
      default: 'hover'
    },
    type: String,
    size: {
      type: String,
      default: ''
    },
    splitButton: Boolean,
    hideOnClick: {
      type: Boolean,
      default: true
    },
    placement: {
      type: String,
      default: 'bottom-end'
    },
    visibleArrow: {
      default: true
    },
    showTimeout: {
      type: Number,
      default: 250
    },
    hideTimeout: {
      type: Number,
      default: 150
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },

  setup(props, {
    emit,
    slots
  }) {
    const instance = getCurrentInstance();
    const {
      size,
      trigger,
      showTimeout,
      tabindex,
      hideTimeout,
      hideOnClick,
      splitButton,
      type
    } = toRefs(props);
    const dropdownSize = computed(() => {
      var _instance$proxy, _instance$proxy$$ELEM;

      return size.value || ((_instance$proxy = instance.proxy) === null || _instance$proxy === void 0 ? void 0 : (_instance$proxy$$ELEM = _instance$proxy.$ELEMENT) === null || _instance$proxy$$ELEM === void 0 ? void 0 : _instance$proxy$$ELEM.size);
    });
    const timeout = ref(0);
    const visible = ref(false);
    const triggerElm = ref(null);

    const show = () => {
      var _triggerElm$value;

      if ((_triggerElm$value = triggerElm.value) === null || _triggerElm$value === void 0 ? void 0 : _triggerElm$value.disabled) return;
      clearTimeout(timeout.value);
      timeout.value = setTimeout(() => {
        visible.value = true;
      }, trigger.value === 'click' ? 0 : showTimeout.value);
    };

    const hide = () => {
      var _triggerElm$value2;

      if ((_triggerElm$value2 = triggerElm.value) === null || _triggerElm$value2 === void 0 ? void 0 : _triggerElm$value2.disabled) return;
      removeTabindex();

      if (tabindex.value >= 0) {
        resetTabindex(triggerElm.value);
      }

      clearTimeout(timeout.value);
      timeout.value = setTimeout(() => {
        visible.value = false;
      }, trigger.value === 'click' ? 0 : hideTimeout.value);
    };

    const handleClick = () => {
      var _triggerElm$value3;

      if ((_triggerElm$value3 = triggerElm.value) === null || _triggerElm$value3 === void 0 ? void 0 : _triggerElm$value3.disabled) return;

      if (visible.value) {
        hide();
      } else {
        show();
      }
    };

    const menuItems = ref(null);

    const handleTriggerKeyDown = ev => {
      const _keyCode = ev.keyCode;

      if ([38, 40].indexOf(_keyCode) > -1) {
        // up/down
        removeTabindex();
        resetTabindex(menuItems.value[0]);
        menuItems.value[0].focus();
        ev.preventDefault();
        ev.stopPropagation();
      } else if (_keyCode === 13) {
        // space enter选中
        handleClick();
      } else if ([9, 27].indexOf(_keyCode) > -1) {
        // tab || esc
        hide();
      }
    };

    const menuItemsArray = ref(null);

    const handleItemKeyDown = ev => {
      const _keyCode = ev.keyCode;
      const _target = ev.target;

      const _currentIndex = menuItemsArray.value.indexOf(_target);

      const _max = menuItemsArray.value.length - 1;

      let _nextIndex;

      if ([38, 40].indexOf(_keyCode) > -1) {
        // up/down
        if (_keyCode === 38) {
          // up
          _nextIndex = _currentIndex !== 0 ? _currentIndex - 1 : 0;
        } else {
          // down
          _nextIndex = _currentIndex < _max ? _currentIndex + 1 : _max;
        }

        removeTabindex();
        resetTabindex(menuItems.value[_nextIndex]);

        menuItems.value[_nextIndex].focus();

        ev.preventDefault();
        ev.stopPropagation();
      } else if (_keyCode === 13) {
        // enter选中
        triggerElmFocus();

        _target.click();

        if (hideOnClick.value) {
          // click关闭
          visible.value = false;
        }
      } else if ([9, 27].indexOf(_keyCode) > -1) {
        // tab // esc
        hide();
        triggerElmFocus();
      }
    };

    const resetTabindex = ele => {
      // 下次tab时组件聚焦元素
      removeTabindex();
      ele.setAttribute('tabindex', '0'); // 下次期望的聚焦元素
    };

    const removeTabindex = () => {
      triggerElm.value.setAttribute('tabindex', '-1');
      menuItemsArray.value.forEach(item => {
        item.setAttribute('tabindex', '-1');
      });
    };

    const dropdownElm = ref(null);
    const listId = ref(`dropdown-menu-${generateId()}`);

    const initAria = () => {
      dropdownElm.value.setAttribute('id', listId.value);
      triggerElm.value.setAttribute('aria-haspopup', 'list');
      triggerElm.value.setAttribute('aria-controls', listId.value);

      if (!splitButton.value) {
        // 自定义
        triggerElm.value.setAttribute('role', 'button');
        triggerElm.value.setAttribute('tabindex', tabindex.value);
        triggerElm.value.setAttribute('class', (triggerElm.value.getAttribute('class') || '') + ' el-dropdown-selfdefine'); // 控制
      }
    };

    const focusing = ref(false);

    const initEvent = () => {
      triggerElm.value = splitButton.value ? instance.proxy.$refs.trigger.$el : instance.proxy.$el.children[0];
      triggerElm.value.addEventListener('keydown', handleTriggerKeyDown); // triggerElm keydown

      dropdownElm.value.addEventListener('keydown', handleItemKeyDown, true); // item keydown
      // 控制自定义元素的样式

      if (!splitButton.value) {
        triggerElm.value.addEventListener('focus', () => {
          focusing.value = true;
        });
        triggerElm.value.addEventListener('blur', () => {
          focusing.value = false;
        });
        triggerElm.value.addEventListener('click', () => {
          focusing.value = false;
        });
      }

      if (trigger.value === 'hover') {
        triggerElm.value.addEventListener('mouseenter', show);
        triggerElm.value.addEventListener('mouseleave', hide);
        dropdownElm.value.addEventListener('mouseenter', show);
        dropdownElm.value.addEventListener('mouseleave', hide);
      } else if (trigger.value === 'click') {
        triggerElm.value.addEventListener('click', handleClick);
      }
    };

    const handleMenuItemClick = (command, instance) => {
      if (hideOnClick.value) {
        visible.value = false;
      }

      emit('command', command, instance);
    };

    const triggerElmFocus = () => {
      triggerElm.value.focus && triggerElm.value.focus();
    };

    const initDomOperation = () => {
      dropdownElm.value = instance.proxy.popperElm;
      menuItems.value = dropdownElm.value.querySelectorAll("[tabindex='-1']");
      menuItemsArray.value = [].slice.call(menuItems.value);
      initEvent();
      initAria();
    };

    const {
      broadcast,
      on
    } = useEmitter();
    watch(visible, val => {
      broadcast('visible', val);
      emit('visible-change', val);
    });
    on('menu-item-click', handleMenuItemClick);
    watch(focusing, val => {
      const selfDefine = instance.proxy.$el.querySelector('.el-dropdown-selfdefine');

      if (selfDefine) {
        // 自定义
        if (val) {
          selfDefine.className += ' focusing';
        } else {
          selfDefine.className = selfDefine.className.replace('focusing', '');
        }
      }
    });
    instance.proxy.initDomOperation = initDomOperation;
    instance.proxy.dropdownSize = dropdownSize.value;
    instance.proxy.visible = visible.value;
    instance.proxy.broadcast = broadcast;
    provide('dropdown', instance);

    const handleMainButtonClick = event => {
      emit('click', event);
      hide();
    };

    return () => {
      const defaultNode = slots.default() ? slots.default()[0] : h('span');
      const dropdownNode = slots.default() ? slots.default()[1] : h('ul');
      const triggerElm = !splitButton.value ? defaultNode : createVNode(resolveComponent("el-button-group"), null, {
        default: () => [createVNode(resolveComponent("el-button"), {
          "type": type.value,
          "size": dropdownSize.value,
          "nativeOn-click": handleMainButtonClick
        }, {
          default: () => [defaultNode]
        }), createVNode(resolveComponent("el-button"), {
          "ref": "trigger",
          "type": type.value,
          "size": dropdownSize.value,
          "class": "el-dropdown__caret-button"
        }, {
          default: () => [createVNode("i", {
            "class": "el-dropdown__icon el-icon-arrow-down"
          }, null)]
        })]
      }); // fixme: directive api not work
      // const vClickoutside = resolveDirective('clickoutside')
      //
      // return withDirectives(
      //   h('div', { class: 'el-dropdown' }, [triggerElm, slots.dropdown]),
      //   [vClickoutside, hide]
      // )

      return h('div', {
        class: 'el-dropdown'
      }, [triggerElm, dropdownNode]);
    };
  }

};

script$1c.__file = "packages/dropdown/src/dropdown.vue";

/* istanbul ignore next */

script$1c.install = function (app) {
  app.component(script$1c.name, script$1c);
};

var script$1d = {
  name: 'ElDropdownItem',
  props: {
    command: {},
    disabled: Boolean,
    divided: Boolean,
    icon: String
  },

  setup(props) {
    const instance = getCurrentInstance();
    const {
      dispatch
    } = useEmitter();
    const {
      command
    } = toRefs(props);

    const handleClick = () => {
      dispatch('menu-item-click', command === null || command === void 0 ? void 0 : command.value, instance.proxy);
    };

    return {
      handleClick
    };
  }

};

function render$14(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("li", {
    class: ["el-dropdown-menu__item", {
      'is-disabled': $props.disabled,
      'el-dropdown-menu__item--divided': $props.divided
    }],
    onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleClick(...args))),
    "aria-disabled": $props.disabled,
    tabindex: $props.disabled ? null : -1
  }, [
    ($props.icon)
      ? (openBlock(), createBlock("i", {
          key: 0,
          class: $props.icon
        }, null, 2 /* CLASS */))
      : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default")
  ], 10 /* CLASS, PROPS */, ["aria-disabled", "tabindex"]))
}

script$1d.render = render$14;
script$1d.__file = "packages/dropdown/src/dropdown-item.vue";

/* istanbul ignore next */

script$1d.install = function (app) {
  app.component(script$1d.name, script$1d);
};

var script$1e = {
  name: 'ElDropdownMenu',
  componentName: 'ElDropdownMenu',
  props: { ...popperProps,
    visibleArrow: {
      type: Boolean,
      default: true
    },
    arrowOffset: {
      type: Number,
      default: 0
    }
  },
  emits: ['updatePopper', 'visible', 'update:modelValue', 'created'],

  setup(props, {
    emit,
    slots
  }) {
    const popperElm = ref(null);
    const referenceElm = ref(null);
    const {
      doDestroy,
      showPopper,
      currentPlacement,
      updatePopper
    } = usePopper(props, {
      emit,
      slots
    }, {
      popperElm,
      referenceElm
    });
    const dropdown = inject('dropdown');
    const size = dropdown.dropdownSize;
    const instance = getCurrentInstance();
    const {
      on
    } = useEmitter();
    on('updatePopper', () => {
      if (showPopper.value) updatePopper();
    });
    on('visible', val => {
      showPopper.value = val;
    });
    onMounted(() => {
      dropdown.popperElm = popperElm.value = instance.proxy.$el;
      referenceElm.value = dropdown.$el;
      nextTick(() => dropdown.initDomOperation());
    });
    watch(() => dropdown.placement, val => {
      currentPlacement.value = val;
    }, {
      immediate: true
    });
    watch(() => dropdown.visible.value, val => {
      showPopper.value = val;
    });
    return {
      showPopper,
      size,
      doDestroy
    };
  }

};

function render$15(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    name: "el-zoom-in-top",
    onAfterLeave: $setup.doDestroy
  }, {
    default: withCtx(() => [
      withDirectives(createVNode("ul", {
        class: ["el-dropdown-menu el-popper", [$setup.size && `el-dropdown-menu--${$setup.size}`]]
      }, [
        renderSlot(_ctx.$slots, "default")
      ], 2 /* CLASS */), [
        [vShow, $setup.showPopper]
      ])
    ]),
    _: 3
  }, 8 /* PROPS */, ["onAfterLeave"]))
}

script$1e.render = render$15;
script$1e.__file = "packages/dropdown/src/dropdown-menu.vue";

/* istanbul ignore next */

script$1e.install = function (app) {
  app.component(script$1e.name, script$1e);
};

/*
 * @Author: Mr Chang
 * @Date: 2020-08-30 13:09:21
 * @LastEditTime: 2020-09-02 11:17:04
 * @LastEditors: Mr Chang
 * @Description:
 * @FilePath: \element3\packages\steps\src\constants.js
 */
const stateSymbol = Symbol('state');
const propsSymbol = Symbol('props');

var script$1f = {
  name: 'ElSteps',
  props: {
    space: [Number, String],
    active: Number,
    direction: {
      type: String,
      default: 'horizontal'
    },
    alignCenter: Boolean,
    simple: Boolean,
    finishStatus: {
      type: String,
      default: 'finish'
    },
    processStatus: {
      type: String,
      default: 'process'
    }
  },
  emits: ['change'],

  setup(props, context) {
    const state = reactive({
      steps: [],
      stepOffset: 0
    });
    provide(stateSymbol, state);
    provide(propsSymbol, props);
    watch(() => props.active, (newVal, oldVal) => context.emit('change', newVal, oldVal));
    watch(() => state.steps, () => {
      state.steps.forEach((child, index) => {
        child.state.index = index;
      });
    }, {
      deep: true
    });
    return { ...toRefs(state)
    };
  }

};

function render$16(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-steps", [!$props.simple && 'el-steps--' + $props.direction, $props.simple && 'el-steps--simple']]
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2 /* CLASS */))
}

script$1f.render = render$16;
script$1f.__file = "packages/steps/src/steps.vue";

/* istanbul ignore next */

script$1f.install = function (app) {
  app.component(script$1f.name, script$1f);
};

var script$1g = {
  name: 'ElStep',
  props: {
    title: String,
    icon: String,
    description: String,
    status: String
  },

  setup(props) {
    const parentState = inject(stateSymbol);
    const steps = parentState.steps;
    const stepOffset = parentState.stepOffset;
    const parentProps = inject(propsSymbol);
    const isSimple = parentProps.simple;
    const isCenter = parentProps.alignCenter;
    const state = reactive({
      index: -1,
      lineStyle: {},
      internalStatus: ''
    });
    const currentStatus = computed(() => {
      return props.status || state.internalStatus;
    });
    const prevStatus = computed(() => {
      const prevStep = steps[state.index - 1];
      return prevStep ? prevStep.currentStatus : 'wait';
    });
    const isVertical = computed(() => {
      return parentProps.direction === 'vertical';
    });
    const isLast = computed(() => {
      return state.index === steps.length - 1;
    });
    const stepsCount = computed(() => {
      return steps.length;
    });
    const space = computed(() => {
      return isSimple ? '' : parentProps.space;
    });
    const style = computed(() => {
      const style = {};
      const len = steps.length;
      const newSpace = typeof space.value === 'number' ? space.value + 'px' : space.value ? space.value : 100 / (len - (isCenter ? 0 : 1)) + '%';
      style.flexBasis = newSpace;
      if (isVertical.value) return style;

      if (isLast.value) {
        style.maxWidth = 100 / stepsCount.value + '%';
      } else {
        style.marginRight = -stepOffset + 'px';
      }

      return style;
    });

    const updateStatus = val => {
      if (state.index < 0) return;
      const prevChild = steps[state.index - 1];

      if (val > state.index) {
        state.internalStatus = parentProps.finishStatus;
      } else if (val === state.index && prevStatus.value !== 'error') {
        state.internalStatus = parentProps.processStatus;
      } else {
        state.internalStatus = 'wait';
      }

      if (prevChild) prevChild.calcProgress(state.internalStatus);
    };

    const calcProgress = status => {
      let step = 100;
      const style = {};
      style.transitionDelay = 150 * state.index + 'ms';

      if (status === parentProps.processStatus) {
        step = state.currentStatus !== 'error' ? 0 : 0;
      } else if (status === 'wait') {
        step = 0;
        style.transitionDelay = -150 * state.index + 'ms';
      }

      style.borderWidth = step && !isSimple ? '1px' : 0;
      parentProps.direction === 'vertical' ? style.height = step + '%' : style.width = step + '%';
      state.lineStyle = style;
    };

    watch(() => state.index, () => {
      updateStatus(parentProps.active);
    }, {
      immediate: true
    });
    watch(() => parentProps.active, updateStatus, {
      immediate: true
    });
    watch(() => parentProps.processStatus, () => {
      updateStatus(parentProps.active);
    }, {
      immediate: true
    });
    const instance = {
      state,
      currentStatus,
      calcProgress,
      updateStatus
    };
    onBeforeMount(() => {
      steps.push(instance);
    });
    onBeforeUnmount(() => {
      const index = steps.indexOf(instance);

      if (index >= 0) {
        steps.splice(index, 1);
      }
    });
    return { ...toRefs(state),
      currentStatus,
      prevStatus,
      direction: parentProps.direction,
      isSimple,
      isLast,
      isCenter,
      isVertical,
      space,
      style,
      stepOffset
    };
  }

};

const _hoisted_1$J = {
  key: 1,
  class: "el-step__icon-inner"
};
const _hoisted_2$s = { class: "el-step__main" };
const _hoisted_3$k = {
  key: 0,
  class: "el-step__arrow"
};

function render$17(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    ref: "step",
    class: ["el-step", [
      !$setup.isSimple && `is-${$setup.direction}`,
      $setup.isSimple && 'is-simple',
      $setup.isLast && !$setup.space && !$setup.isCenter && 'is-flex',
      $setup.isCenter && !$setup.isVertical && !$setup.isSimple && 'is-center'
    ]],
    style: $setup.style
  }, [
    createCommentVNode(" icon & line "),
    createVNode("div", {
      class: ["el-step__head", `is-${$setup.currentStatus}`]
    }, [
      createVNode("div", {
        class: "el-step__line",
        style: $setup.isLast ? '' : { marginRight: $setup.stepOffset + 'px' }
      }, [
        createVNode("i", {
          class: "el-step__line-inner",
          style: _ctx.lineStyle
        }, null, 4 /* STYLE */)
      ], 4 /* STYLE */),
      createVNode("div", {
        class: ["el-step__icon", `is-${$props.icon ? 'icon' : 'text'}`]
      }, [
        ($setup.currentStatus !== 'success' && $setup.currentStatus !== 'error')
          ? renderSlot(_ctx.$slots, "icon", { key: 0 }, () => [
              ($props.icon)
                ? (openBlock(), createBlock("i", {
                    key: 0,
                    class: ["el-step__icon-inner", [$props.icon]]
                  }, null, 2 /* CLASS */))
                : createCommentVNode("v-if", true),
              (!$props.icon && !$setup.isSimple)
                ? (openBlock(), createBlock("div", _hoisted_1$J, toDisplayString(_ctx.index + 1), 1 /* TEXT */))
                : createCommentVNode("v-if", true)
            ])
          : (openBlock(), createBlock("i", {
              key: 1,
              class: [[
            'el-icon-' + ($setup.currentStatus === 'success' ? 'check' : 'close')
          ], "el-step__icon-inner is-status"]
            }, null, 2 /* CLASS */))
      ], 2 /* CLASS */)
    ], 2 /* CLASS */),
    createCommentVNode(" title & description "),
    createVNode("div", _hoisted_2$s, [
      createVNode("div", {
        class: ["el-step__title", ['is-' + $setup.currentStatus]],
        ref: "title"
      }, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString($props.title), 1 /* TEXT */)
        ])
      ], 2 /* CLASS */),
      ($setup.isSimple)
        ? (openBlock(), createBlock("div", _hoisted_3$k))
        : (openBlock(), createBlock("div", {
            key: 1,
            class: ["el-step__description", ['is-' + $setup.currentStatus]]
          }, [
            renderSlot(_ctx.$slots, "description", {}, () => [
              createTextVNode(toDisplayString($props.description), 1 /* TEXT */)
            ])
          ], 2 /* CLASS */))
    ])
  ], 6 /* CLASS, STYLE */))
}

script$1g.render = render$17;
script$1g.__file = "packages/steps/src/step.vue";

/* istanbul ignore next */

script$1g.install = function (app) {
  app.component(script$1g.name, script$1g);
};

var script$1h = {
  name: 'ElDialog',
  props: { ...popupProps,
    title: {
      type: String,
      default: ''
    },
    modal: {
      type: Boolean,
      default: true
    },
    modalAppendToBody: {
      type: Boolean,
      default: true
    },
    appendToBody: {
      type: Boolean,
      default: false
    },
    lockScroll: {
      type: Boolean,
      default: true
    },
    closeOnClickModal: {
      type: Boolean,
      default: true
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    width: String,
    fullscreen: Boolean,
    customClass: {
      type: String,
      default: ''
    },
    top: {
      type: String,
      default: '15vh'
    },
    beforeClose: Function,
    center: {
      type: Boolean,
      default: false
    },
    destroyOnClose: Boolean
  },
  emits: ['update:visible', 'close', 'opened', 'open', 'closed'],

  setup(props, {
    emit
  }) {
    const {
      visible,
      rendered,
      open
    } = usePopup(props);
    const {
      appendToBody,
      fullscreen,
      top,
      width,
      closeOnClickModal,
      destroyOnClose
    } = toRefs(props);
    const closed = ref(false);
    const key = ref(0);
    const dialog = ref(null);
    const instanc = getCurrentInstance();
    const {
      broadcast
    } = useEmitter();
    const style = computed(() => {
      const style = {};

      if (!(fullscreen && fullscreen.value)) {
        style.marginTop = top.value;

        if (width && width.value) {
          style.width = width.value;
        }
      }

      return style;
    });

    const handleWrapperClick = () => {
      if (!closeOnClickModal) return;
      handleClose();
    };

    const handleClose = () => {
      if (typeof props.beforeClose === 'function') {
        props.beforeClose(hide);
      } else {
        hide();
      }
    };

    const hide = cancel => {
      if (cancel !== false) {
        emit('update:visible', false);
        emit('close');
        closed.value = true;
      }
    };

    const updatePopper = () => {
      broadcast('updatePopper');
      broadcast('updatePopper');
    };

    const afterEnter = () => {
      emit('opened');
    };

    const afterLeave = () => {
      emit('closed');
    };

    watch(visible, val => {
      const el = instanc.ctx.$el;

      if (val) {
        closed.value = false;
        emit('open');
        el.addEventListener('scroll', updatePopper);
        nextTick(() => {
          dialog.value.scrollTop = 0;
        });

        if (appendToBody.value) {
          document.body.appendChild(el);
        }
      } else {
        el.removeEventListener('scroll', updatePopper);
        if (!closed.value) emit('close');

        if (destroyOnClose && destroyOnClose.value) {
          nextTick(() => {
            key.value++;
          });
        }
      }
    });
    onMounted(() => {
      if (visible.value) {
        rendered.value = true;
        open();

        if (appendToBody.value) {
          document.body.appendChild(instanc.ctx.$el);
        }
      }
    });
    onUnmounted(() => {
      const el = instanc.ctx.$el;

      if (appendToBody.value && el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    });
    return {
      dialog,
      key,
      rendered,
      handleClose,
      style,
      handleWrapperClick,
      afterEnter,
      afterLeave
    };
  }

};

const _hoisted_1$K = { class: "el-dialog__header" };
const _hoisted_2$t = { class: "el-dialog__title" };
const _hoisted_3$l = /*#__PURE__*/createVNode("i", { class: "el-dialog__close el-icon el-icon-close" }, null, -1 /* HOISTED */);
const _hoisted_4$c = {
  key: 0,
  class: "el-dialog__body"
};
const _hoisted_5$a = {
  key: 1,
  class: "el-dialog__footer"
};

function render$18(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    name: "dialog-fade",
    onAfterEnter: $setup.afterEnter,
    onAfterLeave: $setup.afterLeave
  }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        class: "el-dialog__wrapper",
        onClick: _cache[2] || (_cache[2] = withModifiers((...args) => ($setup.handleWrapperClick(...args)), ["self"]))
      }, [
        (openBlock(), createBlock("div", {
          role: "dialog",
          key: $setup.key,
          "aria-modal": "true",
          "aria-label": $props.title || 'dialog',
          class: [
          'el-dialog',
          { 'is-fullscreen': $props.fullscreen, 'el-dialog--center': $props.center },
          $props.customClass
        ],
          ref: "dialog",
          style: $setup.style
        }, [
          createVNode("div", _hoisted_1$K, [
            renderSlot(_ctx.$slots, "title", {}, () => [
              createVNode("span", _hoisted_2$t, toDisplayString($props.title), 1 /* TEXT */)
            ]),
            ($props.showClose)
              ? (openBlock(), createBlock("button", {
                  key: 0,
                  type: "button",
                  class: "el-dialog__headerbtn",
                  "aria-label": "Close",
                  onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleClose(...args)))
                }, [
                  _hoisted_3$l
                ]))
              : createCommentVNode("v-if", true)
          ]),
          ($setup.rendered)
            ? (openBlock(), createBlock("div", _hoisted_4$c, [
                renderSlot(_ctx.$slots, "default")
              ]))
            : createCommentVNode("v-if", true),
          (_ctx.$slots.footer)
            ? (openBlock(), createBlock("div", _hoisted_5$a, [
                renderSlot(_ctx.$slots, "footer")
              ]))
            : createCommentVNode("v-if", true)
        ], 14 /* CLASS, STYLE, PROPS */, ["aria-label"]))
      ], 512 /* NEED_PATCH */), [
        [vShow, _ctx.visible]
      ])
    ]),
    _: 3
  }, 8 /* PROPS */, ["onAfterEnter", "onAfterLeave"]))
}

script$1h.render = render$18;
script$1h.__file = "packages/dialog/Dialog.vue";

/* istanbul ignore next */

script$1h.install = function (app) {
  app.component(script$1h.name, script$1h);
};

/* fixme: deactivated暂时不知道映射哪钩子，没有加 */
var script$1i = {
  name: 'ElPopover',
  props: { ...vuePopperProps,
    trigger: {
      type: String,
      default: 'click',
      validator: value => ['click', 'focus', 'hover', 'manual'].indexOf(value) > -1
    },
    openDelay: {
      type: Number,
      default: 0
    },
    closeDelay: {
      type: Number,
      default: 200
    },
    title: String,
    disabled: Boolean,
    content: String,
    reference: {},
    popperClass: String,
    width: {},
    visibleArrow: {
      default: true
    },
    arrowOffset: {
      type: Number,
      default: 0
    },
    transition: {
      type: String,
      default: 'fade-in-linear'
    },
    tabindex: {
      type: Number,
      default: 0
    }
  },
  emits: ['created', 'show', 'hide', 'after-enter', 'after-leave', 'update:modelValue'],

  setup(props, {
    emit,
    slots
  }) {
    const {
      disabled,
      trigger,
      reference,
      popper,
      tabindex
    } = toRefs(props);
    const instance = getCurrentInstance();
    const referenceEl = ref(null);
    const {
      showPopper,
      destroyPopper
    } = useVuePopper(props, {
      instance,
      emit,
      slots,
      referenceEl
    });
    const tooltipId = computed(() => `el-popover-${generateId()}`);
    watch(showPopper, val => {
      if (disabled.value) return;
      val ? emit('show') : emit('hide');
    });
    const {
      doToggle,
      doShow,
      doClose,
      handleFocus,
      handleClick,
      handleBlur,
      handleMouseEnter,
      handleKeydown,
      handleMouseLeave,
      handleDocumentClick,
      handleAfterEnter,
      handleAfterLeave,
      cleanup
    } = useInteractive$1({
      instance,
      emit,
      slots,
      referenceEl,
      showPopper,
      destroyPopper,
      ...toRefs(props)
    });
    onMounted(() => {
      referenceEl.value = reference && reference.value || instance.proxy.$refs.reference;
      const popperRef = popper && popper.value || instance.proxy.$refs.popper;

      if (!referenceEl.value && slots.reference && slots.reference()) {
        referenceEl.value = slots.reference()[0].el;
      } // 可访问性


      if (referenceEl.value) {
        addClass(referenceEl.value, 'el-popover__reference');
        referenceEl.value.setAttribute('aria-describedby', tooltipId.value);
        referenceEl.value.setAttribute('tabindex', tabindex.value); // tab序列

        popperRef.setAttribute('tabindex', 0);

        if (trigger.value !== 'click') {
          on(referenceEl.value, 'focusin', () => {
            handleFocus();
            const instanceRef = referenceEl.value.__vue__;

            if (instanceRef && typeof instanceRef.focus === 'function') {
              instanceRef.focus();
            }
          });
          on(popperRef, 'focusin', handleFocus);
          on(referenceEl.value, 'focusout', handleBlur);
          on(popperRef, 'focusout', handleBlur);
        }

        on(referenceEl.value, 'keydown', handleKeydown);
        on(referenceEl.value, 'click', handleClick);
      }

      if (trigger.value === 'click') {
        on(referenceEl.value, 'click', doToggle);
        on(document, 'click', handleDocumentClick);
      } else if (trigger.value === 'hover') {
        on(referenceEl.value, 'mouseenter', handleMouseEnter);
        on(popperRef, 'mouseenter', handleMouseEnter);
        on(referenceEl.value, 'mouseleave', handleMouseLeave);
        on(popperRef, 'mouseleave', handleMouseLeave);
      } else if (trigger.value === 'focus') {
        if (tabindex < 0) {
          console.warn('[Element Warn][Popover]a negative taindex means that the element cannot be focused by tab key');
        }

        if (referenceEl.value.querySelector('input, textarea')) {
          on(referenceEl.value, 'focusin', doShow);
          on(referenceEl.value, 'focusout', doClose);
        } else {
          on(referenceEl.value, 'mousedown', doShow);
          on(referenceEl.value, 'mouseup', doClose);
        }
      }
    });
    onBeforeUnmount(() => {
      cleanup();
    });
    onUnmounted(() => {
      off(referenceEl.value, 'click', doToggle);
      off(referenceEl.value, 'mouseup', doClose);
      off(referenceEl.value, 'mousedown', doShow);
      off(referenceEl.value, 'focusin', doShow);
      off(referenceEl.value, 'focusout', doClose);
      off(referenceEl.value, 'mousedown', doShow);
      off(referenceEl.value, 'mouseup', doClose);
      off(referenceEl.value, 'mouseleave', handleMouseLeave);
      off(referenceEl.value, 'mouseenter', handleMouseEnter);
      off(document, 'click', handleDocumentClick);
    }); // deactivated(() => {
    //   cleanup()
    // })

    return {
      showPopper,
      doToggle,
      doShow,
      doClose,
      handleFocus,
      handleClick,
      handleBlur,
      handleMouseEnter,
      handleKeydown,
      handleMouseLeave,
      handleDocumentClick,
      handleAfterEnter,
      handleAfterLeave,
      tooltipId,
      cleanup
    };
  }

};

function useInteractive$1({
  instance,
  showPopper,
  referenceEl,
  trigger,
  popper,
  slots,
  emit,
  destroyPopper,
  openDelay,
  closeDelay,
  reference
}) {
  function doToggle() {
    showPopper.value = !showPopper.value;
  }

  function doShow() {
    showPopper.value = true;
  }

  function doClose() {
    showPopper.value = false;
  }

  function handleFocus() {
    addClass(referenceEl.value, 'focusing');
    if (trigger.value === 'click' || trigger.value === 'focus') showPopper.value = true;
  }

  function handleClick() {
    removeClass(referenceEl.value, 'focusing');
  }

  function handleBlur() {
    removeClass(referenceEl.value, 'focusing');
    if (trigger.value === 'click' || trigger.value === 'focus') showPopper.value = false;
  }

  let _timer = null;

  function handleMouseEnter() {
    clearTimeout(_timer);

    if (openDelay.value) {
      _timer = setTimeout(() => {
        showPopper.value = true;
      }, openDelay.value);
    } else {
      showPopper.value = true;
    }
  }

  function handleKeydown(ev) {
    if (ev.keyCode === 27 && trigger.value !== 'manual') {
      doClose();
    }
  }

  function handleMouseLeave() {
    clearTimeout(_timer);

    if (closeDelay.value) {
      _timer = setTimeout(() => {
        showPopper.value = false;
      }, closeDelay.value);
    } else {
      showPopper.value = false;
    }
  }

  function handleDocumentClick(e) {
    let referenceRef = reference && reference.value || instance.proxy.$refs.reference;
    const popperRef = popper && popper.value || instance.proxy.$refs.popper;
    const $el = instance.proxy.$el;

    if (!referenceRef && slots.reference && slots.reference() && slots.reference()[0]) {
      referenceRef = referenceEl = slots.reference()[0].el;
    }
    /* fixme: 在eleui官网调试是如下的判定条件 */


    if ($el && referenceRef && !$el.contains(e.target) && !referenceRef.contains(e.target) && popperRef && !popperRef.contains(e.target)) return showPopper.value = false;
  }

  function handleAfterEnter() {
    nextTick(() => emit('after-enter'));
  }

  function handleAfterLeave() {
    nextTick(() => {
      emit('after-leave');
      destroyPopper();
    });
  }

  function cleanup() {
    if (openDelay.value || closeDelay.value) {
      clearTimeout(_timer);
    }
  }

  return {
    doToggle,
    doShow,
    doClose,
    handleFocus,
    handleClick,
    handleBlur,
    handleMouseEnter,
    handleKeydown,
    handleMouseLeave,
    handleDocumentClick,
    handleAfterEnter,
    handleAfterLeave,
    cleanup
  };
}

const _hoisted_1$L = { ref: "reference" };

function render$19(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("span", null, [
    createVNode(Transition, {
      name: $props.transition,
      onAfterEnter: $setup.handleAfterEnter,
      onAfterLeave: $setup.handleAfterLeave
    }, {
      default: withCtx(() => [
        withDirectives(createVNode("div", {
          class: ["el-popover el-popper", [$props.popperClass, $props.content && 'el-popover--plain']],
          ref: "popper",
          style: { width: $props.width + 'px' },
          role: "tooltip",
          id: $setup.tooltipId,
          "aria-hidden": $props.disabled || !$setup.showPopper ? 'true' : 'false'
        }, [
          ($props.title)
            ? (openBlock(), createBlock("div", {
                key: 0,
                class: "el-popover__title",
                textContent: toDisplayString($props.title)
              }, null, 8 /* PROPS */, ["textContent"]))
            : createCommentVNode("v-if", true),
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString($props.content), 1 /* TEXT */)
          ])
        ], 14 /* CLASS, STYLE, PROPS */, ["id", "aria-hidden"]), [
          [vShow, !$props.disabled && $setup.showPopper]
        ])
      ]),
      _: 3
    }, 8 /* PROPS */, ["name", "onAfterEnter", "onAfterLeave"]),
    createVNode("span", _hoisted_1$L, [
      renderSlot(_ctx.$slots, "reference")
    ], 512 /* NEED_PATCH */)
  ]))
}

script$1i.render = render$19;
script$1i.__file = "packages/popover/Popover.vue";

const getReference = (el, binding, vnode) => {
  const _ref = binding.expression ? binding.value : binding.arg;

  const popper = vnode.context.$refs[_ref];

  if (popper) {
    if (Array.isArray(popper)) {
      popper[0].$refs.reference = el;
    } else {
      popper.$refs.reference = el;
    }
  }
};
/* directive 暂时测试不通过，待修复，目前调试看起来是directive没有正确的执行挂载导致的 */


var directive$1 = {
  beforeMount(el, binding, vnode) {
    console.log(el, binding);
    getReference(el, binding, vnode);
  },

  mounted(el, binding, vnode) {
    getReference(el, binding, vnode);
  }

};

/* istanbul ignore next */

script$1i.install = function (app) {
  app.directive('popover', directive$1);
  app.component(script$1i.name, script$1i);
};

var script$1j = {
  name: 'ElPopconfirm',
  props: {
    title: {
      type: String
    },
    confirmButtonText: {
      type: String,
      default: t('el.popconfirm.confirmButtonText')
    },
    cancelButtonText: {
      type: String,
      default: t('el.popconfirm.cancelButtonText')
    },
    confirmButtonType: {
      type: String,
      default: 'primary'
    },
    cancelButtonType: {
      type: String,
      default: 'text'
    },
    icon: {
      type: String,
      default: 'el-icon-question'
    },
    iconColor: {
      type: String,
      default: '#f90'
    },
    hideIcon: {
      type: Boolean,
      default: false
    }
  },
  components: {
    ElPopover: script$1i,
    ElButton: script$7
  },
  emits: ['onConfirm', 'onCancel'],

  setup(props, {
    emit
  }) {
    const state = reactive({
      visible: false
    });

    const confirm = () => {
      state.visible = false; // TODO 如果把 onConfirm 修改成 on-confirm 的话就涉及到 api 的变更了
      // 不过在发版之前可以讨论一波
      // eslint-disable-next-line vue/custom-event-name-casing

      emit('onConfirm');
    };

    const cancel = () => {
      state.visible = false; // eslint-disable-next-line vue/custom-event-name-casing

      emit('onCancel');
    };

    return { ...toRefs(state),
      confirm,
      cancel
    };
  }

};

const _hoisted_1$M = { class: "el-popconfirm" };
const _hoisted_2$u = { class: "el-popconfirm__main" };
const _hoisted_3$m = { class: "el-popconfirm__action" };

function render$1a(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_el_popover = resolveComponent("el-popover");

  return (openBlock(), createBlock(_component_el_popover, mergeProps(_ctx.$attrs, {
    modelValue: _ctx.visible,
    "onUpdate:modelValue": _cache[1] || (_cache[1] = $event => (_ctx.visible = $event)),
    trigger: "click"
  }), {
    reference: withCtx(() => [
      renderSlot(_ctx.$slots, "reference")
    ]),
    default: withCtx(() => [
      createVNode("div", _hoisted_1$M, [
        createVNode("p", _hoisted_2$u, [
          (!$props.hideIcon)
            ? (openBlock(), createBlock("i", {
                key: 0,
                class: [$props.icon, "el-popconfirm__icon"],
                style: { color: $props.iconColor }
              }, null, 6 /* CLASS, STYLE */))
            : createCommentVNode("v-if", true),
          createTextVNode(" " + toDisplayString($props.title), 1 /* TEXT */)
        ]),
        createVNode("div", _hoisted_3$m, [
          createVNode(_component_el_button, {
            size: "mini",
            type: $props.cancelButtonType,
            onClick: $setup.cancel
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($props.cancelButtonText), 1 /* TEXT */)
            ]),
            _: 1
          }, 8 /* PROPS */, ["type", "onClick"]),
          createVNode(_component_el_button, {
            size: "mini",
            type: $props.confirmButtonType,
            onClick: $setup.confirm
          }, {
            default: withCtx(() => [
              createTextVNode(toDisplayString($props.confirmButtonText), 1 /* TEXT */)
            ]),
            _: 1
          }, 8 /* PROPS */, ["type", "onClick"])
        ])
      ])
    ]),
    _: 1
  }, 16 /* FULL_PROPS */, ["modelValue"]))
}

script$1j.render = render$1a;
script$1j.__file = "packages/popconfirm/Popconfirm.vue";

/* istanbul ignore next */

script$1j.install = function (app) {
  app.component(script$1j.name, script$1j);
};

var script$1k = {
  name: 'ElCard',
  props: {
    header: {},
    bodyStyle: {},
    shadow: {
      type: String,
      default: 'always'
    }
  }
};

const _hoisted_1$N = {
  key: 0,
  class: "el-card__header"
};

function render$1b(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: ["el-card", 'is-' + $props.shadow + '-shadow']
  }, [
    (_ctx.$slots.header || $props.header)
      ? (openBlock(), createBlock("div", _hoisted_1$N, [
          renderSlot(_ctx.$slots, "header", {}, () => [
            createTextVNode(toDisplayString($props.header), 1 /* TEXT */)
          ])
        ]))
      : createCommentVNode("v-if", true),
    createVNode("div", {
      class: "el-card__body",
      style: $props.bodyStyle
    }, [
      renderSlot(_ctx.$slots, "default")
    ], 4 /* STYLE */)
  ], 2 /* CLASS */))
}

script$1k.render = render$1b;
script$1k.__file = "packages/card/Card.vue";

/* istanbul ignore next */

script$1k.install = function (app) {
  app.component(script$1k.name, script$1k);
};

var script$1l = {
  name: 'ElCarousel',
  props: {
    initialIndex: {
      type: Number,
      default: 0
    },
    height: String,
    trigger: {
      type: String,
      default: 'hover'
    },
    autoplay: {
      type: Boolean,
      default: true
    },
    interval: {
      type: Number,
      default: 3000
    },
    indicatorPosition: String,
    indicator: {
      type: Boolean,
      default: true
    },
    arrow: {
      type: String,
      default: 'hover'
    },
    type: String,
    loop: {
      type: Boolean,
      default: true
    },
    direction: {
      type: String,
      default: 'horizontal',

      validator(val) {
        return ['horizontal', 'vertical'].indexOf(val) !== -1;
      }

    }
  },
  emits: ['change'],

  setup(props, {
    emit
  }) {
    // 初始化状态
    const initData = reactive({
      items: [],
      activeIndex: -1,
      containerWidth: 0,
      timer: null,
      hover: false
    }); // 封装ArrowButton逻辑

    const {
      loop,
      arrowDisplay,
      handleButtonEnter,
      handleButtonLeave,
      throttledArrowClick,
      setActiveItem,
      resetItemPosition
    } = useArrowButton(props, initData); // 封装Indicator逻辑

    const {
      hasLabel,
      indicatorsClasses,
      throttledIndicatorHover,
      handleIndicatorClick
    } = useIndicator(props, initData); // 初始化Slide

    const {
      carouselClasses,
      handleMouseEnter,
      handleMouseLeave,
      startTimer
    } = useInitSlide(props, initData, loop);

    const updateItems = ElCarouselItem => {
      initData.items.push(ElCarouselItem);
    };

    const {
      addResizeListener,
      removeResizeListener
    } = useResizeEvent();
    onMounted(() => {
      nextTick(() => {
        addResizeListener(resetItemPosition);

        if (props.initialIndex < initData.items.length && props.initialIndex >= 0) {
          initData.activeIndex = props.initialIndex;
        }

        startTimer();
      });
    });
    onUnmounted(() => {
      removeResizeListener(resetItemPosition);
    });
    watch(() => initData.items, val => {
      if (val.length > 0) setActiveItem(props.initialIndex);
    });
    watch(() => initData.activeIndex, (val, oldVal) => {
      resetItemPosition(oldVal);

      if (oldVal > -1) {
        emit('change', val, oldVal);
      }
    }); // 暴露方法

    const prev = () => {
      setActiveItem(initData.activeIndex - 1);
    };

    const next = () => {
      setActiveItem(initData.activeIndex + 1);
    }; // 取出视图所需参数


    const {
      items,
      activeIndex,
      hover
    } = toRefs(initData);
    /**
     * 向CarouselItem提供属性及方法
     */
    // 通过computed将props中的direction字符串变成响应式

    const computedDirection = computed(() => {
      return props.direction;
    });
    const computedType = computed(() => {
      return props.type;
    });
    const computedItems = computed(() => {
      return initData.items;
    });
    const computedItemLength = computed(() => {
      return initData.items.length;
    });
    const computedLoop = computed(() => {
      return props.loop;
    }); // 只提供计算出来的值，不允许子组件借此改变数据流向

    provide('direction', computedDirection);
    provide('type', computedType);
    provide('items', computedItems);
    provide('itemLength', computedItemLength);
    provide('loop', computedLoop); // 提供改变状态的方法

    provide('updateItems', updateItems);
    provide('setActiveItem', setActiveItem);
    return {
      items,
      activeIndex,
      hover,
      arrowDisplay,
      handleButtonEnter,
      handleButtonLeave,
      throttledArrowClick,
      hasLabel,
      indicatorsClasses,
      throttledIndicatorHover,
      handleIndicatorClick,
      carouselClasses,
      handleMouseEnter,
      handleMouseLeave,
      prev,
      next,
      setActiveItem
    };
  }

};

const useArrowButton = (props, initData) => {
  const loop = ref(props.loop);

  const itemInStage = (item, index) => {
    const length = initData.items.length;

    if (index === length - 1 && item.ctx.inStage && initData.items[0].active || item.ctx.inStage && initData.items[index + 1] && initData.items[index + 1].active) {
      return 'left';
    } else if (index === 0 && item.ctx.inStage && initData.items[length - 1].active || item.ctx.inStage && initData.items[index - 1] && initData.items[index - 1].active) {
      return 'right';
    }

    return false;
  };

  const resetItemPosition = oldIndex => {
    initData.items.forEach((item, index) => {
      item.ctx.translateItem(index, initData.activeIndex, oldIndex);
    });
  };

  const setActiveItem = index => {
    if (typeof index === 'string') {
      const filteredItems = initData.items.filter(item => item.ctx.name === index);

      if (filteredItems.length > 0) {
        index = initData.items.indexOf(filteredItems[0]);
      }
    }

    index = Number(index);

    if (isNaN(index) || index !== Math.floor(index)) {
      console.warn('[Element Warn][Carousel]index must be an integer.');
      return;
    }

    const length = initData.items.length;
    const oldIndex = initData.activeIndex;

    if (index < 0) {
      initData.activeIndex = loop.value ? length - 1 : 0;
    } else if (index >= length) {
      initData.activeIndex = loop.value ? 0 : length - 1;
    } else {
      initData.activeIndex = index;
    }

    if (oldIndex === initData.activeIndex) {
      resetItemPosition(oldIndex);
    }
  };

  const throttledArrowClick = throttle$1(300, true, index => {
    setActiveItem(index);
  });

  const handleButtonEnter = arrow => {
    if (props.direction === 'vertical') return;
    initData.items.forEach((item, index) => {
      if (arrow === itemInStage(item, index)) {
        item.ctx.hover = true;
      }
    });
  };

  const handleButtonLeave = () => {
    if (props.direction === 'vertical') return;
    initData.items.forEach(item => {
      item.ctx.hover = false;
    });
  };

  const arrowDisplay = computed(() => {
    return props.arrow !== 'never' && props.direction !== 'vertical';
  });
  watch(loop, () => {
    setActiveItem(initData.activeIndex);
  });
  return {
    loop,
    arrowDisplay,
    handleButtonEnter,
    handleButtonLeave,
    throttledArrowClick,
    setActiveItem,
    resetItemPosition
  };
};

const useIndicator = (props, initData) => {
  const handleIndicatorHover = index => {
    if (props.trigger === 'hover' && index !== initData.activeIndex) {
      initData.activeIndex = index;
    }
  };

  const throttledIndicatorHover = throttle$1(300, index => {
    handleIndicatorHover(index);
  });

  const handleIndicatorClick = index => {
    initData.activeIndex = index;
  };

  const hasLabel = computed(() => {
    return initData.items.some(item => item.ctx.label.toString().length > 0);
  });
  const indicatorsClasses = computed(() => {
    const classes = ['el-carousel__indicators', 'el-carousel__indicators--' + props.direction];

    if (hasLabel.value) {
      classes.push('el-carousel__indicators--labels');
    }

    if (props.indicatorPosition === 'outside' || props.type === 'card') {
      classes.push('el-carousel__indicators--outside');
    }

    return classes;
  });
  return {
    throttledIndicatorHover,
    handleIndicatorClick,
    hasLabel,
    indicatorsClasses
  };
};

const useInitSlide = (props, initData, loop) => {
  const autoplay = ref(props.autoplay);

  const playSlides = () => {
    if (initData.activeIndex < initData.items.length - 1) {
      initData.activeIndex++;
    } else if (loop.value) {
      initData.activeIndex = 0;
    }
  };

  const startTimer = () => {
    if (props.interval <= 0 || !autoplay.value || initData.timer) return;
    initData.timer = setInterval(playSlides, props.interval);
  };

  const pauseTimer = () => {
    if (initData.timer) {
      clearInterval(initData.timer);
      initData.timer = null;
    }
  };

  const handleMouseEnter = () => {
    initData.hover = true;
    pauseTimer();
  };

  const handleMouseLeave = () => {
    initData.hover = false;
    startTimer();
  };

  const carouselClasses = computed(() => {
    const classes = ['el-carousel', 'el-carousel--' + props.direction];

    if (initData.type === 'card') {
      classes.push('el-carousel--card');
    }

    return classes;
  });
  watch(autoplay, val => {
    val ? startTimer() : pauseTimer();
  });
  return {
    carouselClasses,
    playSlides,
    startTimer,
    handleMouseEnter,
    handleMouseLeave
  };
};

const _hoisted_1$O = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-left" }, null, -1 /* HOISTED */);
const _hoisted_2$v = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-right" }, null, -1 /* HOISTED */);
const _hoisted_3$n = { class: "el-carousel__button" };
const _hoisted_4$d = { key: 0 };

function render$1c(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", {
    class: $setup.carouselClasses,
    onMouseenter: _cache[7] || (_cache[7] = withModifiers((...args) => ($setup.handleMouseEnter(...args)), ["stop"])),
    onMouseleave: _cache[8] || (_cache[8] = withModifiers((...args) => ($setup.handleMouseLeave(...args)), ["stop"]))
  }, [
    createVNode("div", {
      class: "el-carousel__container",
      style: { height: $props.height }
    }, [
      ($setup.arrowDisplay)
        ? (openBlock(), createBlock(Transition, {
            key: 0,
            name: "carousel-arrow-left"
          }, {
            default: withCtx(() => [
              withDirectives(createVNode("button", {
                type: "button",
                onMouseenter: _cache[1] || (_cache[1] = $event => ($setup.handleButtonEnter('left'))),
                onMouseleave: _cache[2] || (_cache[2] = (...args) => ($setup.handleButtonLeave(...args))),
                onClick: _cache[3] || (_cache[3] = withModifiers($event => ($setup.throttledArrowClick($setup.activeIndex - 1)), ["stop"])),
                class: "el-carousel__arrow el-carousel__arrow--left"
              }, [
                _hoisted_1$O
              ], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                [vShow, ($props.arrow === 'always' || $setup.hover) && ($props.loop || $setup.activeIndex > 0)]
              ])
            ]),
            _: 1
          }))
        : createCommentVNode("v-if", true),
      ($setup.arrowDisplay)
        ? (openBlock(), createBlock(Transition, {
            key: 1,
            name: "carousel-arrow-right"
          }, {
            default: withCtx(() => [
              withDirectives(createVNode("button", {
                type: "button",
                onMouseenter: _cache[4] || (_cache[4] = $event => ($setup.handleButtonEnter('right'))),
                onMouseleave: _cache[5] || (_cache[5] = (...args) => ($setup.handleButtonLeave(...args))),
                onClick: _cache[6] || (_cache[6] = withModifiers($event => ($setup.throttledArrowClick($setup.activeIndex + 1)), ["stop"])),
                class: "el-carousel__arrow el-carousel__arrow--right"
              }, [
                _hoisted_2$v
              ], 544 /* HYDRATE_EVENTS, NEED_PATCH */), [
                [vShow, 
            ($props.arrow === 'always' || $setup.hover) &&
            ($props.loop || $setup.activeIndex < $setup.items.length - 1)
          ]
              ])
            ]),
            _: 1
          }))
        : createCommentVNode("v-if", true),
      renderSlot(_ctx.$slots, "default")
    ], 4 /* STYLE */),
    ($props.indicatorPosition !== 'none')
      ? (openBlock(), createBlock("ul", {
          key: 0,
          class: $setup.indicatorsClasses
        }, [
          (openBlock(true), createBlock(Fragment, null, renderList($setup.items, (item, index) => {
            return (openBlock(), createBlock("li", {
              key: index,
              class: [
          'el-carousel__indicator',
          'el-carousel__indicator--' + $props.direction,
          { 'is-active': index === $setup.activeIndex }
        ],
              onMouseenter: $event => ($setup.throttledIndicatorHover(index)),
              onClick: withModifiers($event => ($setup.handleIndicatorClick(index)), ["stop"])
            }, [
              createVNode("button", _hoisted_3$n, [
                ($setup.hasLabel)
                  ? (openBlock(), createBlock("span", _hoisted_4$d, toDisplayString(item.ctx.label), 1 /* TEXT */))
                  : createCommentVNode("v-if", true)
              ])
            ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["onMouseenter", "onClick"]))
          }), 128 /* KEYED_FRAGMENT */))
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true)
  ], 34 /* CLASS, HYDRATE_EVENTS */))
}

script$1l.render = render$1c;
script$1l.__file = "packages/carousel/Carousel.vue";

/* istanbul ignore next */

script$1l.install = function (app) {
  app.component(script$1l.name, script$1l);
};

const CARD_SCALE = 0.83;
var script$1m = {
  name: 'ElCarouselItem',
  props: {
    name: String,
    label: {
      type: [String, Number],
      default: ''
    }
  },

  setup() {
    const parentUpdateItems = inject('updateItems');

    const _this = getCurrentInstance(); // 更新父组件中的items


    onMounted(() => {
      parentUpdateItems(_this);
    }); // 初始化data

    const initData = reactive({
      hover: false,
      translate: 0,
      scale: 1,
      active: false,
      ready: false,
      inStage: false,
      animating: false
    });
    const {
      ready,
      active,
      inStage,
      hover,
      animating
    } = toRefs(initData);
    const parentType = inject('type'); // 处理translateItem，将方法返回到ctx中供父组件调用

    const {
      parentDirection,
      translateItem
    } = useTranslateItem(_this, initData, parentType); // 处理cardItemClick

    const {
      handleItemClick
    } = useCardItemClick(_this, parentType); // 处理样式

    const itemStyle = computed(() => {
      const translateType = parentDirection.value === 'vertical' ? 'translateY' : 'translateX';
      const value = `${translateType}(${initData.translate}px) scale(${initData.scale})`;
      const style = {
        transform: value
      };
      return autoprefixer(style);
    }); // destoryed的时候更新父组件items

    onUnmounted(() => {
      parentUpdateItems();
    });
    return {
      ready,
      active,
      inStage,
      hover,
      animating,
      itemStyle,
      handleItemClick,
      translateItem,
      parentType
    };
  }

};

const useTranslateItem = (_this, initData, parentType) => {
  const parentItemLength = inject('itemLength');
  const parentDirection = inject('direction');
  const parentLoop = inject('loop');

  const processIndex = (index, activeIndex, length) => {
    if (activeIndex === 0 && index === length - 1) {
      return -1;
    } else if (activeIndex === length - 1 && index === 0) {
      return length;
    } else if (index < activeIndex - 1 && activeIndex - index >= length / 2) {
      return length + 1;
    } else if (index > activeIndex + 1 && index - activeIndex >= length / 2) {
      return -2;
    }

    return index;
  };

  const calcCardTranslate = (index, activeIndex) => {
    const parentWidth = _this.parent.vnode.el.offsetWidth;

    if (initData.inStage) {
      return parentWidth * ((2 - CARD_SCALE) * (index - activeIndex) + 1) / 4;
    } else if (index < activeIndex) {
      return -(1 + CARD_SCALE) * parentWidth / 4;
    } else {
      return (3 + CARD_SCALE) * parentWidth / 4;
    }
  };

  const calcTranslate = (index, activeIndex, isVertical) => {
    const distance = _this.parent.vnode.el[isVertical ? 'offsetHeight' : 'offsetWidth'];
    return distance * (index - activeIndex);
  };

  const translateItem = (index, activeIndex, oldIndex) => {
    const length = parentItemLength.value;

    if (parentType.value !== 'card' && oldIndex !== undefined) {
      initData.animating = index === activeIndex || index === oldIndex;
    }

    if (index !== activeIndex && length > 2 && parentLoop.value) {
      index = processIndex(index, activeIndex, length);
    }

    if (parentType.value === 'card') {
      if (parentDirection.value === 'vertical') {
        console.warn('[Element Warn][Carousel]vertical direction is not supported in card mode');
      }

      initData.inStage = Math.round(Math.abs(index - activeIndex)) <= 1;
      initData.active = index === activeIndex;
      initData.translate = calcCardTranslate(index, activeIndex);
      initData.scale = initData.active ? 1 : CARD_SCALE;
    } else {
      initData.active = index === activeIndex;
      const isVertical = parentDirection.value === 'vertical';
      initData.translate = calcTranslate(index, activeIndex, isVertical);
    }

    initData.ready = true;
  };

  return {
    parentDirection,
    translateItem
  };
};

const useCardItemClick = (_this, parentType) => {
  const parentItems = inject('items');
  const setActiveItem = inject('setActiveItem');

  const handleItemClick = () => {
    if (parentType.value === 'card') {
      const index = parentItems.value.indexOf(_this);
      setActiveItem(index);
    }
  };

  return {
    handleItemClick
  };
};

const _hoisted_1$P = {
  key: 0,
  class: "el-carousel__mask"
};

function render$1d(_ctx, _cache, $props, $setup, $data, $options) {
  return withDirectives((openBlock(), createBlock("div", {
    class: ["el-carousel__item", {
      'is-active': $setup.active,
      'el-carousel__item--card': $setup.parentType === 'card',
      'is-in-stage': $setup.inStage,
      'is-hover': $setup.hover,
      'is-animating': $setup.animating
    }],
    onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleItemClick(...args))),
    style: $setup.itemStyle
  }, [
    ($setup.parentType === 'card')
      ? withDirectives((openBlock(), createBlock("div", _hoisted_1$P, null, 512 /* NEED_PATCH */)), [
          [vShow, !$setup.active]
        ])
      : createCommentVNode("v-if", true),
    renderSlot(_ctx.$slots, "default")
  ], 6 /* CLASS, STYLE */)), [
    [vShow, $setup.ready]
  ])
}

script$1m.render = render$1d;
script$1m.__file = "packages/carousel-item/CarouselItem.vue";

/* istanbul ignore next */

script$1m.install = function (app) {
  app.component(script$1m.name, script$1m);
};

var script$1n = {
  name: 'ElCollapse',
  componentName: 'ElCollapse',
  props: {
    accordion: Boolean,
    modelValue: {
      type: [Array, String, Number],

      default() {
        return [];
      }

    }
  },
  emits: ['update:modelValue', 'change'],

  setup(props, context) {
    const instance = getCurrentInstance();
    const state = reactive({
      activeNames: [].concat(props.modelValue)
    });
    provide('collapse', instance);
    const {
      on
    } = useEmitter();
    watch(() => props.modelValue, value => {
      state.activeNames = [].concat(value);
    });
    onBeforeMount(() => {
      on('item-click', handleItemClick);
    });

    function setActiveNames(activeNames) {
      activeNames = [].concat(activeNames);
      const value = props.accordion ? activeNames[0] : activeNames;
      state.activeNames = activeNames;
      context.emit('update:modelValue', value);
      context.emit('change', value);
    }

    function handleItemClick(item) {
      const {
        name
      } = item;

      if (props.accordion) {
        setActiveNames((state.activeNames[0] || state.activeNames[0] === 0) && state.activeNames[0] === name ? '' : name);
      } else {
        const activeNames = state.activeNames.slice(0);
        const index = activeNames.indexOf(name);

        if (index > -1) {
          activeNames.splice(index, 1);
        } else {
          activeNames.push(name);
        }

        setActiveNames(activeNames);
      }
    }

    return { ...toRefs(state),
      setActiveNames,
      handleItemClick
    };
  }

};

const _hoisted_1$Q = {
  class: "el-collapse",
  role: "tablist",
  "aria-multiselectable": "true"
};

function render$1e(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", _hoisted_1$Q, [
    renderSlot(_ctx.$slots, "default")
  ]))
}

script$1n.render = render$1e;
script$1n.__file = "packages/collapse/src/collapse.vue";

/* istanbul ignore next */

script$1n.install = function (app) {
  app.component(script$1n.name, script$1n);
};

var script$1o = {
  name: 'ElCollapseItem',
  componentName: 'ElCollapseItem',
  components: {
    ElCollapseTransition
  },
  props: {
    title: String,
    name: {
      type: [String, Number],

      default() {
        return '';
      }

    },
    disabled: Boolean
  },

  setup(props) {
    const state = reactive({
      contentWrapStyle: {
        height: 'auto',
        display: 'block'
      },
      contentHeight: 0,
      focusing: false,
      isClick: false,
      id: generateId()
    });
    const instance = getCurrentInstance();
    const collapse = inject('collapse');
    const {
      dispatch
    } = useEmitter();
    const isActive = computed(() => {
      const name = props.name || props.name === 0 ? props.name : instance.uid;
      return collapse.ctx.activeNames.indexOf(name) > -1;
    });

    function handleFocus() {
      setTimeout(() => {
        if (!state.isClick) {
          state.focusing = true;
        } else {
          state.isClick = false;
        }
      }, 50);
    }

    function handleHeaderClick() {
      if (props.disabled) return;
      const name = props.name || props.name === 0 ? props.name : instance.uid;
      dispatch('item-click', {
        name
      });
      state.focusing = false;
      state.isClick = true;
    }

    function handleEnterClick() {
      const name = props.name || props.name === 0 ? props.name : instance.uid;
      dispatch('item-click', {
        name
      });
    }

    return { ...toRefs(state),
      isActive,
      handleFocus,
      handleHeaderClick,
      handleEnterClick
    };
  }

};

const _hoisted_1$R = { class: "el-collapse-item__content" };

function render$1f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_collapse_transition = resolveComponent("el-collapse-transition");

  return (openBlock(), createBlock("div", {
    class: ["el-collapse-item", { 'is-active': $setup.isActive, 'is-disabled': $props.disabled }]
  }, [
    createVNode("div", {
      role: "tab",
      "aria-expanded": $setup.isActive,
      "aria-controls": `el-collapse-content-${_ctx.id}`,
      "aria-describedby": `el-collapse-content-${_ctx.id}`
    }, [
      createVNode("div", {
        class: ["el-collapse-item__header", {
          focusing: _ctx.focusing,
          'is-active': $setup.isActive
        }],
        onClick: _cache[1] || (_cache[1] = (...args) => ($setup.handleHeaderClick(...args))),
        role: "button",
        id: `el-collapse-head-${_ctx.id}`,
        tabindex: $props.disabled ? undefined : 0,
        onKeyup: _cache[2] || (_cache[2] = withKeys(withModifiers((...args) => ($setup.handleEnterClick(...args)), ["stop"]), ["space","enter"])),
        onFocus: _cache[3] || (_cache[3] = (...args) => ($setup.handleFocus(...args))),
        onBlur: _cache[4] || (_cache[4] = $event => (_ctx.focusing = false))
      }, [
        renderSlot(_ctx.$slots, "title", {}, () => [
          createTextVNode(toDisplayString($props.title), 1 /* TEXT */)
        ]),
        createVNode("i", {
          class: ["el-collapse-item__arrow el-icon-arrow-right", { 'is-active': $setup.isActive }]
        }, null, 2 /* CLASS */)
      ], 42 /* CLASS, PROPS, HYDRATE_EVENTS */, ["id", "tabindex"])
    ], 8 /* PROPS */, ["aria-expanded", "aria-controls", "aria-describedby"]),
    createVNode(_component_el_collapse_transition, null, {
      default: withCtx(() => [
        withDirectives(createVNode("div", {
          class: "el-collapse-item__wrap",
          role: "tabpanel",
          "aria-hidden": !$setup.isActive,
          "aria-labelledby": `el-collapse-head-${_ctx.id}`,
          id: `el-collapse-content-${_ctx.id}`
        }, [
          createVNode("div", _hoisted_1$R, [
            renderSlot(_ctx.$slots, "default")
          ])
        ], 8 /* PROPS */, ["aria-hidden", "aria-labelledby", "id"]), [
          [vShow, $setup.isActive]
        ])
      ]),
      _: 3
    })
  ], 2 /* CLASS */))
}

script$1o.render = render$1f;
script$1o.__file = "packages/collapse/src/collapse-item.vue";

/* istanbul ignore next */

script$1o.install = function (app) {
  app.component(script$1o.name, script$1o);
};

var script$1p = {
  name: 'ElTimeline',
  props: {
    reverse: {
      type: Boolean,
      default: false
    }
  },

  provide() {
    return {
      timeline: this
    };
  },

  render() {
    const reverse = this.reverse;
    const classes = {
      'el-timeline': true,
      'is-reverse': reverse
    };
    let slots;

    if (this.$slots.default) {
      slots = this.$slots.default();
      let children;

      if (slots.length > 0 && slots[0].type === Fragment) {
        children = slots[0].children;
      } else {
        children = slots;
      }

      if (reverse) {
        children.reverse();
      }
    }

    return createVNode("ul", {
      "class": classes
    }, [slots]);
  }

};

script$1p.__file = "packages/timeline/Timeline.vue";

/* istanbul ignore next */

script$1p.install = function (app) {
  app.component(script$1p.name, script$1p);
};

var script$1q = {
  name: 'ElTimelineItem',
  inject: ['timeline'],
  props: {
    timestamp: String,
    hideTimestamp: {
      type: Boolean,
      default: false
    },
    placement: {
      type: String,
      default: 'bottom'
    },
    type: String,
    color: String,
    size: {
      type: String,
      default: 'normal'
    },
    icon: String
  }
};

const _hoisted_1$S = { class: "el-timeline-item" };
const _hoisted_2$w = /*#__PURE__*/createVNode("div", { class: "el-timeline-item__tail" }, null, -1 /* HOISTED */);
const _hoisted_3$o = {
  key: 1,
  class: "el-timeline-item__dot"
};
const _hoisted_4$e = { class: "el-timeline-item__wrapper" };
const _hoisted_5$b = {
  key: 0,
  class: "el-timeline-item__timestamp is-top"
};
const _hoisted_6$5 = { class: "el-timeline-item__content" };
const _hoisted_7$3 = {
  key: 1,
  class: "el-timeline-item__timestamp is-bottom"
};

function render$1g(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("li", _hoisted_1$S, [
    _hoisted_2$w,
    (!_ctx.$slots.dot)
      ? (openBlock(), createBlock("div", {
          key: 0,
          class: ["el-timeline-item__node", [
        `el-timeline-item__node--${$props.size || ''}`,
        `el-timeline-item__node--${$props.type || ''}`
      ]],
          style: {
        backgroundColor: $props.color
      }
        }, [
          ($props.icon)
            ? (openBlock(), createBlock("i", {
                key: 0,
                class: ["el-timeline-item__icon", $props.icon]
              }, null, 2 /* CLASS */))
            : createCommentVNode("v-if", true)
        ], 6 /* CLASS, STYLE */))
      : createCommentVNode("v-if", true),
    (_ctx.$slots.dot)
      ? (openBlock(), createBlock("div", _hoisted_3$o, [
          renderSlot(_ctx.$slots, "dot")
        ]))
      : createCommentVNode("v-if", true),
    createVNode("div", _hoisted_4$e, [
      (!$props.hideTimestamp && $props.placement === 'top')
        ? (openBlock(), createBlock("div", _hoisted_5$b, toDisplayString($props.timestamp), 1 /* TEXT */))
        : createCommentVNode("v-if", true),
      createVNode("div", _hoisted_6$5, [
        renderSlot(_ctx.$slots, "default")
      ]),
      (!$props.hideTimestamp && $props.placement === 'bottom')
        ? (openBlock(), createBlock("div", _hoisted_7$3, toDisplayString($props.timestamp), 1 /* TEXT */))
        : createCommentVNode("v-if", true)
    ])
  ]))
}

script$1q.render = render$1g;
script$1q.__file = "packages/timeline-item/TimelineItem.vue";

/* istanbul ignore next */

script$1q.install = function (app) {
  app.component(script$1q.name, script$1q);
};

var script$1r = {
  name: 'ElDivider',
  props: {
    direction: {
      type: String,
      default: 'horizontal',

      validator(val) {
        return ['horizontal', 'vertical'].indexOf(val) !== -1;
      }

    },
    contentPosition: {
      type: String,
      default: 'center',

      validator(val) {
        return ['left', 'center', 'right'].indexOf(val) !== -1;
      }

    }
  }
};

function render$1h(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock("div", mergeProps(_ctx.$attrs, {
    class: ['el-divider', `el-divider--${$props.direction}`]
  }), [
    (_ctx.$slots.default && $props.direction !== 'vertical')
      ? (openBlock(), createBlock("div", {
          key: 0,
          class: ['el-divider__text', `is-${$props.contentPosition}`]
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2 /* CLASS */))
      : createCommentVNode("v-if", true)
  ], 16 /* FULL_PROPS */))
}

script$1r.render = render$1h;
script$1r.__file = "packages/divider/Divider.vue";

/* istanbul ignore next */

script$1r.install = function (app) {
  app.component(script$1r.name, script$1r);
};

var date$1 = createCommonjsModule(function (module) {
/* Modified from https://github.com/taylorhakes/fecha
 *
 * The MIT License (MIT)
 *
 * Copyright (c) 2015 Taylor Hakes
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 *     The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 *     THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 *     FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 *     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

/*eslint-disable*/
// 把 YYYY-MM-DD 改成了 yyyy-MM-dd
(function (main) {
  /**
   * Parse or format dates
   * @class fecha
   */

  var fecha = {};
  var token = /d{1,4}|M{1,4}|yy(?:yy)?|S{1,3}|Do|ZZ|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
  var twoDigits = '\\d\\d?';
  var threeDigits = '\\d{3}';
  var fourDigits = '\\d{4}';
  var word = '[^\\s]+';
  var literal = /\[([^]*?)\]/gm;

  var noop = function () {};

  function regexEscape(str) {
    return str.replace(/[|\\{()[^$+*?.-]/g, '\\$&');
  }

  function shorten(arr, sLen) {
    var newArr = [];

    for (var i = 0, len = arr.length; i < len; i++) {
      newArr.push(arr[i].substr(0, sLen));
    }

    return newArr;
  }

  function monthUpdate(arrName) {
    return function (d, v, i18n) {
      var index = i18n[arrName].indexOf(v.charAt(0).toUpperCase() + v.substr(1).toLowerCase());

      if (~index) {
        d.month = index;
      }
    };
  }

  function pad(val, len) {
    val = String(val);
    len = len || 2;

    while (val.length < len) {
      val = '0' + val;
    }

    return val;
  }

  var dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
  var monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
  var monthNamesShort = shorten(monthNames, 3);
  var dayNamesShort = shorten(dayNames, 3);
  fecha.i18n = {
    dayNamesShort: dayNamesShort,
    dayNames: dayNames,
    monthNamesShort: monthNamesShort,
    monthNames: monthNames,
    amPm: ['am', 'pm'],
    DoFn: function DoFn(D) {
      return D + ['th', 'st', 'nd', 'rd'][D % 10 > 3 ? 0 : (D - D % 10 !== 10) * D % 10];
    }
  };
  var formatFlags = {
    D: function (dateObj) {
      return dateObj.getDay();
    },
    DD: function (dateObj) {
      return pad(dateObj.getDay());
    },
    Do: function (dateObj, i18n) {
      return i18n.DoFn(dateObj.getDate());
    },
    d: function (dateObj) {
      return dateObj.getDate();
    },
    dd: function (dateObj) {
      return pad(dateObj.getDate());
    },
    ddd: function (dateObj, i18n) {
      return i18n.dayNamesShort[dateObj.getDay()];
    },
    dddd: function (dateObj, i18n) {
      return i18n.dayNames[dateObj.getDay()];
    },
    M: function (dateObj) {
      return dateObj.getMonth() + 1;
    },
    MM: function (dateObj) {
      return pad(dateObj.getMonth() + 1);
    },
    MMM: function (dateObj, i18n) {
      return i18n.monthNamesShort[dateObj.getMonth()];
    },
    MMMM: function (dateObj, i18n) {
      return i18n.monthNames[dateObj.getMonth()];
    },
    yy: function (dateObj) {
      return pad(String(dateObj.getFullYear()), 4).substr(2);
    },
    yyyy: function (dateObj) {
      return pad(dateObj.getFullYear(), 4);
    },
    h: function (dateObj) {
      return dateObj.getHours() % 12 || 12;
    },
    hh: function (dateObj) {
      return pad(dateObj.getHours() % 12 || 12);
    },
    H: function (dateObj) {
      return dateObj.getHours();
    },
    HH: function (dateObj) {
      return pad(dateObj.getHours());
    },
    m: function (dateObj) {
      return dateObj.getMinutes();
    },
    mm: function (dateObj) {
      return pad(dateObj.getMinutes());
    },
    s: function (dateObj) {
      return dateObj.getSeconds();
    },
    ss: function (dateObj) {
      return pad(dateObj.getSeconds());
    },
    S: function (dateObj) {
      return Math.round(dateObj.getMilliseconds() / 100);
    },
    SS: function (dateObj) {
      return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
    },
    SSS: function (dateObj) {
      return pad(dateObj.getMilliseconds(), 3);
    },
    a: function (dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
    },
    A: function (dateObj, i18n) {
      return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
    },
    ZZ: function (dateObj) {
      var o = dateObj.getTimezoneOffset();
      return (o > 0 ? '-' : '+') + pad(Math.floor(Math.abs(o) / 60) * 100 + Math.abs(o) % 60, 4);
    }
  };
  var parseFlags = {
    d: [twoDigits, function (d, v) {
      d.day = v;
    }],
    Do: [twoDigits + word, function (d, v) {
      d.day = parseInt(v, 10);
    }],
    M: [twoDigits, function (d, v) {
      d.month = v - 1;
    }],
    yy: [twoDigits, function (d, v) {
      var da = new Date(),
          cent = +('' + da.getFullYear()).substr(0, 2);
      d.year = '' + (v > 68 ? cent - 1 : cent) + v;
    }],
    h: [twoDigits, function (d, v) {
      d.hour = v;
    }],
    m: [twoDigits, function (d, v) {
      d.minute = v;
    }],
    s: [twoDigits, function (d, v) {
      d.second = v;
    }],
    yyyy: [fourDigits, function (d, v) {
      d.year = v;
    }],
    S: ['\\d', function (d, v) {
      d.millisecond = v * 100;
    }],
    SS: ['\\d{2}', function (d, v) {
      d.millisecond = v * 10;
    }],
    SSS: [threeDigits, function (d, v) {
      d.millisecond = v;
    }],
    D: [twoDigits, noop],
    ddd: [word, noop],
    MMM: [word, monthUpdate('monthNamesShort')],
    MMMM: [word, monthUpdate('monthNames')],
    a: [word, function (d, v, i18n) {
      var val = v.toLowerCase();

      if (val === i18n.amPm[0]) {
        d.isPm = false;
      } else if (val === i18n.amPm[1]) {
        d.isPm = true;
      }
    }],
    ZZ: ['[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z', function (d, v) {
      var parts = (v + '').match(/([+-]|\d\d)/gi),
          minutes;

      if (parts) {
        minutes = +(parts[1] * 60) + parseInt(parts[2], 10);
        d.timezoneOffset = parts[0] === '+' ? minutes : -minutes;
      }
    }]
  };
  parseFlags.dd = parseFlags.d;
  parseFlags.dddd = parseFlags.ddd;
  parseFlags.DD = parseFlags.D;
  parseFlags.mm = parseFlags.m;
  parseFlags.hh = parseFlags.H = parseFlags.HH = parseFlags.h;
  parseFlags.MM = parseFlags.M;
  parseFlags.ss = parseFlags.s;
  parseFlags.A = parseFlags.a; // Some common format strings

  fecha.masks = {
    default: 'ddd MMM dd yyyy HH:mm:ss',
    shortDate: 'M/D/yy',
    mediumDate: 'MMM d, yyyy',
    longDate: 'MMMM d, yyyy',
    fullDate: 'dddd, MMMM d, yyyy',
    shortTime: 'HH:mm',
    mediumTime: 'HH:mm:ss',
    longTime: 'HH:mm:ss.SSS'
  };
  /***
   * Format a date
   * @method format
   * @param {Date|number} dateObj
   * @param {string} mask Format of the date, i.e. 'mm-dd-yy' or 'shortDate'
   */

  fecha.format = function (dateObj, mask, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof dateObj === 'number') {
      dateObj = new Date(dateObj);
    }

    if (Object.prototype.toString.call(dateObj) !== '[object Date]' || isNaN(dateObj.getTime())) {
      throw new Error('Invalid Date in fecha.format');
    }

    mask = fecha.masks[mask] || mask || fecha.masks['default'];
    var literals = []; // Make literals inactive by replacing them with ??

    mask = mask.replace(literal, function ($0, $1) {
      literals.push($1);
      return '@@@';
    }); // Apply formatting rules

    mask = mask.replace(token, function ($0) {
      return $0 in formatFlags ? formatFlags[$0](dateObj, i18n) : $0.slice(1, $0.length - 1);
    }); // Inline literal values back into the formatted value

    return mask.replace(/@@@/g, function () {
      return literals.shift();
    });
  };
  /**
   * Parse a date string into an object, changes - into /
   * @method parse
   * @param {string} dateStr Date string
   * @param {string} format Date parse format
   * @returns {Date|boolean}
   */


  fecha.parse = function (dateStr, format, i18nSettings) {
    var i18n = i18nSettings || fecha.i18n;

    if (typeof format !== 'string') {
      throw new Error('Invalid format in fecha.parse');
    }

    format = fecha.masks[format] || format; // Avoid regular expression denial of service, fail early for really long strings
    // https://www.owasp.org/index.php/Regular_expression_Denial_of_Service_-_ReDoS

    if (dateStr.length > 1000) {
      return null;
    }

    var dateInfo = {};
    var parseInfo = [];
    var literals = [];
    format = format.replace(literal, function ($0, $1) {
      literals.push($1);
      return '@@@';
    });
    var newFormat = regexEscape(format).replace(token, function ($0) {
      if (parseFlags[$0]) {
        var info = parseFlags[$0];
        parseInfo.push(info[1]);
        return '(' + info[0] + ')';
      }

      return $0;
    });
    newFormat = newFormat.replace(/@@@/g, function () {
      return literals.shift();
    });
    var matches = dateStr.match(new RegExp(newFormat, 'i'));

    if (!matches) {
      return null;
    }

    for (var i = 1; i < matches.length; i++) {
      parseInfo[i - 1](dateInfo, matches[i], i18n);
    }

    var today = new Date();

    if (dateInfo.isPm === true && dateInfo.hour != null && +dateInfo.hour !== 12) {
      dateInfo.hour = +dateInfo.hour + 12;
    } else if (dateInfo.isPm === false && +dateInfo.hour === 12) {
      dateInfo.hour = 0;
    }

    var date;

    if (dateInfo.timezoneOffset != null) {
      dateInfo.minute = +(dateInfo.minute || 0) - +dateInfo.timezoneOffset;
      date = new Date(Date.UTC(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0));
    } else {
      date = new Date(dateInfo.year || today.getFullYear(), dateInfo.month || 0, dateInfo.day || 1, dateInfo.hour || 0, dateInfo.minute || 0, dateInfo.second || 0, dateInfo.millisecond || 0);
    }

    return date;
  };
  /* istanbul ignore next */


  if ( module.exports) {
    module.exports = fecha;
  } else {
    main.fecha = fecha;
  }
})(commonjsGlobal);
});

const weeks = ['sun', 'mon', 'tue', 'wed', 'thu', 'fri', 'sat'];
const months = ['jan', 'feb', 'mar', 'apr', 'may', 'jun', 'jul', 'aug', 'sep', 'oct', 'nov', 'dec'];

const getI18nSettings = () => {
  return {
    dayNamesShort: weeks.map(week => t(`el.datepicker.weeks.${week}`)),
    dayNames: weeks.map(week => t(`el.datepicker.weeks.${week}`)),
    monthNamesShort: months.map(month => t(`el.datepicker.months.${month}`)),
    monthNames: months.map((month, index) => t(`el.datepicker.month${index + 1}`)),
    amPm: ['am', 'pm']
  };
};
const getFirstDayOfMonth = function (date) {
  const temp = new Date(date.getTime());
  temp.setDate(1);
  return temp.getDay();
}; // see: https://stackoverflow.com/questions/3674539/incrementing-a-date-in-javascript
const getPrevMonthLastDays = (date, amount) => {
  if (amount <= 0) return [];
  const temp = new Date(date.getTime());
  temp.setDate(0);
  const lastDay = temp.getDate();
  return range$1(amount).map((_, index) => lastDay - (amount - index - 1));
};
const getMonthDays = date => {
  const temp = new Date(date.getFullYear(), date.getMonth() + 1, 0);
  const days = temp.getDate();
  return range$1(days).map((_, index) => index + 1);
};
const range$1 = function (n) {
  // see https://stackoverflow.com/questions/3746725/create-a-javascript-array-containing-1-n
  return Array.apply(null, {
    length: n
  }).map((_, n) => n);
};
const validateRangeInOneMonth = function (start, end) {
  return start.getMonth() === end.getMonth() && start.getFullYear() === end.getFullYear();
};

var script$1s = {
  props: {
    selectedDay: String,
    // formated date yyyy-MM-dd
    range: {
      type: Array,

      validator(val) {
        if (!(val && val.length)) return true;
        const [start, end] = val;
        return validateRangeInOneMonth(start, end);
      }

    },
    date: Date,
    hideHeader: Boolean,
    firstDayOfWeek: Number
  },

  setup(props, {
    emit
  }) {
    const {
      selectedDay,
      date,
      hideHeader,
      firstDayOfWeek
    } = toRefs(props);
    const WEEK_DAYS = ref(getI18nSettings().dayNames);
    const elCalendar = inject('elCalendar'); // methods

    const toNestedArr = days => {
      return range$1(days.length / 7).map((_, index) => {
        const start = index * 7;
        return days.slice(start, start + 7);
      });
    };

    const getFormateDate = (day, type) => {
      if (!day || ['prev', 'current', 'next'].indexOf(type) === -1) {
        throw new Error('invalid day or type');
      }

      let prefix = curMonthDatePrefix.value;

      if (type === 'prev') {
        prefix = prevMonthDatePrefix.value;
      } else if (type === 'next') {
        prefix = nextMonthDatePrefix.value;
      }

      day = `00${day}`.slice(-2);
      return `${prefix}-${day}`;
    };

    const getCellClass = ({
      text,
      type
    }) => {
      const classes = [type];

      if (type === 'current') {
        const date = getFormateDate(text, type);

        if (date === selectedDay.value) {
          classes.push('is-selected');
        }

        if (date === formatedToday.value) {
          classes.push('is-today');
        }
      }

      return classes;
    };

    const pickDay = ({
      text,
      type
    }) => {
      const date = getFormateDate(text, type);
      emit('pick', date);
    };

    const cellRenderProxy = ({
      text,
      type
    }) => {
      const render = elCalendar.slots.default;
      if (!render) return createVNode("span", null, [text]);
      const day = getFormateDate(text, type);
      const date = new Date(day);
      const data = {
        isSelected: selectedDay.value === day,
        type: `${type}-month`,
        day
      };
      return render({
        date,
        data
      });
    }; // computed


    const prevMonthDatePrefix = computed(() => {
      const temp = new Date(date.value.getTime());
      temp.setDate(0);
      return date$1.format(temp, 'yyyy-MM');
    });
    const curMonthDatePrefix = computed(() => {
      return date$1.format(date.value, 'yyyy-MM');
    });
    const nextMonthDatePrefix = computed(() => {
      const temp = new Date(date.value.getFullYear(), date.value.getMonth() + 1, 1);
      return date$1.format(temp, 'yyyy-MM');
    });
    const formatedToday = computed(() => {
      return elCalendar.formatedToday;
    });
    const isInRange = computed(() => {
      return props.range && props.range.length;
    });
    const rows = computed(() => {
      let days = []; // if range exists, should render days in range.

      if (isInRange.value) {
        const [start, end] = props.range;
        const currentMonthRange = range$1(end.getDate() - start.getDate() + 1).map((_, index) => ({
          text: start.getDate() + index,
          type: 'current'
        }));
        let remaining = currentMonthRange.length % 7;
        remaining = remaining === 0 ? 0 : 7 - remaining;
        const nextMonthRange = range$1(remaining).map((_, index) => ({
          text: index + 1,
          type: 'next'
        }));
        days = currentMonthRange.concat(nextMonthRange);
      } else {
        let firstDay = getFirstDayOfMonth(date.value);
        firstDay = firstDay === 0 ? 7 : firstDay;

        const _firstDayOfWeek = typeof firstDayOfWeek.value === 'number' ? firstDayOfWeek.value : 1;

        const prevMonthDays = getPrevMonthLastDays(date.value, firstDay - _firstDayOfWeek).map(day => ({
          text: day,
          type: 'prev'
        }));
        const currentMonthDays = getMonthDays(date.value).map(day => ({
          text: day,
          type: 'current'
        }));
        days = [...prevMonthDays, ...currentMonthDays];
        const nextMonthDays = range$1(42 - days.length).map((_, index) => ({
          text: index + 1,
          type: 'next'
        }));
        days = days.concat(nextMonthDays);
      }

      return toNestedArr(days);
    });
    const weekDays = computed(() => {
      const start = firstDayOfWeek.value;

      if (typeof start !== 'number' || start === 0) {
        return WEEK_DAYS.value.slice();
      } else {
        return WEEK_DAYS.value.slice(start).concat(WEEK_DAYS.value.slice(0, start));
      }
    });
    return () => {
      const instance = getCurrentInstance();
      const thead = hideHeader.value ? null : createVNode("thead", null, [weekDays.value.map(day => createVNode("th", {
        "key": day
      }, [day]))]);
      return createVNode("table", {
        "class": {
          'el-calendar-table': true,
          'is-range': isInRange.value
        },
        "cellspacing": "0",
        "cellpadding": "0"
      }, [thead, createVNode("tbody", null, [rows.value.map((row, index) => createVNode("tr", {
        "class": {
          'el-calendar-table__row': true,
          'el-calendar-table__row--hide-border': index === 0 && hideHeader.value
        },
        "key": index
      }, [row.map((cell, key) => createVNode("td", {
        "key": key,
        "class": getCellClass(cell),
        "onClick": pickDay.bind(instance, cell)
      }, [createVNode("div", {
        "class": "el-calendar-day"
      }, [cellRenderProxy(cell)])]))]))])]);
    };
  }

};

script$1s.__file = "packages/calendar/DateTable.vue";

const validTypes = ['prev-month', 'today', 'next-month'];
const weekDays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
const oneDay = 86400000;
var script$1t = {
  name: 'ElCalendar',
  components: {
    DateTable: script$1s,
    ElButton: script$7,
    ElButtonGroup: script$8
  },
  props: {
    modelValue: [Date, String, Number],
    range: {
      type: Array,

      validator(range) {
        if (Array.isArray(range)) {
          return range.length === 2 && range.every(item => typeof item === 'string' || typeof item === 'number' || item instanceof Date);
        } else {
          return true;
        }
      }

    },
    firstDayOfWeek: {
      type: Number,
      default: 1
    }
  },
  emits: ['input', 'update:modelValue'],

  setup(props, {
    emit
  }) {
    const instance = getCurrentInstance();
    provide('elCalendar', instance);
    const state = reactive({
      selectedDay: '',
      now: new Date()
    });
    const t = useLocale(); // computed

    const prevMonthDatePrefix = computed(() => {
      const temp = new Date(date.value.getTime());
      temp.setDate(0);
      return date$1.format(temp, 'yyyy-MM');
    });
    const curMonthDatePrefix = computed(() => {
      return date$1.format(date.value, 'yyyy-MM');
    });
    const nextMonthDatePrefix = computed(() => {
      const temp = new Date(date.value.getFullYear(), date.value.getMonth() + 1, 1);
      return date$1.format(temp, 'yyyy-MM');
    });
    const formatedDate = computed(() => {
      return date$1.format(date.value, 'yyyy-MM-dd');
    });
    const i18nDate = computed(() => {
      const year = date.value.getFullYear();
      const month = date.value.getMonth() + 1;
      const pickedMonth = 'el.datepicker.month' + month;
      return `${year} ${t('el.datepicker.year')} ${t(pickedMonth)}`;
    });
    const formatedToday = computed(() => {
      return date$1.format(state.now, 'yyyy-MM-dd');
    });
    const realSelectedDay = computed({
      get() {
        if (!props.modelValue) return state.selectedDay;
        return formatedDate.value;
      },

      set(val) {
        state.selectedDay = val;
        const date = new Date(val);
        emit('input', date);
        emit('update:modelValue', date);
      }

    });
    const date = computed(() => {
      if (!props.modelValue) {
        if (realSelectedDay.value) {
          const d = state.selectedDay.split('-');
          return new Date(d[0], d[1] - 1, d[2]);
        } else if (validatedRange.value.length) {
          return validatedRange.value[0][0];
        }

        return state.now;
      } else {
        return toDate(props.modelValue);
      }
    });
    const validatedRange = computed(() => {
      let range = props.range;
      if (!range) return [];
      range = props.range && range.reduce((prev, val, index) => {
        const date = toDate(val);

        if (rangeValidator(date, index === 0)) {
          prev = prev.concat(date);
        }

        return prev;
      }, []);

      if (range.length === 2) {
        const [start, end] = range;

        if (start > end) {
          console.warn('[ElementCalendar]end time should be greater than start time');
          return [];
        } // start time and end time in one month


        if (validateRangeInOneMonth(start, end)) {
          return [[start, end]];
        }

        const data = [];
        let startDay = new Date(start.getFullYear(), start.getMonth() + 1, 1);
        const lastDay = toDate(startDay.getTime() - oneDay);

        if (!validateRangeInOneMonth(startDay, end)) {
          console.warn('[ElementCalendar]start time and end time interval must not exceed two months');
          return [];
        } // 第一个月的时间范围


        data.push([start, lastDay]); // 下一月的时间范围，需要计算一下该月的第一个周起始日

        const firstDayOfWeek = realFirstDayOfWeek.value;
        const nextMontFirstDay = startDay.getDay();
        let interval = 0;

        if (nextMontFirstDay !== firstDayOfWeek) {
          if (firstDayOfWeek === 0) {
            interval = 7 - nextMontFirstDay;
          } else {
            interval = firstDayOfWeek - nextMontFirstDay;
            interval = interval > 0 ? interval : 7 + interval;
          }
        }

        startDay = toDate(startDay.getTime() + interval * oneDay);

        if (startDay.getDate() < end.getDate()) {
          data.push([startDay, end]);
        }

        return data;
      }

      return [];
    }); // if range is valid, we get a two-digit array

    const realFirstDayOfWeek = computed(() => {
      if (props.firstDayOfWeek < 1 || props.firstDayOfWeek > 6) {
        return 0;
      }

      return Math.floor(props.firstDayOfWeek);
    }); // methods;

    const pickDay = day => {
      realSelectedDay.value = day;
    };

    const selectDate = type => {
      if (validTypes.indexOf(type) === -1) {
        throw new Error(`invalid type ${type}`);
      }

      let day = '';

      if (type === 'prev-month') {
        day = `${prevMonthDatePrefix.value}-01`;
      } else if (type === 'next-month') {
        day = `${nextMonthDatePrefix.value}-01`;
      } else {
        day = formatedToday.value;
      }

      if (day === formatedDate.value) return;
      pickDay(day);
    };

    const toDate = val => {
      if (!val) {
        throw new Error('invalid val');
      }

      return val instanceof Date ? val : new Date(val);
    };

    const rangeValidator = (date, isStart) => {
      const firstDayOfWeek = realFirstDayOfWeek.value;
      const expected = isStart ? firstDayOfWeek : firstDayOfWeek === 0 ? 6 : firstDayOfWeek - 1;
      const message = `${isStart ? 'start' : 'end'} of range should be ${weekDays[expected]}.`;

      if (date.getDay() !== expected) {
        console.warn('[ElementCalendar]', message, 'Invalid range will be ignored.');
        return false;
      }

      return true;
    };

    return { ...toRefs(state),
      prevMonthDatePrefix,
      curMonthDatePrefix,
      nextMonthDatePrefix,
      formatedDate,
      i18nDate,
      formatedToday,
      realSelectedDay,
      date,
      validatedRange,
      realFirstDayOfWeek,
      pickDay,
      selectDate,
      toDate,
      t,
      rangeValidator
    };
  }

};

const _hoisted_1$T = { class: "el-calendar" };
const _hoisted_2$x = { class: "el-calendar__header" };
const _hoisted_3$p = { class: "el-calendar__title" };
const _hoisted_4$f = {
  key: 0,
  class: "el-calendar__button-group"
};
const _hoisted_5$c = {
  key: 0,
  class: "el-calendar__body"
};
const _hoisted_6$6 = {
  key: 1,
  class: "el-calendar__body"
};

function render$1i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_button = resolveComponent("el-button");
  const _component_el_button_group = resolveComponent("el-button-group");
  const _component_date_table = resolveComponent("date-table");

  return (openBlock(), createBlock("div", _hoisted_1$T, [
    createVNode("div", _hoisted_2$x, [
      createVNode("div", _hoisted_3$p, toDisplayString($setup.i18nDate), 1 /* TEXT */),
      ($setup.validatedRange.length === 0)
        ? (openBlock(), createBlock("div", _hoisted_4$f, [
            createVNode(_component_el_button_group, null, {
              default: withCtx(() => [
                createVNode(_component_el_button, {
                  type: "plain",
                  size: "mini",
                  onClick: _cache[1] || (_cache[1] = $event => ($setup.selectDate('prev-month')))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($setup.t('el.datepicker.prevMonth')), 1 /* TEXT */)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_button, {
                  type: "plain",
                  size: "mini",
                  onClick: _cache[2] || (_cache[2] = $event => ($setup.selectDate('today')))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($setup.t('el.datepicker.today')), 1 /* TEXT */)
                  ]),
                  _: 1
                }),
                createVNode(_component_el_button, {
                  type: "plain",
                  size: "mini",
                  onClick: _cache[3] || (_cache[3] = $event => ($setup.selectDate('next-month')))
                }, {
                  default: withCtx(() => [
                    createTextVNode(toDisplayString($setup.t('el.datepicker.nextMonth')), 1 /* TEXT */)
                  ]),
                  _: 1
                })
              ]),
              _: 1
            })
          ]))
        : createCommentVNode("v-if", true)
    ]),
    ($setup.validatedRange.length === 0)
      ? (openBlock(), createBlock("div", _hoisted_5$c, [
          createVNode(_component_date_table, {
            date: $setup.date,
            "selected-day": $setup.realSelectedDay,
            "first-day-of-week": $setup.realFirstDayOfWeek,
            onPick: $setup.pickDay
          }, null, 8 /* PROPS */, ["date", "selected-day", "first-day-of-week", "onPick"])
        ]))
      : (openBlock(), createBlock("div", _hoisted_6$6, [
          (openBlock(true), createBlock(Fragment, null, renderList($setup.validatedRange, (range, index) => {
            return (openBlock(), createBlock(_component_date_table, {
              key: index,
              date: range[0],
              "selected-day": $setup.realSelectedDay,
              range: range,
              "hide-header": index !== 0,
              "first-day-of-week": $setup.realFirstDayOfWeek,
              onPick: $setup.pickDay
            }, null, 8 /* PROPS */, ["date", "selected-day", "range", "hide-header", "first-day-of-week", "onPick"]))
          }), 128 /* KEYED_FRAGMENT */))
        ]))
  ]))
}

script$1t.render = render$1i;
script$1t.__file = "packages/calendar/Calendar.vue";

/* istanbul ignore next */

script$1t.install = function (app) {
  app.component(script$1t.name, script$1t);
};

const Mode = {
  CONTAIN: {
    name: 'contain',
    icon: 'el-icon-full-screen'
  },
  ORIGINAL: {
    name: 'original',
    icon: 'el-icon-c-scale-to-original'
  }
};
const mousewheelEventName$1 = isFirefox() ? 'DOMMouseScroll' : 'mousewheel';
var script$1u = {
  name: 'elImageViewer',
  props: {
    urlList: {
      type: Array,
      default: () => []
    },
    zIndex: {
      type: Number,
      default: 2000
    },
    onSwitch: {
      type: Function,
      default: () => {}
    },
    onClose: {
      type: Function,
      default: () => {}
    },
    initialIndex: {
      type: Number,
      default: 0
    }
  },

  setup(props) {
    const img = ref(null);
    const imageWrapper = ref(null); // data

    const state = reactive({
      mode: Mode.CONTAIN,
      transform: {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: false
      }
    });
    const index = ref(props.initialIndex);
    let loading = ref(false);
    const infinite = ref(true);
    const isShow = ref(true); // computed

    const isSingle = computed(() => props.urlList.length <= 1);
    const isFirst = computed(() => props.index === 0);
    const isLast = computed(() => props.index === props.urlList.length - 1);
    const currentImg = computed(() => props.urlList[index.value]);
    const imgStyle = computed(() => {
      const {
        scale,
        deg,
        offsetX,
        offsetY,
        enableTransition
      } = state.transform;
      const style = {
        transform: `scale(${scale}) rotate(${deg}deg)`,
        transition: enableTransition ? 'transform .3s' : '',
        'margin-left': `${offsetX}px`,
        'margin-top': `${offsetY}px`
      };

      if (state.mode.name === Mode.CONTAIN.name) {
        style.maxWidth = style.maxHeight = '100%';
      }

      return style;
    }); // lifeC

    onMounted(() => {
      deviceSupportInstall(); // add tabindex then wrapper can be focusable via Javascript
      // focus wrapper so arrow key can't cause inner scroll behavior underneath

      imageWrapper.value.focus();
    }); // watch

    watch(index, val => {
      reset();
      props.onSwitch(val);
    });
    watch(currentImg, () => {
      nextTick(() => {
        if (img.value.complete) {
          loading = true;
        }
      });
    }); // methods

    const handleActions = (action, options = {}) => {
      if (loading.value) return;
      const {
        zoomRate,
        rotateDeg,
        enableTransition
      } = {
        zoomRate: 0.2,
        rotateDeg: 90,
        enableTransition: true,
        ...options
      };

      switch (action) {
        case 'zoomOut':
          if (state.transform.scale > 0.2) {
            state.transform.scale = parseFloat((state.transform.scale - zoomRate).toFixed(3));
          }

          break;

        case 'zoomIn':
          state.transform.scale = parseFloat((state.transform.scale + zoomRate).toFixed(3));
          break;

        case 'clocelise':
          state.transform.deg += rotateDeg;
          break;

        case 'anticlocelise':
          state.transform.deg -= rotateDeg;
          break;
      }

      state.transform.enableTransition = enableTransition;
    };

    const reset = () => {
      state.transform = {
        scale: 1,
        deg: 0,
        offsetX: 0,
        offsetY: 0,
        enableTransition: false
      };
    };

    const toggleMode = () => {
      if (loading.value) return;
      const modeNames = Object.keys(Mode);
      const modeValues = Object.values(Mode);
      const index = modeValues.findIndex(index => index.name === state.mode.name);
      const nextIndex = (index + 1) % modeNames.length;
      state.mode = Mode[modeNames[nextIndex]];
      reset();
    };

    const prev = () => {
      if (isFirst.value && !infinite.value) return;
      const len = props.urlList.length;
      index.value = (index.value - 1 + len) % len;
    };

    const next = () => {
      if (isLast.value && !infinite.value) return;
      const len = props.urlList.length;
      index.value = (index.value + 1) % len;
    };

    let keyDownHandler = rafThrottle(e => {
      const keyCode = e.keyCode;

      switch (keyCode) {
        // ESC
        case 27:
          hide();
          break;
        // SPACE

        case 32:
          toggleMode();
          break;
        // LEFT_ARROW

        case 37:
          prev();
          break;
        // UP_ARROW

        case 38:
          handleActions('zoomIn');
          break;
        // RIGHT_ARROW

        case 39:
          next();
          break;
        // DOWN_ARROW

        case 40:
          handleActions('zoomOut');
          break;
      }
    });
    let mouseWheelHandler = rafThrottle(e => {
      const delta = e.wheelDelta ? e.wheelDelta : -e.detail;

      if (delta > 0) {
        handleActions('zoomIn', {
          zoomRate: 0.015,
          enableTransition: false
        });
      } else {
        handleActions('zoomOut', {
          zoomRate: 0.015,
          enableTransition: false
        });
      }
    });

    const deviceSupportInstall = () => {
      on(document, 'keydown', keyDownHandler);
      on(document, mousewheelEventName$1, mouseWheelHandler);
    };

    const deviceSupportUninstall = () => {
      off(document, 'keydown', keyDownHandler);
      off(document, mousewheelEventName$1, mouseWheelHandler);
      keyDownHandler = null;
      mouseWheelHandler = null;
    };

    const hide = () => {
      deviceSupportUninstall();
      props.onClose();
    };

    const handleImgLoad = () => {
      loading = false;
    };

    const handleImgError = e => {
      loading = false;
      e.target.alt = '加载失败';
    };

    const handleMouseDown = e => {
      if (loading || e.button !== 0) return;
      const {
        offsetX,
        offsetY
      } = state.transform;
      const startX = e.pageX;
      const startY = e.pageY;

      const _dragHandler = rafThrottle(ev => {
        state.transform.offsetX = offsetX + ev.pageX - startX;
        state.transform.offsetY = offsetY + ev.pageY - startY;
      });

      on(document, 'mousemove', _dragHandler);
      on(document, 'mouseup', () => {
        off(document, 'mousemove', _dragHandler);
      });
      e.preventDefault();
    };

    return {
      img,
      imageWrapper,
      loading,
      isShow,
      state,
      infinite,
      index,
      isSingle,
      isFirst,
      isLast,
      currentImg,
      imgStyle,
      reset,
      next,
      prev,
      toggleMode,
      handleActions,
      hide,
      keyDownHandler,
      mouseWheelHandler,
      deviceSupportInstall,
      deviceSupportUninstall,
      handleImgLoad,
      handleImgError,
      handleMouseDown
    };
  }

};

const _hoisted_1$U = /*#__PURE__*/createVNode("div", { class: "el-image-viewer__mask" }, null, -1 /* HOISTED */);
const _hoisted_2$y = /*#__PURE__*/createVNode("i", { class: "el-icon-circle-close" }, null, -1 /* HOISTED */);
const _hoisted_3$q = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-left" }, null, -1 /* HOISTED */);
const _hoisted_4$g = /*#__PURE__*/createVNode("i", { class: "el-icon-arrow-right" }, null, -1 /* HOISTED */);
const _hoisted_5$d = { class: "el-image-viewer__btn el-image-viewer__actions" };
const _hoisted_6$7 = { class: "el-image-viewer__actions__inner" };
const _hoisted_7$4 = /*#__PURE__*/createVNode("i", { class: "el-image-viewer__actions__divider" }, null, -1 /* HOISTED */);
const _hoisted_8$3 = /*#__PURE__*/createVNode("i", { class: "el-image-viewer__actions__divider" }, null, -1 /* HOISTED */);
const _hoisted_9$2 = { class: "el-image-viewer__canvas" };

function render$1j(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, { name: "viewer-fade" }, {
    default: withCtx(() => [
      createVNode("div", {
        tabindex: "-1",
        ref: "imageWrapper",
        class: "el-image-viewer__wrapper",
        style: { 'z-index': $props.zIndex }
      }, [
        _hoisted_1$U,
        createCommentVNode(" CLOSE "),
        createVNode("span", {
          class: "el-image-viewer__btn el-image-viewer__close",
          onClick: _cache[1] || (_cache[1] = (...args) => ($setup.hide(...args)))
        }, [
          _hoisted_2$y
        ]),
        createCommentVNode(" ARROW "),
        (!$setup.isSingle)
          ? (openBlock(), createBlock(Fragment, { key: 0 }, [
              createVNode("span", {
                class: ["el-image-viewer__btn el-image-viewer__prev", { 'is-disabled': !$setup.infinite && $setup.isFirst }],
                onClick: _cache[2] || (_cache[2] = (...args) => ($setup.prev(...args)))
              }, [
                _hoisted_3$q
              ], 2 /* CLASS */),
              createVNode("span", {
                class: ["el-image-viewer__btn el-image-viewer__next", { 'is-disabled': !$setup.infinite && $setup.isLast }],
                onClick: _cache[3] || (_cache[3] = (...args) => ($setup.next(...args)))
              }, [
                _hoisted_4$g
              ], 2 /* CLASS */)
            ], 64 /* STABLE_FRAGMENT */))
          : createCommentVNode("v-if", true),
        createCommentVNode(" ACTIONS "),
        createVNode("div", _hoisted_5$d, [
          createVNode("div", _hoisted_6$7, [
            createVNode("i", {
              class: "el-icon-zoom-out",
              onClick: _cache[4] || (_cache[4] = $event => ($setup.handleActions('zoomOut')))
            }),
            createVNode("i", {
              class: "el-icon-zoom-in",
              onClick: _cache[5] || (_cache[5] = $event => ($setup.handleActions('zoomIn')))
            }),
            _hoisted_7$4,
            createVNode("i", {
              class: $setup.state.mode.icon,
              onClick: _cache[6] || (_cache[6] = (...args) => ($setup.toggleMode(...args)))
            }, null, 2 /* CLASS */),
            _hoisted_8$3,
            createVNode("i", {
              class: "el-icon-refresh-left",
              onClick: _cache[7] || (_cache[7] = $event => ($setup.handleActions('anticlocelise')))
            }),
            createVNode("i", {
              class: "el-icon-refresh-right",
              onClick: _cache[8] || (_cache[8] = $event => ($setup.handleActions('clocelise')))
            })
          ])
        ]),
        createCommentVNode(" CANVAS "),
        createVNode("div", _hoisted_9$2, [
          createVNode("img", {
            ref: "img",
            class: "el-image-viewer__img",
            src: $setup.currentImg,
            style: $setup.imgStyle,
            onLoad: _cache[9] || (_cache[9] = (...args) => ($setup.handleImgLoad(...args))),
            onError: _cache[10] || (_cache[10] = (...args) => ($setup.handleImgError(...args))),
            onMousedown: _cache[11] || (_cache[11] = (...args) => ($setup.handleMouseDown(...args)))
          }, null, 44 /* STYLE, PROPS, HYDRATE_EVENTS */, ["src"])
        ])
      ], 4 /* STYLE */)
    ]),
    _: 1
  }))
}

script$1u.render = render$1j;
script$1u.__file = "packages/image/ImageViewer.vue";

const isSupportObjectFit = () => document.documentElement.style.objectFit !== undefined;

const ObjectFit = {
  NONE: 'none',
  CONTAIN: 'contain',
  COVER: 'cover',
  FILL: 'fill',
  SCALE_DOWN: 'scale-down'
};
let prevOverflow = '';
var script$1v = {
  name: 'ElImage',
  inheritAttrs: false,
  components: {
    ImageViewer: script$1u
  },
  props: {
    src: String,
    fit: String,
    lazy: Boolean,
    scrollContainer: {},
    previewSrcList: {
      type: Array,
      default: () => []
    },
    zIndex: {
      type: Number,
      default: 2000
    }
  },
  emits: ['error'],

  setup(props, ctx) {
    const instance = getCurrentInstance();
    const loading = ref(true);
    const error = ref(false);
    const show = ref(!props.lazy);
    const showViewer = ref(false);
    const imageWidth = ref(0);
    const imageHeight = ref(0); // computed

    const imageStyle = computed(() => {
      const {
        fit
      } = props;

      if ( //! this.$isServer &&
      fit) {
        return isSupportObjectFit() ? {
          'object-fit': fit
        } : getImageStyle(fit);
      }

      return {};
    });
    const alignCenter = computed(() => {
      return (// !this.$isServer &&
        !isSupportObjectFit() && props.fit !== ObjectFit.FILL
      );
    });
    const preview = computed(() => {
      const {
        previewSrcList
      } = props;
      return Array.isArray(previewSrcList) && previewSrcList.length > 0;
    });
    const imageIndex = computed(() => {
      let previewIndex = 0;
      const srcIndex = props.previewSrcList.indexOf(props.src);

      if (srcIndex >= 0) {
        previewIndex = srcIndex;
      }

      return previewIndex;
    }); // watch

    watch(() => props.src, () => {
      show.value && loadImage();
    });
    watch(show, val => {
      val && loadImage();
    }); // lifecycle

    onMounted(() => {
      if (props.lazy) {
        addLazyLoadListener();
      } else {
        loadImage();
      }
    });
    onBeforeUnmount(() => {
      props.lazy && removeLazyLoadListener();
    }); // methods

    const loadImage = () => {
      // if (this.$isServer) return
      // reset status
      loading.value = true;
      error.value = false;
      const img = new Image();

      img.onload = e => handleLoad(e, img);

      img.onerror = handleError.bind(this); // bind html attrs
      // so it can behave consistently

      Object.keys(instance.ctx.$attrs).forEach(key => {
        const value = instance.ctx.$attrs[key];
        img.setAttribute(key, value);
      });
      img.src = props.src;
    };

    const handleLoad = (e, img) => {
      imageWidth.value = img.width;
      imageHeight.value = img.height;
      loading.value = false;
      error.value = false;
    };

    const handleError = e => {
      loading.value = false;
      error.value = true;
      ctx.emit('error', e);
    };

    const handleLazyLoad = () => {
      if (isInContainer(instance.ctx.$el, instance.ctx._scrollContainer)) {
        show.value = true;
        removeLazyLoadListener();
      }
    };

    const addLazyLoadListener = () => {
      // if (this.$isServer) return
      const {
        scrollContainer
      } = props;
      let _scrollContainer = null;

      if (isHtmlElement(scrollContainer)) {
        _scrollContainer = scrollContainer;
      } else if (isString(scrollContainer)) {
        _scrollContainer = document.querySelector(scrollContainer);
      } else {
        _scrollContainer = getScrollContainer(instance.ctx.$el);
      }

      if (_scrollContainer) {
        instance.ctx._scrollContainer = _scrollContainer;
        instance.ctx._lazyLoadHandler = throttle$1(200, handleLazyLoad);
        on(_scrollContainer, 'scroll', instance.ctx._lazyLoadHandler);
        handleLazyLoad();
      }
    };

    const removeLazyLoadListener = () => {
      const {
        _scrollContainer,
        _lazyLoadHandler
      } = instance.ctx;
      if ( // this.$isServer ||
      !_scrollContainer || !_lazyLoadHandler) return;
      off(_scrollContainer, 'scroll', _lazyLoadHandler);
      instance.ctx._scrollContainer = null;
      instance.ctx._lazyLoadHandler = null;
    };
    /**
     * simulate object-fit behavior to compatible with IE11 and other browsers which not support object-fit
     */


    const getImageStyle = fit => {
      const {
        clientWidth: containerWidth,
        clientHeight: containerHeight
      } = instance.ctx.$el;
      if (!imageWidth.value || !imageHeight.value || !containerWidth || !containerHeight) return {};
      const vertical = imageWidth.value / imageHeight.value < 1;

      if (fit === ObjectFit.SCALE_DOWN) {
        const isSmaller = imageWidth.value < containerWidth && imageHeight.value < containerHeight;
        fit = isSmaller ? ObjectFit.NONE : ObjectFit.CONTAIN;
      }

      switch (fit) {
        case ObjectFit.NONE:
          return {
            width: 'auto',
            height: 'auto'
          };

        case ObjectFit.CONTAIN:
          return vertical ? {
            width: 'auto'
          } : {
            height: 'auto'
          };

        case ObjectFit.COVER:
          return vertical ? {
            height: 'auto'
          } : {
            width: 'auto'
          };

        default:
          return {};
      }
    };

    const clickHandler = () => {
      // don't show viewer when preview is false
      if (!preview.value) {
        return;
      } // prevent body scroll


      prevOverflow = document.body.style.overflow;
      document.body.style.overflow = 'hidden';
      showViewer.value = true;
    };

    const closeViewer = () => {
      document.body.style.overflow = prevOverflow;
      showViewer.value = false;
    };

    return {
      loading,
      error,
      show,
      showViewer,
      imageWidth,
      imageHeight,
      imageStyle,
      alignCenter,
      preview,
      imageIndex,
      loadImage,
      handleLoad,
      handleError,
      handleLazyLoad,
      getImageStyle,
      addLazyLoadListener,
      removeLazyLoadListener,
      clickHandler,
      closeViewer,
      t
    };
  }

};

const _hoisted_1$V = { class: "el-image" };
const _hoisted_2$z = /*#__PURE__*/createVNode("div", { class: "el-image__placeholder" }, null, -1 /* HOISTED */);
const _hoisted_3$r = { class: "el-image__error" };

function render$1k(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_image_viewer = resolveComponent("image-viewer");

  return (openBlock(), createBlock("div", _hoisted_1$V, [
    ($setup.loading)
      ? renderSlot(_ctx.$slots, "placeholder", { key: 0 }, () => [
          _hoisted_2$z
        ])
      : ($setup.error)
        ? renderSlot(_ctx.$slots, "error", { key: 1 }, () => [
            createVNode("div", _hoisted_3$r, toDisplayString($setup.t('el.image.error')), 1 /* TEXT */)
          ])
        : (openBlock(), createBlock("img", mergeProps({
            key: 2,
            class: "el-image__inner"
          }, _ctx.$attrs, {
            onClick: _cache[1] || (_cache[1] = (...args) => ($setup.clickHandler(...args))),
            src: $props.src,
            style: $setup.imageStyle,
            class: {
        'el-image__inner--center': $setup.alignCenter,
        'el-image__preview': $setup.preview
      }
          }), null, 16 /* FULL_PROPS */, ["src"])),
    ($setup.preview)
      ? (openBlock(), createBlock(Fragment, { key: 3 }, [
          ($setup.showViewer)
            ? (openBlock(), createBlock(_component_image_viewer, {
                key: 0,
                "z-index": $props.zIndex,
                "initial-index": $setup.imageIndex,
                "on-close": $setup.closeViewer,
                "url-list": $props.previewSrcList
              }, null, 8 /* PROPS */, ["z-index", "initial-index", "on-close", "url-list"]))
            : createCommentVNode("v-if", true)
        ], 64 /* STABLE_FRAGMENT */))
      : createCommentVNode("v-if", true)
  ]))
}

script$1v.render = render$1k;
script$1v.__file = "packages/image/Image.vue";

/* istanbul ignore next */

script$1v.install = function (app) {
  app.component(script$1v.name, script$1v);
};

const cubic = value => Math.pow(value, 3);

const easeInOutCubic = value => value < 0.5 ? cubic(value * 2) / 2 : 1 - cubic((1 - value) * 2) / 2;

var script$1w = {
  name: 'ElBacktop',
  components: {
    ElIcon: script$6
  },
  props: {
    visibilityHeight: {
      type: Number,
      default: 200
    },
    target: {
      type: String,
      default: null
    },
    right: {
      type: Number,
      default: 40
    },
    bottom: {
      type: Number,
      default: 40
    }
  },

  setup(props, {
    emit
  }) {
    const el = ref(null);
    const container = ref(null);
    const visible = ref(null);
    let throttledScrollHandler;
    const {
      visibilityHeight,
      target,
      right,
      bottom
    } = toRefs(props);
    const styleBottom = computed(() => `${bottom.value}px`);
    const styleRight = computed(() => `${right.value}px`);

    const init = () => {
      container.value = document;
      el.value = document.documentElement;

      if (target.value) {
        el.value = document.querySelector(target.value);

        if (!el.value) {
          throw new Error(`target is not existed: ${target.value}`);
        }

        container.value = el.value;
      }
    };

    const onScroll = () => {
      const scrollTop = el.value.scrollTop;
      visible.value = scrollTop >= visibilityHeight.value;
    };

    const handleClick = e => {
      scrollToTop();
      emit('click', e);
    };

    const scrollToTop = () => {
      const element = el.value;
      const beginTime = Date.now();
      const beginValue = element.scrollTop;

      const rAF = window.requestAnimationFrame || (func => setTimeout(func, 16));

      const frameFunc = () => {
        const progress = (Date.now() - beginTime) / 500;

        if (progress < 1) {
          element.scrollTop = beginValue * (1 - easeInOutCubic(progress));
          rAF(frameFunc);
        } else {
          element.scrollTop = 0;
        }
      };

      rAF(frameFunc);
    };

    onMounted(() => {
      init();
      throttledScrollHandler = throttle$1(300, onScroll);
      container.value.addEventListener('scroll', throttledScrollHandler);
    });
    onUnmounted(() => {
      container.value.removeEventListener('scroll', throttledScrollHandler);
    });
    return {
      visible,
      styleBottom,
      styleRight,
      handleClick
    };
  }

};

function render$1l(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_icon = resolveComponent("el-icon");

  return (openBlock(), createBlock(Transition, { name: "el-fade-in" }, {
    default: withCtx(() => [
      ($setup.visible)
        ? (openBlock(), createBlock("div", {
            key: 0,
            onClick: _cache[1] || (_cache[1] = withModifiers((...args) => ($setup.handleClick(...args)), ["stop"])),
            style: {
        right: $setup.styleRight,
        bottom: $setup.styleBottom
      },
            class: "el-backtop"
          }, [
            renderSlot(_ctx.$slots, "default", {}, () => [
              createVNode(_component_el_icon, { name: "caret-top" })
            ])
          ], 4 /* STYLE */))
        : createCommentVNode("v-if", true)
    ]),
    _: 1
  }))
}

script$1w.render = render$1l;
script$1w.__file = "packages/backtop/Backtop.vue";

/* istanbul ignore next */

script$1w.install = function (app) {
  app.component(script$1w.name, script$1w);
};

const getStyleComputedProperty$1 = (element, property) => {
  if (element === window) {
    element = document.documentElement;
  }

  if (element.nodeType !== 1) {
    return [];
  } // NOTE: 1 DOM access here


  const css = window.getComputedStyle(element, null);
  return property ? css[property] : css;
};

const entries = obj => {
  return Object.keys(obj || {}).map(key => [key, obj[key]]);
};

const getPositionSize = (el, prop) => {
  return el === window || el === document ? document.documentElement[prop] : el[prop];
};

const getOffsetHeight = el => {
  return getPositionSize(el, 'offsetHeight');
};

const getClientHeight = el => {
  return getPositionSize(el, 'clientHeight');
};

const scope = 'ElInfiniteScroll';
const attributes = {
  delay: {
    type: Number,
    default: 200
  },
  distance: {
    type: Number,
    default: 0
  },
  disabled: {
    type: Boolean,
    default: false
  },
  immediate: {
    type: Boolean,
    default: true
  }
};

const getScrollOptions = el => {
  if (!isHtmlElement(el)) return {};
  return entries(attributes).reduce((map, [key, option]) => {
    const {
      type,
      default: defaultValue
    } = option;
    const attributeName = `infinite-scroll-${key}`;
    let value = el.hasAttribute(attributeName) ? el.getAttribute(attributeName) : defaultValue;

    switch (type) {
      case Number:
        value = Number(value);
        value = Number.isNaN(value) ? defaultValue : value;
        break;

      case Boolean:
        value = isDefined(value) ? value === 'false' ? false : Boolean(value) : defaultValue;
        break;

      default:
        value = type(value);
    }

    map[key] = value;
    return map;
  }, {});
};

const getElementTop = el => el.getBoundingClientRect().top;

const handleScroll = function (cb) {
  const {
    el,
    container,
    observer
  } = this[scope];
  const {
    distance,
    disabled
  } = getScrollOptions(el);
  if (disabled) return;
  const containerInfo = container.getBoundingClientRect();
  if (!containerInfo.width && !containerInfo.height) return;
  let shouldTrigger = false;

  if (container === el) {
    // be aware of difference between clientHeight & offsetHeight & window.getComputedStyle().height
    const scrollBottom = container.scrollTop + getClientHeight(container);
    shouldTrigger = container.scrollHeight - scrollBottom <= distance;
  } else {
    const heightBelowTop = getOffsetHeight(el) + getElementTop(el) - getElementTop(container);
    const offsetHeight = getOffsetHeight(container);
    const borderBottom = Number.parseFloat(getStyleComputedProperty$1(container, 'borderBottomWidth'));
    shouldTrigger = heightBelowTop - offsetHeight + borderBottom <= distance;
  }

  if (shouldTrigger && isFunction(cb)) {
    cb.call();
  } else if (observer) {
    observer.disconnect();
    this[scope].observer = null;
  }
};

var ElInfiniteScroll = {
  name: 'InfiniteScroll',

  mounted(el, binding) {
    const cb = binding.value; // only include vertical scroll

    const container = getScrollContainer(el, true);
    const {
      delay,
      immediate
    } = getScrollOptions(el);
    const onScroll = throttle$1(delay, handleScroll.bind(el, cb));
    el[scope] = {
      el,
      container,
      onScroll
    };

    if (container) {
      container.addEventListener('scroll', onScroll);

      if (immediate) {
        const observer = el[scope].observer = new MutationObserver(onScroll);
        observer.observe(container, {
          childList: true,
          subtree: true
        });
        onScroll();
      }
    }
  },

  unmounted(el) {
    const {
      container,
      onScroll
    } = el[scope];

    if (container) {
      container.removeEventListener('scroll', onScroll);
    }
  }

};

/* istanbul ignore next */

ElInfiniteScroll.install = function (app) {
  app.directive(ElInfiniteScroll.name, ElInfiniteScroll);
};

var script$1x = {
  name: 'ElDrawer',
  props: { ...popupProps,
    appendToBody: {
      type: Boolean,
      default: false
    },
    beforeClose: {
      type: Function
    },
    customClass: {
      type: String,
      default: ''
    },
    closeOnPressEscape: {
      type: Boolean,
      default: true
    },
    destroyOnClose: {
      type: Boolean,
      default: false
    },
    modal: {
      type: Boolean,
      default: true
    },
    direction: {
      type: String,
      default: 'rtl',

      validator(val) {
        return ['ltr', 'rtl', 'ttb', 'btt'].indexOf(val) !== -1;
      }

    },
    modalAppendToBody: {
      type: Boolean,
      default: true
    },
    showClose: {
      type: Boolean,
      default: true
    },
    size: {
      type: String,
      default: '30%'
    },
    title: {
      type: String,
      default: ''
    },
    visible: {
      type: Boolean
    },
    wrapperClosable: {
      type: Boolean,
      default: true
    },
    withHeader: {
      type: Boolean,
      default: true
    }
  },
  emits: ['update:visible', 'close', 'opened', 'open', 'closed'],

  setup(props, {
    emit
  }) {
    const {
      rendered,
      open
    } = usePopup(props);
    const {
      appendToBody,
      beforeClose,
      destroyOnClose,
      direction,
      visible,
      wrapperClosable
    } = toRefs(props);
    const closed = ref(false);
    const prevActiveElement = ref(null);
    const drawer = ref(null);
    const self = getCurrentInstance().proxy;
    const isHorizontal = computed(() => {
      return direction.value === 'rtl' || direction.value === 'ltr';
    });
    watch(visible, val => {
      const el = self.$el;

      if (val) {
        closed.value = false;
        emit('open');

        if (appendToBody.value) {
          document.body.appendChild(el);
        }

        prevActiveElement.value = document.activeElement;
        nextTick(() => {
          Utils.focusFirstDescendant(drawer.value);
        });
      } else {
        if (!closed.value) emit('close');
        nextTick(() => {
          if (prevActiveElement.value) {
            prevActiveElement.value.focus();
          }
        });
      }
    });

    const afterEnter = () => {
      emit('opened');
    };

    const afterLeave = () => {
      emit('closed');
    };

    const handleWrapperClick = () => {
      if (wrapperClosable.value) {
        closeDrawer();
      }
    };

    const closeDrawer = () => {
      if (beforeClose && typeof beforeClose.value === 'function') {
        beforeClose.value(hide);
      } else {
        hide();
      }
    };

    const hide = cancel => {
      if (cancel !== false) {
        emit('update:visible', false);
        emit('close');

        if (destroyOnClose.value === true) {
          rendered.value = false;
        }

        closed.value = true;
      }
    }; // todo: ESC 退出模态框,暂时无调用，lint过不去先在return调用


    const handleClose = () => {
      // This method here will be called by PopupManger, when the `closeOnPressEscape` was set to true
      // pressing `ESC` will call this method, and also close the drawer.
      // This method also calls `beforeClose` if there was one.
      closeDrawer();
    };

    onMounted(() => {
      if (visible.value) {
        rendered.value = true;
        open();
      }
    });
    onUnmounted(() => {
      // if appendToBody is true, remove DOM node after destroy
      if (appendToBody.value && self.$el && self.$el.parentNode) {
        self.$el.parentNode.removeChild(self.$el);
      }
    });
    return {
      isHorizontal,
      drawer,
      rendered,
      afterEnter,
      afterLeave,
      handleWrapperClick,
      closeDrawer,
      handleClose
    };
  }

};

const _hoisted_1$W = {
  class: "el-drawer__wrapper",
  tabindex: "-1"
};
const _hoisted_2$A = {
  key: 0,
  class: "el-drawer__header",
  id: "el-drawer__title"
};
const _hoisted_3$s = /*#__PURE__*/createVNode("i", { class: "el-dialog__close el-icon el-icon-close" }, null, -1 /* HOISTED */);
const _hoisted_4$h = {
  key: 1,
  class: "el-drawer__body"
};

function render$1m(_ctx, _cache, $props, $setup, $data, $options) {
  return (openBlock(), createBlock(Transition, {
    name: "el-drawer-fade",
    onAfterEnter: $setup.afterEnter,
    onAfterLeave: $setup.afterLeave
  }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", _hoisted_1$W, [
        createVNode("div", {
          class: ["el-drawer__container", $props.visible && 'el-drawer__open'],
          onClick: _cache[2] || (_cache[2] = withModifiers((...args) => ($setup.handleWrapperClick(...args)), ["self"])),
          role: "document",
          tabindex: "-1"
        }, [
          createVNode("div", {
            "aria-modal": "true",
            "aria-labelledby": "el-drawer__title",
            "aria-label": $props.title,
            class: ["el-drawer", [$props.direction, $props.customClass]],
            style: $setup.isHorizontal ? `width: ${$props.size}` : `height: ${$props.size}`,
            ref: "drawer",
            role: "dialog",
            tabindex: "-1"
          }, [
            ($props.withHeader)
              ? (openBlock(), createBlock("header", _hoisted_2$A, [
                  renderSlot(_ctx.$slots, "title", {}, () => [
                    createVNode("span", {
                      role: "heading",
                      tabindex: "0",
                      title: $props.title
                    }, toDisplayString($props.title), 9 /* TEXT, PROPS */, ["title"])
                  ]),
                  ($props.showClose)
                    ? (openBlock(), createBlock("button", {
                        key: 0,
                        "aria-label": `close ${$props.title || 'drawer'}`,
                        class: "el-drawer__close-btn",
                        type: "button",
                        onClick: _cache[1] || (_cache[1] = (...args) => ($setup.closeDrawer(...args)))
                      }, [
                        _hoisted_3$s
                      ], 8 /* PROPS */, ["aria-label"]))
                    : createCommentVNode("v-if", true)
                ]))
              : createCommentVNode("v-if", true),
            ($setup.rendered)
              ? (openBlock(), createBlock("section", _hoisted_4$h, [
                  renderSlot(_ctx.$slots, "default")
                ]))
              : createCommentVNode("v-if", true)
          ], 14 /* CLASS, STYLE, PROPS */, ["aria-label"])
        ], 2 /* CLASS */)
      ], 512 /* NEED_PATCH */), [
        [vShow, $props.visible]
      ])
    ]),
    _: 1
  }, 8 /* PROPS */, ["onAfterEnter", "onAfterLeave"]))
}

script$1x.render = render$1m;
script$1x.__file = "packages/drawer/Drawer.vue";

/* istanbul ignore next */

script$1x.install = function (app) {
  app.component(script$1x.name, script$1x);
};

var script$1y = {
  components: {
    ElScrollbar
  },
  mixins: [Popper$1, Emitter],
  componentName: 'ElAutocompleteSuggestions',

  data() {
    return {
      parent: this.$parent,
      dropdownWidth: ''
    };
  },

  props: {
    options: {
      default() {
        return {
          gpuAcceleration: false
        };
      }

    },
    id: String
  },
  methods: {
    select(item) {
      this.dispatch('ElAutocomplete', 'item-click', item);
    }

  },

  updated() {
    this.$nextTick(() => {
      this.popperJS && this.updatePopper();
    });
  },

  mounted() {
    this.$parent.popperElm = this.popperElm = this.$el;
    this.referenceElm = this.$parent.$refs.input.$refs.input || this.$parent.$refs.input.$refs.textarea;
    this.referenceList = this.$el.querySelector('.el-autocomplete-suggestion__list');
    this.referenceList.setAttribute('role', 'listbox');
    this.referenceList.setAttribute('id', this.id);
  },

  created() {
    // TODO $on 已经废弃了
    // eslint-disable-next-line vue/no-deprecated-events-api
    this.$on('visible', (val, inputWidth) => {
      this.dropdownWidth = inputWidth + 'px';
      this.showPopper = val;
    });
  }

};

const _hoisted_1$X = { key: 0 };
const _hoisted_2$B = /*#__PURE__*/createVNode("i", { class: "el-icon-loading" }, null, -1 /* HOISTED */);

function render$1n(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_scrollbar = resolveComponent("el-scrollbar");

  return (openBlock(), createBlock(Transition, {
    name: "el-zoom-in-top",
    onAfterLeave: _ctx.doDestroy
  }, {
    default: withCtx(() => [
      withDirectives(createVNode("div", {
        class: ["el-autocomplete-suggestion el-popper", { 'is-loading': !$data.parent.hideLoading && $data.parent.loading }],
        style: { width: $data.dropdownWidth },
        role: "region"
      }, [
        createVNode(_component_el_scrollbar, {
          tag: "ul",
          "wrap-class": "el-autocomplete-suggestion__wrap",
          "view-class": "el-autocomplete-suggestion__list"
        }, {
          default: withCtx(() => [
            (!$data.parent.hideLoading && $data.parent.loading)
              ? (openBlock(), createBlock("li", _hoisted_1$X, [
                  _hoisted_2$B
                ]))
              : renderSlot(_ctx.$slots, "default", { key: 1 })
          ]),
          _: 1
        })
      ], 6 /* CLASS, STYLE */), [
        [vShow, _ctx.showPopper]
      ])
    ]),
    _: 1
  }, 8 /* PROPS */, ["onAfterLeave"]))
}

script$1y.render = render$1n;
script$1y.__file = "packages/autocomplete/src/autocomplete-suggestions.vue";

var script$1z = {
  name: 'ElAutocomplete',
  mixins: [Emitter, Focus('input'), Migrating],
  inheritAttrs: false,
  componentName: 'ElAutocomplete',
  components: {
    ElInput: script$g,
    ElAutocompleteSuggestions: script$1y
  },
  directives: {
    Clickoutside
  },
  props: {
    valueKey: {
      type: String,
      default: 'value'
    },
    popperClass: String,
    popperOptions: Object,
    placeholder: String,
    clearable: {
      type: Boolean,
      default: false
    },
    disabled: Boolean,
    name: String,
    size: String,
    value: String,
    maxlength: Number,
    minlength: Number,
    autofocus: Boolean,
    fetchSuggestions: Function,
    triggerOnFocus: {
      type: Boolean,
      default: true
    },
    customItem: String,
    selectWhenUnmatched: {
      type: Boolean,
      default: false
    },
    prefixIcon: String,
    suffixIcon: String,
    label: String,
    debounce: {
      type: Number,
      default: 300
    },
    placement: {
      type: String,
      default: 'bottom-start'
    },
    hideLoading: Boolean,
    popperAppendToBody: {
      type: Boolean,
      default: true
    },
    highlightFirstItem: {
      type: Boolean,
      default: false
    }
  },

  data() {
    return {
      activated: false,
      suggestions: [],
      loading: false,
      highlightedIndex: -1,
      suggestionDisabled: false
    };
  },

  computed: {
    suggestionVisible() {
      const suggestions = this.suggestions;
      const isValidData = Array.isArray(suggestions) && suggestions.length > 0;
      return (isValidData || this.loading) && this.activated;
    },

    id() {
      return `el-autocomplete-${generateId()}`;
    }

  },
  watch: {
    suggestionVisible(val) {
      const $input = this.getInput();

      if ($input) {
        this.broadcast('visible', [val, $input.offsetWidth]);
      }
    }

  },
  methods: {
    getMigratingConfig() {
      return {
        props: {
          'custom-item': 'custom-item is removed, use scoped slot instead.',
          props: 'props is removed, use value-key instead.'
        }
      };
    },

    getData(queryString) {
      if (this.suggestionDisabled) {
        return;
      }

      this.loading = true;
      this.fetchSuggestions(queryString, suggestions => {
        this.loading = false;

        if (this.suggestionDisabled) {
          return;
        }

        if (Array.isArray(suggestions)) {
          this.suggestions = suggestions;
          this.highlightedIndex = this.highlightFirstItem ? 0 : -1;
        } else {
          console.error('[Element Error][Autocomplete]autocomplete suggestions must be an array');
        }
      });
    },

    handleInput(value) {
      this.$emit('input', value);
      this.suggestionDisabled = false;

      if (!this.triggerOnFocus && !value) {
        this.suggestionDisabled = true;
        this.suggestions = [];
        return;
      }

      this.debouncedGetData(value);
    },

    handleChange(value) {
      this.$emit('change', value);
    },

    handleFocus(event) {
      this.activated = true;
      this.$emit('focus', event);

      if (this.triggerOnFocus) {
        this.debouncedGetData(this.value);
      }
    },

    handleBlur(event) {
      this.$emit('blur', event);
    },

    handleClear() {
      this.activated = false;
      this.$emit('clear');
    },

    close() {
      this.activated = false;
    },

    handleKeyEnter(e) {
      if (this.suggestionVisible && this.highlightedIndex >= 0 && this.highlightedIndex < this.suggestions.length) {
        e.preventDefault();
        this.select(this.suggestions[this.highlightedIndex]);
      } else if (this.selectWhenUnmatched) {
        this.$emit('select', {
          value: this.value
        });
        this.$nextTick(() => {
          this.suggestions = [];
          this.highlightedIndex = -1;
        });
      }
    },

    select(item) {
      this.$emit('input', item[this.valueKey]);
      this.$emit('select', item);
      this.$nextTick(() => {
        this.suggestions = [];
        this.highlightedIndex = -1;
      });
    },

    highlight(index) {
      if (!this.suggestionVisible || this.loading) {
        return;
      }

      if (index < 0) {
        this.highlightedIndex = -1;
        return;
      }

      if (index >= this.suggestions.length) {
        index = this.suggestions.length - 1;
      }

      const suggestion = this.$refs.suggestions.$el.querySelector('.el-autocomplete-suggestion__wrap');
      const suggestionList = suggestion.querySelectorAll('.el-autocomplete-suggestion__list li');
      const highlightItem = suggestionList[index];
      const scrollTop = suggestion.scrollTop;
      const offsetTop = highlightItem.offsetTop;

      if (offsetTop + highlightItem.scrollHeight > scrollTop + suggestion.clientHeight) {
        suggestion.scrollTop += highlightItem.scrollHeight;
      }

      if (offsetTop < scrollTop) {
        suggestion.scrollTop -= highlightItem.scrollHeight;
      }

      this.highlightedIndex = index;
      const $input = this.getInput();
      $input.setAttribute('aria-activedescendant', `${this.id}-item-${this.highlightedIndex}`);
    },

    getInput() {
      return this.$refs.input.getInput();
    }

  },

  mounted() {
    this.debouncedGetData = debounce(this.debounce, this.getData); // TODO $on 已经废弃
    // eslint-disable-next-line vue/no-deprecated-events-api

    this.$on('item-click', item => {
      this.select(item);
    });
    const $input = this.getInput();
    $input.setAttribute('role', 'textbox');
    $input.setAttribute('aria-autocomplete', 'list');
    $input.setAttribute('aria-controls', 'id');
    $input.setAttribute('aria-activedescendant', `${this.id}-item-${this.highlightedIndex}`);
  },

  beforeUnmount() {
    this.$refs.suggestions.$destroy();
  }

};

function render$1o(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_el_input = resolveComponent("el-input");
  const _component_el_autocomplete_suggestions = resolveComponent("el-autocomplete-suggestions");
  const _directive_clickoutside = resolveDirective("clickoutside");

  return withDirectives((openBlock(), createBlock("div", {
    class: "el-autocomplete",
    "aria-haspopup": "listbox",
    role: "combobox",
    "aria-expanded": $options.suggestionVisible,
    "aria-owns": $options.id
  }, [
    createVNode(_component_el_input, mergeProps({ ref: "input" }, [_ctx.$props, _ctx.$attrs], {
      onInput: $options.handleInput,
      onChange: $options.handleChange,
      onFocus: $options.handleFocus,
      onBlur: $options.handleBlur,
      onClear: $options.handleClear,
      onKeydown: [
        _cache[1] || (_cache[1] = withKeys(withModifiers($event => ($options.highlight($data.highlightedIndex - 1)), ["prevent"]), ["up"])),
        _cache[2] || (_cache[2] = withKeys(withModifiers($event => ($options.highlight($data.highlightedIndex + 1)), ["prevent"]), ["down"])),
        withKeys($options.handleKeyEnter, ["enter"]),
        withKeys($options.close, ["tab"])
      ]
    }), createSlots({ _: 2 }, [
      (_ctx.$slots.prepend)
        ? {
            name: "prepend",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prepend")
            ])
          }
        : undefined,
      (_ctx.$slots.append)
        ? {
            name: "append",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "append")
            ])
          }
        : undefined,
      (_ctx.$slots.prefix)
        ? {
            name: "prefix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "prefix")
            ])
          }
        : undefined,
      (_ctx.$slots.suffix)
        ? {
            name: "suffix",
            fn: withCtx(() => [
              renderSlot(_ctx.$slots, "suffix")
            ])
          }
        : undefined
    ]), 1040 /* FULL_PROPS, DYNAMIC_SLOTS */, ["onInput", "onChange", "onFocus", "onBlur", "onClear", "onKeydown"]),
    createVNode(_component_el_autocomplete_suggestions, {
      "visible-arrow": "",
      class: [$props.popperClass ? $props.popperClass : ''],
      "popper-options": $props.popperOptions,
      "append-to-body": $props.popperAppendToBody,
      ref: "suggestions",
      placement: $props.placement,
      id: $options.id
    }, {
      default: withCtx(() => [
        (openBlock(true), createBlock(Fragment, null, renderList($data.suggestions, (item, index) => {
          return (openBlock(), createBlock("li", {
            key: index,
            class: { highlighted: $data.highlightedIndex === index },
            onClick: $event => ($options.select(item)),
            id: `${$options.id}-item-${index}`,
            role: "option",
            "aria-selected": $data.highlightedIndex === index
          }, [
            renderSlot(_ctx.$slots, "default", { item: item }, () => [
              createTextVNode(toDisplayString(item[$props.valueKey]), 1 /* TEXT */)
            ])
          ], 10 /* CLASS, PROPS */, ["onClick", "id", "aria-selected"]))
        }), 128 /* KEYED_FRAGMENT */))
      ]),
      _: 1
    }, 8 /* PROPS */, ["class", "popper-options", "append-to-body", "placement", "id"])
  ], 8 /* PROPS */, ["aria-expanded", "aria-owns"])), [
    [_directive_clickoutside, $options.close]
  ])
}

script$1z.render = render$1o;
script$1z.__file = "packages/autocomplete/src/autocomplete.vue";

/* istanbul ignore next */

script$1z.install = function (app) {
  app.component(script$1z.name, script$1z);
};

var version = "0.0.26";

// 用于构建时的入口
const components = [ElRow, script, script$2, script$3, script$4, script$5, script$Z, script$1, script$7, script$8, script$s, script$v, script$9, script$6, script$19, script$1a, script$1w, script$R, script$13, script$14, script$15, script$16, ElPagination, script$k, script$X, script$Y, script$1l, script$1m, script$17, script$18, script$1b, script$1c, script$1d, script$1e, script$1f, script$1g, ElLoading, script$K, script$M, script$O, ElTableColumn, script$a, script$b, script$c, script$d, script$e, script$f, script$g, script$h, script$l, script$q, script$p, script$u, // ElTimePicker,
// ElTimeSelect,
// ElDatePicker,
script$z, script$A, script$G, script$J, script$j, script$m, script$1h, ElTooltip, script$1i, script$1j, script$1k, script$1n, script$1o, script$1p, script$1q, script$1r, script$1t, script$1v, ElInfiniteScroll, script$1x, ElScrollbar, script$1z, ElCollapseTransition];

const install = (app, opts = {}) => {
  app.use(setupGlobalOptions(opts));
  components.forEach(component => {
    app.use(component);
  });
  applyOptions(app);
};

function applyOptions(app) {
  app.config.globalProperties.$loading = ElLoading.service;
  app.config.globalProperties.$msgbox = ElMessageBox.service;
  app.config.globalProperties.$alert = ElMessageBox.service.alert;
  app.config.globalProperties.$confirm = ElMessageBox.service.confirm;
  app.config.globalProperties.$prompt = ElMessageBox.service.prompt;
  app.config.globalProperties.$notify = ElNotification.service;
  app.config.globalProperties.$message = ElMessage.service;
}

const elementUI = {
  version,
  install
};

export default elementUI;
export { script$Z as ElAlert, script$4 as ElAside, script$1z as ElAutocomplete, script$Y as ElAvatar, script$1w as ElBacktop, script$X as ElBadge, script$19 as ElBreadcrumb, script$1a as ElBreadcrumbItem, script$7 as ElButton, script$8 as ElButtonGroup, script$1t as ElCalendar, script$1k as ElCard, script$1l as ElCarousel, script$1m as ElCarouselItem, script$q as ElCascader, script$p as ElCascaderPanel, script$d as ElCheckbox, script$e as ElCheckboxButton, script$f as ElCheckboxGroup, script as ElCol, script$1n as ElCollapse, script$1o as ElCollapseItem, ElCollapseTransition, script$G as ElColorPicker, script$1 as ElContainer, script$1h as ElDialog, script$1r as ElDivider, script$1x as ElDrawer, script$1c as ElDropdown, script$1d as ElDropdownItem, script$1e as ElDropdownMenu, script$3 as ElFooter, script$K as ElForm, script$M as ElFormItem, script$2 as ElHeader, script$6 as ElIcon, script$1v as ElImage, ElInfiniteScroll, script$g as ElInput, script$h as ElInputNumber, script$9 as ElLink, ElLoading, script$5 as ElMain, script$13 as ElMenu, script$14 as ElMenuItem, script$16 as ElMenuItemGroup, script$j as ElOption, script$m as ElOptionGroup, script$1b as ElPageHeader, ElPagination, script$1j as ElPopconfirm, script$1i as ElPopover, script$v as ElProgress, script$a as ElRadio, script$b as ElRadioButton, script$c as ElRadioGroup, script$A as ElRate, ElRow, ElScrollbar, script$l as ElSelect, script$u as ElSlider, script$1g as ElStep, script$1f as ElSteps, script$15 as ElSubmenu, script$s as ElSwitch, script$18 as ElTabPane, script$O as ElTable, ElTableColumn, script$17 as ElTabs, script$k as ElTag, script$1p as ElTimeline, script$1q as ElTimelineItem, ElTooltip, script$J as ElTransfer, script$R as ElTree, script$z as ElUpload, install, setupGlobalOptions, useLoading, useMessage, useMsgbox, useNotify };
